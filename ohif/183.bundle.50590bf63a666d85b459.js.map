{"version":3,"file":"183.bundle.50590bf63a666d85b459.js","mappings":"gHAGA,MAkQA,EAlQ8B,CAC5B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,C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,EAA8B,CAClC3iD,EAAS0D,cAAcg0B,EAAK,KAC5BylB,EACAzlB,EAAK,GACLA,EAAK,IAEDkrB,EAA8B,CAClC5iD,EAAS0D,cAAcg0B,EAAK,KAC5BylB,EACAzlB,EAAK,GACLA,EAAK,IAEDmrB,EAAgC,CACpC7iD,EAAS0D,cAAcg0B,EAAK,KAC5BylB,EACAzlB,EAAK,GACLA,EAAK,IAEDorB,EAA+B,CACnC9iD,EAAS0D,cAAcg0B,EAAK,KAC5BylB,EACAzlB,EAAK,GACLA,EAAK,IASP,GAPAoqB,EAAYl/C,KACV+/C,EACAC,EACAC,EACAC,IAICV,GAAcx3D,KAAKupB,cAAconC,QAAQljB,WACzCgqB,IACAI,GACDnF,GACA4E,EACA,CAEA,IAAIa,EAAY,GAAGd,QACnB,IAAA/pC,aACExlB,EACAZ,EACAixD,EACAT,EACA,CACE3yD,QACA6F,aAAc5K,KAAKupB,cAAconC,QAAQljB,QACrCztC,KAAKupB,cAAconC,QAAQ/lD,aAC3B,EACJC,QAAS7K,KAAKupB,cAAconC,QAAQljB,QAChCztC,KAAKupB,cAAconC,QAAQ9lD,QAC3B,EACJ5F,KAAM,WAGVkzD,EAAY,GAAGd,QACf,IAAA/pC,aACExlB,EACAZ,EACAixD,EACAL,EACA,CACE/yD,QACA6F,aAAc5K,KAAKupB,cAAconC,QAAQljB,QACrCztC,KAAKupB,cAAconC,QAAQ/lD,aAC3B,EACJC,QAAS7K,KAAKupB,cAAconC,QAAQljB,QAChCztC,KAAKupB,cAAconC,QAAQ9lD,QAC3B,EACJ5F,KAAM,Q,MAGL,GACLuyD,IACCC,IACAI,GACDnF,EACA,CACA,MAAMyF,EAAY,GAAGd,KAErB,IAAA/pC,aACExlB,EACAZ,EACAixD,EACAT,EACA,CACE3yD,QACA6F,aAAc5K,KAAKupB,cAAconC,QAAQljB,QACrCztC,KAAKupB,cAAconC,QAAQ/lD,aAC3B,EACJC,QAAS7K,KAAKupB,cAAconC,QAAQljB,QAChCztC,KAAKupB,cAAconC,QAAQ9lD,QAC3B,EACJ5F,KAAM,U,MAGL,GACLsyD,IACCE,I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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/constants/COLOR_LUT.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/elementCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/MouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/ImageMouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGCursorDescriptor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGMouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/setCursorForElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/_getHash.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/setAttributesIfNecessary.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/setNewAttributesIfValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawCircle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawEllipseByCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawHandle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawHandles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawPath.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawTextBox.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLink.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLinkedTextBox.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRect.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawArrow.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRedactionRect.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ChangeTypes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/Events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/SegmentationRepresentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/StrategyCallbacks.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/Touch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolBindings.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/AnnotationStyleStates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/WorkerTypes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/mouseToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/touchToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/annotationInterpolationEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/mouse/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/wheel/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/imageChangeEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationCompletedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationSelectionListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationModifiedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationRemovedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/init.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/cameraSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/presentationViewSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createPresentationViewSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/voiSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/imageSliceSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createImageSliceSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/slabThicknessSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createSlabThicknessSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/VideoRedactionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationLocking.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationSelection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationVisibility.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/ToolStyle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/helpers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/getState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/getFont.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/helpers/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/AnnotationGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/activeSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/clipAndCacheSurfacesForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/getRepresentationSpecificConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentationRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addRepresentationData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/convertStackToVolumeSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/convertVolumeToStackSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentLocking.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationColor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/computeAndAddRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/convertContourToSurface.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/convertLabelmapToSurface.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/updateSurfaceData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/convertContourToLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/convertSurfaceToLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/labelmapComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/utils/extractContourData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/utils/createAndAddContourSegmentationsFromClippedSurfaces.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/contourComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/canComputeRequestedRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/registerPolySegWorker.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/SegmentationStateManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentationState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/Synchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/createSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getAllSynchronizers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/destroySynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/addTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/addEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/removeEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/cancelActiveManipulations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/svgNodeCache.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationDisplayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/BaseTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/PanTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/TrackballRotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/WindowLevelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/StackScrollTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/PlanarRotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/StackScrollToolMouseWheelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ZoomTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/VolumeRotateMouseWheelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/MIPJumpToClickTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/CrosshairsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/MagnifyTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/AdvancedMagnifyTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ReferenceLinesTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/OverlayGridTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/SegmentationIntersectionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ReferenceCursors.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ScaleOverlayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LengthTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/ProbeTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/DragProbeTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/RectangleROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/EllipticalROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/CircleROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/SplineROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/SplineContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LivewireContourTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LivewireContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/ArrowAnnotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/AngleTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/CobbAngleTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/UltrasoundDirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/KeyImageTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/AnnotationEraserTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/CircleScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/SphereScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/CircleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/PaintFillTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/OrientationMarkerTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/SegmentSelectTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/BrushTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/strategies/utils/stackVolumeCheck.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/types/ContourAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/areSameSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/isContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/calculatePerimeter.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/findHandlePolylineIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/areCoplanarContours.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/contourFinder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getDeduplicatedVTKPolyDataPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/detectContourHoles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/AnnotationToPointData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/interpolation/acceptAutogeneratedInterpolations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/updateContourPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getSphereBoundsInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportsForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getAnnotationNearPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/getOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/invertOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/playClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/getDataInTime.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/polyData/utils.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/intersectAABB.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/isPointOnLineSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/mirror.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isClosed.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSignedArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getWindingDirection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal2.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLinesIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/combinePolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/intersectPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/decimate.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/projectTo2D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/findClosestPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planar/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointToString.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/scroll.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getUniqueSegmentIndices.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isValidRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushSizeForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createImageIdReferenceMap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isLineInSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/findLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createBidirectionalToolData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/segmentContourAction.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/invalidateBrushCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/triggerSegmentationRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForViewportIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToSlice.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js"],"sourcesContent":["/**\n * Cornerstone Color LUT used for Segmentations\n */\nconst CORNERSTONE_COLOR_LUT = [\n  [0, 0, 0, 0],\n  [221, 84, 84, 255],\n  [77, 228, 121, 255],\n  [166, 70, 235, 255],\n  [189, 180, 116, 255],\n  [109, 182, 196, 255],\n  [204, 101, 157, 255],\n  [123, 211, 94, 255],\n  [93, 87, 218, 255],\n  [225, 128, 80, 255],\n  [73, 232, 172, 255],\n  [181, 119, 186, 255],\n  [176, 193, 112, 255],\n  [105, 153, 200, 255],\n  [208, 97, 120, 255],\n  [90, 215, 101, 255],\n  [135, 83, 222, 255],\n  [229, 178, 76, 255],\n  [122, 183, 181, 255],\n  [190, 115, 171, 255],\n  [149, 197, 108, 255],\n  [100, 118, 205, 255],\n  [212, 108, 93, 255],\n  [86, 219, 141, 255],\n  [183, 79, 226, 255],\n  [233, 233, 72, 255],\n  [118, 167, 187, 255],\n  [194, 111, 146, 255],\n  [116, 201, 104, 255],\n  [115, 96, 209, 255],\n  [216, 147, 89, 255],\n  [82, 223, 188, 255],\n  [230, 75, 224, 255],\n  [163, 184, 121, 255],\n  [114, 143, 191, 255],\n  [198, 107, 114, 255],\n  [99, 206, 122, 255],\n  [153, 92, 213, 255],\n  [220, 192, 85, 255],\n  [78, 215, 227, 255],\n  [234, 71, 173, 255],\n  [141, 188, 117, 255],\n  [110, 113, 195, 255],\n  [202, 128, 103, 255],\n  [95, 210, 157, 255],\n  [195, 88, 217, 255],\n  [206, 224, 81, 255],\n  [74, 166, 231, 255],\n  [185, 120, 139, 255],\n  [113, 192, 113, 255],\n  [133, 106, 199, 255],\n  [207, 162, 98, 255],\n  [91, 214, 198, 255],\n  [221, 84, 198, 255],\n  [159, 228, 77, 255],\n  [70, 111, 235, 255],\n  [189, 119, 116, 255],\n  [109, 196, 138, 255],\n  [165, 101, 204, 255],\n  [211, 201, 94, 255],\n  [87, 191, 218, 255],\n  [225, 80, 153, 255],\n  [106, 232, 73, 255],\n  [124, 119, 186, 255],\n  [193, 142, 112, 255],\n  [105, 200, 168, 255],\n  [203, 97, 208, 255],\n  [184, 215, 90, 255],\n  [83, 147, 222, 255],\n  [229, 76, 101, 255],\n  [122, 183, 130, 255],\n  [146, 115, 190, 255],\n  [197, 171, 108, 255],\n  [100, 205, 205, 255],\n  [212, 93, 177, 255],\n  [141, 219, 86, 255],\n  [79, 97, 226, 255],\n  [233, 99, 72, 255],\n  [118, 187, 150, 255],\n  [173, 111, 194, 255],\n  [197, 201, 104, 255],\n  [96, 171, 209, 255],\n  [216, 89, 137, 255],\n  [94, 223, 82, 255],\n  [107, 75, 230, 255],\n  [184, 153, 121, 255],\n  [114, 191, 175, 255],\n  [198, 107, 191, 255],\n  [166, 206, 99, 255],\n  [92, 132, 213, 255],\n  [220, 85, 91, 255],\n  [78, 227, 115, 255],\n  [159, 71, 234, 255],\n  [188, 176, 117, 255],\n  [110, 185, 195, 255],\n  [202, 103, 161, 255],\n  [129, 210, 95, 255],\n  [88, 88, 217, 255],\n  [224, 123, 81, 255],\n  [74, 231, 166, 255],\n  [177, 120, 185, 255],\n  [179, 192, 113, 255],\n  [106, 156, 199, 255],\n  [207, 98, 125, 255],\n  [91, 214, 96, 255],\n  [130, 84, 221, 255],\n  [228, 171, 77, 255],\n  [70, 235, 221, 255],\n  [189, 116, 174, 255],\n  [153, 196, 109, 255],\n  [101, 123, 204, 255],\n  [211, 104, 94, 255],\n  [87, 218, 136, 255],\n  [177, 80, 225, 255],\n  [232, 225, 73, 255],\n  [119, 169, 186, 255],\n  [193, 112, 149, 255],\n  [121, 200, 105, 255],\n  [111, 97, 208, 255],\n  [215, 142, 90, 255],\n  [83, 222, 181, 255],\n  [229, 76, 229, 255],\n  [165, 183, 122, 255],\n  [115, 146, 190, 255],\n  [197, 108, 119, 255],\n  [100, 205, 118, 255],\n  [148, 93, 212, 255],\n  [219, 186, 86, 255],\n  [79, 220, 226, 255],\n  [233, 72, 179, 255],\n  [144, 187, 118, 255],\n  [111, 118, 194, 255],\n  [201, 124, 104, 255],\n  [96, 209, 153, 255],\n  [189, 89, 216, 255],\n  [211, 223, 82, 255],\n  [75, 172, 230, 255],\n  [184, 121, 142, 255],\n  [117, 191, 114, 255],\n  [130, 107, 198, 255],\n  [206, 157, 99, 255],\n  [92, 213, 193, 255],\n  [220, 85, 203, 255],\n  [165, 227, 78, 255],\n  [71, 118, 234, 255],\n  [188, 117, 117, 255],\n  [110, 195, 135, 255],\n  [161, 103, 202, 255],\n  [210, 195, 95, 255],\n  [88, 195, 217, 255],\n  [224, 81, 158, 255],\n  [113, 231, 74, 255],\n  [123, 120, 185, 255],\n  [192, 139, 113, 255],\n  [106, 199, 164, 255],\n  [198, 98, 207, 255],\n  [188, 214, 91, 255],\n  [84, 153, 221, 255],\n  [228, 77, 108, 255],\n  [70, 235, 84, 255],\n  [143, 116, 189, 255],\n  [196, 167, 109, 255],\n  [101, 204, 199, 255],\n  [211, 94, 182, 255],\n  [147, 218, 87, 255],\n  [80, 104, 225, 255],\n  [232, 93, 73, 255],\n  [119, 186, 147, 255],\n  [170, 112, 193, 255],\n  [200, 200, 105, 255],\n  [97, 175, 208, 255],\n  [215, 90, 142, 255],\n  [100, 222, 83, 255],\n  [101, 76, 229, 255],\n  [183, 150, 122, 255],\n  [115, 190, 171, 255],\n  [197, 108, 194, 255],\n  [170, 205, 100, 255],\n  [93, 138, 212, 255],\n  [219, 86, 97, 255],\n  [79, 226, 110, 255],\n  [153, 72, 233, 255],\n  [187, 173, 118, 255],\n  [111, 187, 194, 255],\n  [201, 104, 165, 255],\n  [134, 209, 96, 255],\n  [89, 95, 216, 255],\n  [223, 117, 82, 255],\n  [75, 230, 159, 255],\n  [174, 121, 184, 255],\n  [182, 191, 114, 255],\n  [107, 160, 198, 255],\n  [206, 99, 130, 255],\n  [92, 213, 92, 255],\n  [124, 85, 220, 255],\n  [227, 165, 78, 255],\n  [71, 234, 214, 255],\n  [188, 117, 176, 255],\n  [156, 195, 110, 255],\n  [103, 128, 202, 255],\n  [210, 100, 95, 255],\n  [88, 217, 131, 255],\n  [170, 81, 224, 255],\n  [231, 218, 74, 255],\n  [120, 172, 185, 255],\n  [192, 113, 153, 255],\n  [125, 199, 106, 255],\n  [107, 98, 207, 255],\n  [214, 137, 91, 255],\n  [84, 221, 175, 255],\n  [222, 77, 228, 255],\n  [194, 235, 70, 255],\n  [116, 149, 189, 255],\n  [196, 109, 123, 255],\n  [101, 204, 114, 255],\n  [143, 94, 211, 255],\n  [218, 180, 87, 255],\n  [80, 225, 225, 255],\n  [232, 73, 186, 255],\n  [147, 186, 119, 255],\n  [112, 122, 193, 255],\n  [200, 121, 105, 255],\n  [97, 208, 148, 255],\n  [184, 90, 215, 255],\n  [216, 222, 83, 255],\n  [76, 178, 229, 255],\n  [183, 122, 145, 255],\n  [121, 190, 115, 255],\n  [126, 108, 197, 255],\n  [205, 153, 100, 255],\n  [93, 212, 187, 255],\n  [219, 86, 208, 255],\n  [171, 226, 79, 255],\n  [72, 126, 233, 255],\n  [187, 118, 121, 255],\n  [111, 194, 132, 255],\n  [157, 104, 201, 255],\n  [209, 190, 96, 255],\n  [89, 200, 216, 255],\n  [223, 82, 164, 255],\n  [120, 230, 75, 255],\n  [121, 121, 184, 255],\n  [191, 136, 114, 255],\n  [107, 198, 160, 255],\n  [192, 99, 206, 255],\n  [193, 213, 92, 255],\n  [85, 158, 220, 255],\n  [227, 78, 115, 255],\n  [71, 234, 78, 255],\n  [141, 117, 188, 255],\n  [195, 163, 110, 255],\n  [103, 202, 194, 255],\n  [210, 95, 186, 255],\n  [153, 217, 88, 255],\n  [81, 111, 224, 255],\n];\n\nexport default CORNERSTONE_COLOR_LUT;\n","import { MouseCursor } from '.';\n\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\n\n/*\n * Public Methods\n */\n\nfunction initElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  _getElementCursors(element)[0] = cursor;\n  _setElementCursor(element, cursor);\n}\n\nfunction _setElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  const cursors = _getElementCursors(element);\n  cursors[1] = cursors[0];\n  cursors[0] = cursor;\n  element.style.cursor = (\n    cursor instanceof MouseCursor\n      ? cursor\n      : MouseCursor.getDefinedCursor('auto')\n  ).getStyleProperty();\n}\n\nfunction resetElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, _getElementCursors(element)[1]);\n}\n\nfunction hideElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\n\n/*\n * Helpers\n */\n\nfunction _getElementCursors(\n  element: HTMLDivElement\n): [MouseCursor | null, MouseCursor | null] {\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n  if (!(map instanceof WeakMap)) {\n    map = new WeakMap();\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n      value: map,\n    });\n  }\n  let cursors = map.get(element);\n  if (!cursors) {\n    cursors = [null, null];\n    map.set(element, cursors);\n  }\n  return cursors;\n}\n\n/*\n * Exports\n */\nexport {\n  initElementCursor,\n  resetElementCursor,\n  hideElementCursor,\n  _setElementCursor as setElementCursor,\n};\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n  'alias',\n  'all-scroll',\n  'auto',\n  'cell',\n  'col-resize',\n  'context-menu',\n  'copy',\n  'crosshair',\n  'default',\n  'e-resize',\n  'ew-resize',\n  'grab',\n  'grabbing',\n  'help',\n  'move',\n  'ne-resize',\n  'nesw-resize',\n  'no-drop',\n  'none',\n  'not-allowed',\n  'n-resize',\n  'ns-resize',\n  'nw-resize',\n  'nwse-resize',\n  'pointer',\n  'progress',\n  'row-resize',\n  'se-resize',\n  's-resize',\n  'sw-resize',\n  'text',\n  'vertical-text',\n  'wait',\n  'w-resize',\n  'zoom-in',\n  'zoom-out',\n]);\n\nexport default class MouseCursor {\n  private name: string;\n  private fallback: MouseCursor | undefined;\n\n  constructor(name: string, fallback?: MouseCursor | undefined) {\n    this.name = name + '';\n    this.fallback = fallback;\n  }\n\n  getName(): string {\n    return this.name + '';\n  }\n\n  addFallbackStyleProperty(style: string): string {\n    const { fallback } = this;\n    if (fallback instanceof MouseCursor) {\n      return `${style}, ${fallback.getStyleProperty()}`;\n    }\n    return style + '';\n  }\n\n  getStyleProperty(): string {\n    return this.addFallbackStyleProperty(this.name) + '';\n  }\n\n  static getDefinedCursor(name: string): MouseCursor | undefined {\n    const definedCursors = getDefinedCursors(\n      // @ts-ignore\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n      DEFINED_CURSORS\n    );\n    let mouseCursor = definedCursors.get(name);\n    if (mouseCursor instanceof MouseCursor) {\n      return mouseCursor;\n    }\n    if (STANDARD_CURSORS.has(name)) {\n      mouseCursor = new MouseCursor(name);\n      definedCursors.set(name, mouseCursor);\n      return mouseCursor;\n    }\n  }\n\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\n    if (cursor instanceof MouseCursor) {\n      const definedCursors = getDefinedCursors(\n        // @ts-ignore\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n        DEFINED_CURSORS\n      );\n      definedCursors.set(name, cursor);\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction getDefinedCursors(\n  context: Record<symbol, Map<string, MouseCursor>>,\n  symbol: symbol\n): Map<string, MouseCursor> {\n  let definedCursors = context[symbol];\n  if (!(definedCursors instanceof Map)) {\n    definedCursors = new Map();\n    Object.defineProperty(context, symbol, { value: definedCursors });\n  }\n  return definedCursors;\n}\n\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\n\nconst DEFAULT_NAME = 'image-cursor';\n\nexport default class ImageMouseCursor extends MouseCursor {\n  private url: string;\n  private x: number;\n  private y: number;\n\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\n      fallback\n    );\n    this.url = url;\n    this.x = Number(x) || 0;\n    this.y = Number(y) || 0;\n  }\n\n  getStyleProperty(): string {\n    const { url, x, y } = this;\n    let style = `url('${url}')`;\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n      style += ` ${x} ${y}`;\n    }\n    return this.addFallbackStyleProperty(style);\n  }\n\n  static getUniqueInstanceName(prefix: string): string {\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n  }\n}\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  return CursorSVG[name];\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport MouseCursor from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\n\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\nimport type { SVGCursorDescriptor } from '../types';\n\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\n\nexport default class SVGMouseCursor extends ImageMouseCursor {\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(url, x, y, name, fallback);\n  }\n\n  /**\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\n   *\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\n   * @param pointer - Should be true to use the version of the cursor containing\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\n   * @returns a SVGMouseCursor instance or\n   * undefined if no SVG cursor descriptor was found with the given name;\n   */\n  static getDefinedCursor(\n    name: string,\n    pointer = false,\n    color?: string\n  ): MouseCursor {\n    if (!color) {\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\n    }\n    const urn = getCursorURN(name, pointer, color);\n    let cursor = super.getDefinedCursor(urn);\n    if (!cursor) {\n      const descriptor = getDefinedSVGCursorDescriptor(name);\n      if (descriptor) {\n        cursor = createSVGMouseCursor(\n          descriptor,\n          urn,\n          pointer,\n          color,\n          super.getDefinedCursor('default')\n        );\n        super.setDefinedCursor(urn, cursor);\n      }\n    }\n    return cursor;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction format(template: string, dictionary: Record<string, unknown>): string {\n  const dict = Object(dictionary);\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return defined(key) ? dict[key] + '' : '';\n  });\n}\n\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\n  const type = pointer ? 'pointer' : 'cursor';\n  return `${type}:${name}/${color}`;\n}\n\nfunction createSVGMouseCursor(\n  descriptor: SVGCursorDescriptor,\n  name: string,\n  pointer: boolean,\n  color: string,\n  fallback: MouseCursor\n): SVGMouseCursor {\n  const { x, y } = descriptor.mousePoint;\n  return new SVGMouseCursor(\n    createSVGIconUrl(descriptor, pointer, { color }),\n    x,\n    y,\n    name,\n    fallback\n  );\n}\n\nfunction createSVGIconUrl(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): string {\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\n\nfunction createSVGIconBlob(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): Blob {\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\n    descriptor,\n    options\n  );\n  return new Blob([svgString], { type: 'image/svg+xml' });\n}\n\nfunction createSVGIcon(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n): string {\n  const { iconContent, iconSize, viewBox } = descriptor;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n  return format(svgString, options);\n}\n\nfunction createSVGIconWithPointer(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n) {\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\n    descriptor;\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n  const svgSize = 16 + iconSize;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n  return format(svgString, options);\n}\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\n\n/**\n * Set the cursor for an HTML element. cursorNames can be either\n * cornerstone3DTools cursors or standard cursors.\n *\n * @param element - The element to set the cursor on.\n * @param cursorName - The name of the cursor to set. This can be\n * any cursor name either Cornerstone-specific cursor names or the standard\n * CSS cursor names.\n */\nfunction setCursorForElement(\n  element: HTMLDivElement,\n  cursorName: string\n): void {\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n  if (!cursor) {\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  if (!cursor) {\n    console.log(\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\n    );\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  setElementCursor(element, cursor);\n}\n\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport {\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n} from './SVGCursorDescriptor';\n\n// Todo: this should be enum\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\n\nexport {\n  MouseCursor,\n  ImageMouseCursor,\n  SVGMouseCursor,\n  elementCursor,\n  registerCursor,\n  CursorNames,\n  CursorSVG,\n  setCursorForElement,\n};\n","function _getHash(\n  annotationUID: string,\n  drawingElementType: string,\n  nodeUID: string\n): string {\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\n\nexport default _getHash;\n","export function setAttributesIfNecessary(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const currentValue = svgNode.getAttribute(key);\n    const newValue = attributes[key];\n    if (newValue === undefined || newValue === '') {\n      svgNode.removeAttribute(key);\n    } else if (currentValue !== newValue) {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const newValue = attributes[key];\n    if (newValue !== undefined && newValue !== '') {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setNewAttributesIfValid;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\n\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawCircle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  circleUID: string,\n  center: Types.Point2,\n  radius: number,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    fill,\n    width,\n    lineWidth,\n    lineDash,\n    fillOpacity,\n    strokeOpacity,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      fill: 'transparent',\n      width: '2',\n      lineDash: undefined,\n      lineWidth: undefined,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    r: `${radius}`,\n    stroke: color,\n    fill,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n    'fill-opacity': fillOpacity, // setting fill opacity\n    'stroke-opacity': strokeOpacity, // setting stroke opacity\n  };\n\n  if (existingCircleElement) {\n    setAttributesIfNecessary(attributes, existingCircleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newCircleElement = document.createElementNS(svgns, 'circle');\n\n    if (dataId !== '') {\n      newCircleElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newCircleElement);\n\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n  }\n}\n\nexport default drawCircle;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawEllipseByCoordinates(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  canvasCoordinates: [Types.Point2, Types.Point2, Types.Point2, Types.Point2],\n  options = {},\n  dataId = ''\n): void {\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const [bottom, top, left, right] = canvasCoordinates;\n\n  const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n  const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n  const angle =\n    (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n\n  const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n  const radiusX = w / 2;\n  const radiusY = h / 2;\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    rx: `${radiusX}`,\n    ry: `${radiusY}`,\n    stroke: color,\n    fill: 'transparent',\n    transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingEllipse) {\n    setAttributesIfNecessary(attributes, existingEllipse);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n\n    if (dataId !== '') {\n      svgEllipseElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgEllipseElement);\n\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n  }\n}\n\nexport default drawEllipseByCoordinates;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\n\nfunction drawEllipse(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  corner1: Types.Point2,\n  corner2: Types.Point2,\n  options = {},\n  dataId = ''\n) {\n  const top: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner1[1]];\n  const bottom: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner2[1]];\n  const left: Types.Point2 = [corner1[0], (corner1[1] + corner2[1]) / 2];\n  const right: Types.Point2 = [corner2[0], (corner1[1] + corner2[1]) / 2];\n\n  drawEllipseByCoordinates(\n    svgDrawingHelper,\n    annotationUID,\n    ellipseUID,\n    [bottom, top, left, right],\n    (options = {}),\n    (dataId = '')\n  );\n}\n\nexport default drawEllipse;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawHandle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handle: Types.Point2,\n  options = {},\n  uniqueIndex\n): void {\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\n    Object.assign(\n      {\n        color: 'rgb(0, 255, 0)',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(\n    annotationUID,\n    'handle',\n    `hg-${handleGroupUID}-index-${uniqueIndex}`\n  );\n\n  let attributes;\n  if (type === 'circle') {\n    attributes = {\n      cx: `${handle[0]}`,\n      cy: `${handle[1]}`,\n      r: handleRadius,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      opacity: opacity,\n    };\n  } else if (type === 'rect') {\n    const handleRadiusFloat = parseFloat(handleRadius);\n    const side = handleRadiusFloat * 1.5;\n    const x = handle[0] - side * 0.5;\n    const y = handle[1] - side * 0.5;\n\n    attributes = {\n      x: `${x}`,\n      y: `${y}`,\n      width: `${side}`,\n      height: `${side}`,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      rx: `${side * 0.1}`,\n      opacity: opacity,\n    };\n  } else {\n    throw new Error(`Unsupported handle type: ${type}`);\n  }\n\n  const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  if (existingHandleElement) {\n    setAttributesIfNecessary(attributes, existingHandleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newHandleElement = document.createElementNS(svgns, type);\n\n    setNewAttributesIfValid(attributes, newHandleElement);\n\n    svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n  }\n}\n\nexport default drawHandle;\n","import type { Types } from '@cornerstonejs/core';\n\nimport { SVGDrawingHelper } from '../types';\nimport drawHandle from './drawHandle';\n\nfunction drawHandles(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handlePoints: Array<Types.Point2>,\n  options = {}\n): void {\n  handlePoints.forEach((handle, i) => {\n    drawHandle(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      handle,\n      options,\n      i\n    );\n  });\n}\n\nexport default drawHandles;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawLine(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  lineUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      shadow: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n  const dropShadowStyle = shadow\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n    : '';\n\n  const attributes = {\n    x1: `${start[0]}`,\n    y1: `${start[1]}`,\n    x2: `${end[0]}`,\n    y2: `${end[1]}`,\n    stroke: color,\n    style: dropShadowStyle,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newLine = document.createElementNS(svgns, 'line');\n\n    if (dataId !== '') {\n      newLine.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newLine);\n\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG polyline with the given points.\n *\n * The `closePath` option, if true, draws a closed polyline, with the\n * last point connected to the first.\n */\nexport default function drawPolyline(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  polylineUID: string,\n  points: Types.Point2[],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    closePath?: boolean;\n  }\n): void {\n  if (points.length < 2) {\n    return;\n  }\n\n  const {\n    color = 'rgb(0, 255, 0)',\n    width = 10,\n    fillColor = 'none',\n    fillOpacity = 0,\n    lineWidth,\n    lineDash,\n    closePath = false,\n  } = options;\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  let pointsAttribute = '';\n\n  for (const point of points) {\n    pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n  }\n\n  if (closePath) {\n    const firstPoint = points[0];\n\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n  }\n\n  const attributes = {\n    points: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingPolyLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingPolyLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\n\n    setNewAttributesIfValid(attributes, newPolyLine);\n\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG path with the given points.\n *\n * The `closePath` option, if true, draws a closed path (last point\n * connected to the first).\n */\nexport default function drawPath(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  pathUID: string,\n  points: Types.Point2[] | Types.Point2[][],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    closePath?: boolean;\n  }\n): void {\n  // It may be a polyline with holes that will be an array with multiple\n  // 'points' arrays\n  const hasSubArrays =\n    points.length && points[0].length && Array.isArray(points[0][0]);\n\n  const pointsArrays = hasSubArrays ? points : [points];\n  const {\n    color = 'rgb(0, 255, 0)',\n    width = 10,\n    fillColor = 'none',\n    fillOpacity = 0,\n    lineWidth,\n    lineDash,\n    closePath = false,\n  } = options;\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\n  const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\n  let pointsAttribute = '';\n\n  for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\n    const points = pointsArrays[i];\n    const numPoints = points.length;\n\n    if (numPoints < 2) {\n      continue;\n    }\n\n    for (let j = 0; j < numPoints; j++) {\n      const point = points[j];\n      const cmd = j ? 'L' : 'M';\n\n      pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(\n        1\n      )} `;\n    }\n\n    if (closePath) {\n      pointsAttribute += 'Z ';\n    }\n  }\n\n  if (!pointsAttribute) {\n    return;\n  }\n\n  const attributes = {\n    d: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingNode) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingNode);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newNode = document.createElementNS(svgns, 'path');\n\n    setNewAttributesIfValid(attributes, newNode);\n    svgDrawingHelper.appendNode(newNode, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\n\n/**\n * Draws a textBox.\n *\n * @param textLines - The text to display.\n * @param position - The x/y position of the textbox\n * @param options - Options for the textBox.\n * @returns Bounding box; can be used for isPointNearTool\n */\nfunction drawTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string>,\n  position: Types.Point2,\n  options = {}\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      fontFamily: 'Helvetica, Arial, sans-serif',\n      fontSize: '14px',\n      color: 'rgb(255, 255, 0)',\n      background: '',\n      padding: 25,\n      centerX: false,\n      centerY: true,\n    },\n    options\n  );\n\n  // Draw each of the text lines on top of the background box\n  const textGroupBoundingBox = _drawTextGroup(\n    svgDrawingHelper,\n    annotationUID,\n    textUID,\n    textLines,\n    position,\n    mergedOptions\n  );\n\n  return textGroupBoundingBox;\n}\n\nfunction _drawTextGroup(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string> = [''],\n  position: Types.Point2,\n  options: any\n): SVGRect {\n  const { padding, color, fontFamily, fontSize, background } = options;\n\n  let textGroupBoundingBox;\n  const [x, y] = [position[0] + padding, position[1] + padding];\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\n  // and evenIf the attributes are not set again since they are the same.\n  if (existingTextGroup) {\n    // TODO: Iterate each node and update color? font-size?\n    const textElement = existingTextGroup.querySelector('text');\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\n\n    for (let i = 0; i < textSpans.length; i++) {\n      const textSpanElement = textSpans[i];\n      const text = textLines[i] || '';\n\n      textSpanElement.textContent = text;\n    }\n\n    // if the textLines have changed size, we need to create textSpans for them\n    if (textLines.length > textSpans.length) {\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\n        const textLine = textLines[i + textSpans.length];\n        const textSpan = _createTextSpan(textLine);\n\n        textElement.appendChild(textSpan);\n      }\n\n      existingTextGroup.appendChild(textElement);\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n    }\n\n    const textAttributes = {\n      fill: color,\n      'font-size': fontSize,\n      'font-family': fontFamily,\n    };\n\n    const textGroupAttributes = {\n      transform: `translate(${x} ${y})`,\n    };\n\n    // Todo: for some reason this does not work to not re-render the textBox\n    setAttributesIfNecessary(textAttributes, textElement);\n    setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const textGroup = document.createElementNS(svgns, 'g');\n\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\n\n    //\n    const textElement = _createTextElement(svgDrawingHelper, options);\n    for (let i = 0; i < textLines.length; i++) {\n      const textLine = textLines[i];\n      const textSpan = _createTextSpan(textLine);\n\n      textElement.appendChild(textSpan);\n    }\n\n    textGroup.appendChild(textElement);\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\n  }\n\n  // We translate the group using `position`\n  // which means we also need to pluck those values when returning\n  // the bounding box\n  return Object.assign({}, textGroupBoundingBox, {\n    x,\n    y,\n    height: textGroupBoundingBox.height + padding,\n    width: textGroupBoundingBox.width + padding,\n  });\n}\n\nfunction _createTextElement(\n  svgDrawingHelper: SVGDrawingHelper,\n  options: any\n): SVGElement {\n  const { color, fontFamily, fontSize } = options;\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textElement = document.createElementNS(svgns, 'text');\n  const noSelectStyle =\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n\n  // font-size=\"100\"\n  textElement.setAttribute('x', '0');\n  textElement.setAttribute('y', '0');\n  textElement.setAttribute('fill', color);\n  textElement.setAttribute('font-family', fontFamily);\n  textElement.setAttribute('font-size', fontSize);\n  textElement.setAttribute('style', combinedStyle);\n\n  return textElement;\n}\n\nfunction _createTextSpan(text): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\n\n  // TODO: centerX\n  // (parent width / 2) - my width\n  // TODO: centerY\n\n  textSpanElement.setAttribute('x', '0');\n  textSpanElement.setAttribute('dy', '1.2em');\n  textSpanElement.textContent = text;\n\n  return textSpanElement;\n}\n\nfunction _drawTextBackground(group: SVGGElement, color: string) {\n  let element = group.querySelector('rect.background');\n\n  // If we have no background color, remove any element that exists and return\n  // the bounding box of the text\n  if (!color) {\n    if (element) {\n      group.removeChild(element);\n    }\n\n    return group.getBBox();\n  }\n\n  // Otherwise, check if we have a <rect> element. If not, create one\n  if (!element) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    element.setAttribute('class', 'background');\n    group.insertBefore(element, group.firstChild);\n  }\n\n  // Get the text groups's bounding box and use it to draw the background rectangle\n  const bBox = group.getBBox();\n\n  const attributes = {\n    x: `${bBox.x}`,\n    y: `${bBox.y}`,\n    width: `${bBox.width}`,\n    height: `${bBox.height}`,\n    fill: color,\n  };\n\n  setAttributesIfNecessary(attributes, element);\n\n  return bBox;\n}\n\nexport default drawTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\n\n/**\n * Draw a link between an annotation to a box.\n */\nfunction drawLink(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  linkUID: string,\n  // Find closest point to approx. bounding box\n  annotationAnchorPoints: Array<Types.Point2>,\n  refPoint: Types.Point2,\n  // Find bounding box point that's closest to our identified\n  // start point\n  boundingBox: PlanarBoundingBox,\n  options = {}\n): void {\n  // The closest anchor point (for the annotation) to the\n  // text box / bounding box\n  const start =\n    annotationAnchorPoints.length > 0\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\n      : refPoint;\n\n  // Calculate the midpoints of the bounding box\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n  // Find the closest textBox midpoint to the annotation's anchor/start point\n  const end = findClosestPoint(boundingBoxPoints, start);\n\n  // Finally we draw the dashed linking line\n  const mergedOptions = Object.assign(\n    {\n      color: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '2,3',\n    },\n    options\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    `link-${linkUID}`,\n    start,\n    end,\n    mergedOptions\n  );\n}\n\n/**\n * Find potential anchor points for a given bounding box. For example, it may\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\n * annotation (instead of from a corner). This function calculates those points\n *\n * @param boundingBox\n */\nfunction _boundingBoxPoints(\n  boundingBox: PlanarBoundingBox\n): Array<Types.Point2> {\n  const { x: left, y: top, height, width } = boundingBox;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\n\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\n\nexport default drawLink;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawLinkedTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textBoxUID: string,\n  //\n  textLines: Array<string>,\n  textBoxPosition: Types.Point2,\n  annotationAnchorPoints: Array<Types.Point2>,\n  textBox: unknown,\n  options = {}\n  // TODO: yCenter as an option\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      handleRadius: '6',\n      centering: {\n        x: false,\n        y: true, // yCenter,\n      },\n    },\n    options\n  );\n\n  // Draw the text box\n  const canvasBoundingBox = drawTextBox(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    textLines,\n    textBoxPosition,\n    mergedOptions\n  );\n  // if (textBox.hasMoved) {\n  //   // Draw dashed link line between tool and text\n  drawLink(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    annotationAnchorPoints, // annotationAnchorPoints\n    textBoxPosition, // refPoint (text)\n    canvasBoundingBox, // textBoxBoundingBox\n    mergedOptions\n  );\n  // }\n\n  // const { top, left, width, height } = canvasBoundingBox\n\n  // textBox.worldBoundingBox = {\n  //   topLeft: canvasToWorld([left, top]),\n  //   topRight: canvasToWorld([left + width, top]),\n  //   bottomLeft: canvasToWorld([left, top + height]),\n  //   bottomRight: canvasToWorld([left + width, top + height]),\n  // }\n\n  return canvasBoundingBox;\n}\n\nexport default drawLinkedTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport { SVGDrawingHelper } from '../types';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRect(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    if (dataId !== '') {\n      svgRectElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawArrow(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  arrowUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // The line itself\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n    color,\n    width,\n    lineWidth,\n    lineDash,\n  });\n\n  // Drawing the head arrow with two lines\n  // Variables to be used when creating the arrow\n  const headLength = 10;\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n\n  const firstLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  const secondLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRedactionRect(\n  svgDrawingHelper: any,\n  annotationUID: string,\n  rectangleUID: string,\n  start: any,\n  end: any,\n  options = {}\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'black',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    _setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    _setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","/**\n * ChangeTypes defines the types of changes occurring on annotation and\n * segmentation data.\n */\nenum ChangeTypes {\n  /**\n   * Interaction events are done when the user is actively interacting with\n   * an annotation, and probably means the event shouldn't be handled/used.\n   */\n  Interaction = 'Interaction',\n  /**\n   * HandlesUpdated occurs when the handle data is added or removed, or moved around\n   */\n  HandlesUpdated = 'HandlesUpdated',\n  /**\n   * StatsUpdated occurs when the stats are updated/calculated.  This can be used\n   * to ignore stats calculations changes occurring on initial load, while still\n   * rendering other updates.\n   */\n  StatsUpdated = 'StatsUpdated',\n  /**\n   * InitialSetup occurs when an annotation has been created initially and\n   * has the first render/data calculation being applied.\n   */\n  InitialSetup = 'InitialSetup',\n  /**\n   * Completed occurs only for the annotation completed event, just to identify it\n   */\n  Completed = 'Completed',\n  /**\n   * Occurs when an interpolation result is updated with more tool specific data.\n   */\n  InterpolationUpdated = 'InterpolationUpdated',\n}\n\nexport default ChangeTypes;\n","/**\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\n *  allows us to handle events consistently across different browsers.\n *\n */\nenum Events {\n  ///////////////////////////////////////\n  //            Tools\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new tools is activated.\n   *\n   * Make use of {@link EventTypes.ToolActivatedEventType | Tool Activated Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolActivatedEventDetail | Tool Activated Event Detail}.\n   */\n  TOOL_ACTIVATED = 'CORNERSTONE_TOOLS_TOOL_ACTIVATED',\n\n  /**\n   * Triggers on the eventTarget when a mode of a tool is changed (active, passive, enabled and disabled).\n   *\n   * Make use of {@link EventTypes.ToolModeChangedEventType | Tool Mode Changed Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolModeChangedEventDetail | Tool Mode Changed Event Detail}.\n   */\n  TOOL_MODE_CHANGED = 'CORNERSTONE_TOOLS_TOOL_MODE_CHANGED',\n\n  ///////////////////////////////////////\n  //            Annotations\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new annotation is added to the state.\n   *\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\n   * for typing your event listeners for this annotation added event, and see what event\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\n   */\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\n\n  /**\n   * Triggers on the eventTarget when a new annotation is completed its drawing\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\n   * for typing your event listeners for this annotation completed event, and see what event\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\n   */\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\n   * for typing your event listeners for this annotation modified event, and see what\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\n   */\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\n   * for typing your event listeners for this annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\n   */\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when an annotation selection status is changed.\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\n   * for typing your event listeners for this annotation selection change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\n   */\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation locked status is changed.\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\n   * for typing your event listeners for this annotation lock change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\n   */\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation visible status is changed.\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\n   * for typing your event listeners for this annotation Hide change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\n   */\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation is rendered.\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\n   * for typing your event listeners for this annotation rendered event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\n   */\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when an annotation interpolation process completed.\n   * Make use of {@link EventTypes.AnnotationInterpolationCompletedEventType | Annotation Interpolation process Completed Event Type}\n   * for typing your event listeners for this annotation interpolation complete event, and see what\n   * event detail is included in {@link EventTypes.AnnotationInterpolationCompletedEventDetail | Annotation interpolation process Event Detail}.\n   */\n  ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when interpolated annotations are removed.\n   * Make use of {@link EventTypes.AnnotationInterpolationRemovedEventType | Annotation Interpolation Removed Event Type}\n   * for typing your event listeners for this interpolated annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationInterpolationRemovedEventDetail | Annotation interpolation removed Event Detail}.\n   */\n  INTERPOLATED_ANNOTATIONS_REMOVED = 'CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED',\n\n  ///////////////////////////////////////\n  //        Segmentations Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\n   * for typing your event listeners for this segmentation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\n   */\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\n   * for typing your event listeners for this segmentation rendered event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\n   */\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\n   * for typing your event listeners for this segmentation representation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\n   * for typing your event listeners for this segmentation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\n   */\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\n   * for typing your event listeners for this segmentation representation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\n   * for typing your event listeners for this segmentation data modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\n   */\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\n\n  ///////////////////////////////////////\n  //         Keyboard Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\n   * for typing your event listeners for this key down event, and see what\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\n   */\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is released.\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\n   * for typing your event listeners for this key up event, and see what\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\n   */\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\n\n  ///////////////////////////////////////\n  //      Mouse Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\n   * for typing your event listeners for this mouse down event, and see what\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\n   */\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\n\n  /**\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\n   * for typing your event listeners for this mouse up event, and see what\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\n   */\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\n\n  /**\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\n   * we use to create new annotation for mouse events.\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\n   * for typing your event listeners for this mouse down activate event, and see what\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\n   */\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\n\n  /**\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\n   * for typing your event listeners for this mouse drag event, and see what\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\n   */\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\n\n  /**\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\n   * It can be just a mouse move or when double click is performed and annotation\n   * drawing can be performed with just mouse move.\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\n   * for typing your event listeners for this mouse move event, and see what\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\n   */\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\n\n  /**\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\n   * for typing your event listeners for this mouse click event, and see what\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\n   */\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\n   * for typing your event listeners for this mouse double click event, and see what\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\n   */\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\n   * for typing your event listeners for this mouse wheel event, and see what\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\n   */\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\n\n  // Todo: not being fired as of now\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n  // Todo: not implemented yet\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\n\n  //////////////////////\n  //   Touch Events   //\n  //////////////////////\n  // The event flow looks like the following\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\n  // Touch Tap\n  // mousedown\n  // mousedown, Touch Start, and Tap are mutually exclusive events\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\n}\n\nexport default Events;\n","/**\n * Segmentations on viewports can be visualized in different ways. This enum\n * defines the different ways of visualizing segmentations. Currently, only\n * labelmap is supported.\n */\nenum SegmentationRepresentations {\n  Labelmap = 'LABELMAP',\n  Contour = 'CONTOUR',\n  Surface = 'SURFACE',\n}\n\nexport default SegmentationRepresentations;\n","/**\n * Defines the names of the strategy callbacks used for performing enhanced\n * strategy operations.\n */\nenum StrategyCallbacks {\n  /**\n   * startStrategy is called at the start of a strategy, typically on mouse down\n   * Note this is separate from preview and the endings for preview, which could\n   * be called alternatively, but this may be nested within a preview.\n   */\n  OnInteractionStart = 'onInteractionStart',\n  /**\n   * finishStrategy is called at the end of a strategy being applied, usually on\n   * mouse up.\n   */\n  OnInteractionEnd = 'onInteractionEnd',\n  /**\n   * The preview can be used for tools to show what would happen on accepting\n   * before the change is actually done.  For example, a spline tool might\n   * show a preview state, and allow that to be accepted or rejected.\n   */\n  Preview = 'preview',\n  RejectPreview = 'rejectPreview',\n  AcceptPreview = 'acceptPreview',\n\n  /**\n   * Fills the given reygion\n   */\n  Fill = 'fill',\n\n  /**\n   * The default strategy function, often synonymous with fill\n   */\n  StrategyFunction = 'strategyFunction',\n\n  /**\n   * For threshold functions, this creates the thresold test.  Mostly an internal\n   * detail, but might be useful to share between strategies.\n   */\n  CreateIsInThreshold = 'createIsInThreshold',\n\n  /**\n   *  Some strategy functions need to initialize some data before being runnable.\n   * This is mostly an internal detail, just useful to have an enum here for this.\n   */\n  Initialize = 'initialize',\n\n  // Internal Details\n  INTERNAL_setValue = 'setValue',\n\n  /** inner circle size  */\n  ComputeInnerCircleRadius = 'computeInnerCircleRadius',\n}\n\nexport default StrategyCallbacks;\n","enum Swipe {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport { Swipe };\n","/**\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\n * These values are used when setting a tool active in a tool group.\n *\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nenum MouseBindings {\n  /** usually the left button */\n  Primary = 1,\n  /** usually the right button */\n  Secondary = 2,\n  Primary_And_Secondary = 3,\n  /** usually mouse wheel button */\n  Auxiliary = 4,\n  Primary_And_Auxiliary = 5,\n  Secondary_And_Auxiliary = 6,\n  Primary_And_Secondary_And_Auxiliary = 7,\n  /** usually \"Browser Back\" button */\n  Fourth_Button = 8,\n  /** usually \"Browser Forward\" button */\n  Fifth_Button = 16,\n}\n\nenum KeyboardBindings {\n  Shift = 16,\n  Ctrl = 17,\n  Alt = 18,\n  Meta = 91,\n  ShiftCtrl = 1617,\n  ShiftAlt = 1618,\n  ShiftMeta = 1691,\n  CtrlAlt = 1718,\n  CtrlMeta = 1791,\n  AltMeta = 1891,\n}\n\nexport { MouseBindings, KeyboardBindings };\n","/**\n * AnnotationStyleStates - This enum defines the 4 possible states available for\n *  a Annotation instance.\n *\n * Default:\n *   The default state for the annotation instance\n * Highlighted:\n *   The annotation should be rendered in \"highlighted\" mode in response to\n *   direct user interaction;\n * Selected:\n *   The annotation has been selected by the user;\n * Locked:\n *   The annotation has been locked;\n * AutoGenerated:\n *   The annotation has been auto generated;\n */\nenum AnnotationStyleStates {\n  Default = '',\n  Highlighted = 'Highlighted',\n  Selected = 'Selected',\n  Locked = 'Locked',\n  AutoGenerated = 'AutoGenerated',\n}\n\nexport default AnnotationStyleStates;\n","/**\n * Worker Types are used to define the types the worker that is getting performed\n */\nenum ChangeTypes {\n  POLYSEG_CONTOUR_TO_LABELMAP = 'polySeg/convertContourToVolumeLabelmap',\n\n  POLYSEG_SURFACE_TO_LABELMAP = 'polySeg/convertSurfacesToVolumeLabelmap',\n\n  POLYSEG_CONTOUR_TO_SURFACE = 'polySeg/convertContourToSurface',\n\n  POLYSEG_LABELMAP_TO_SURFACE = 'polySeg/convertLabelmapToSurface',\n\n  SURFACE_CLIPPING = 'surfaceClipping',\n}\n\nexport default ChangeTypes;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\n  // TODO: should we do this on camera modified instead of image rendered?\n  // e.g. no need to re-render annotations if only the VOI has changed\n  triggerAnnotationRender(evt.detail.element);\n};\n\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import Events from '../enums/Events';\n\nimport {\n  mouseClick,\n  mouseDown,\n  mouseDownActivate,\n  mouseDoubleClick,\n  mouseDrag,\n  mouseMove,\n  mouseUp,\n  mouseWheel,\n} from './mouseEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.addEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.addEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.removeEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.removeEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\nconst mouseToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default mouseToolEventDispatcher;\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\n\n/**\n * Enable Key down and key up listeners\n *\n * @param element - The HTML element to attach the event listeners to.\n */\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\n/**\n * Disable Key down and key up listeners\n * @param element - The HTML element to attach the event listeners to.\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\nconst keyboardToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default keyboardToolEventDispatcher;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is modified, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraModified` method, we call it.\n *\n * @param evt - The normalized camera modified event.\n */\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onCameraModified) {\n      tool.onCameraModified(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When image spacing is calibrated modify the annotations for all of its tools\n * to consider the new calibration info.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\n *\n * @param evt - The normalized image calibration event.\n */\nconst onImageSpacingCalibrated = function (\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\n) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onImageSpacingCalibrated) {\n      tool.onImageSpacingCalibrated(evt);\n    }\n  });\n};\n\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import Events from '../enums/Events';\n\nimport {\n  touchStart,\n  touchStartActivate,\n  touchDrag,\n  touchEnd,\n  touchTap,\n  touchPress,\n} from './touchEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.addEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.removeEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\nconst touchToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default touchToolEventDispatcher;\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\n\n/**\n * The enable and disable add/remove the event listeners that dispatch the\n * required events to the interpolation manager.\n */\nconst enable = function () {\n  eventTarget.addEventListener(\n    Events.ANNOTATION_COMPLETED,\n    InterpolationManager.handleAnnotationCompleted as EventListener\n  );\n  eventTarget.addEventListener(\n    Events.ANNOTATION_MODIFIED,\n    InterpolationManager.handleAnnotationUpdate as EventListener\n  );\n  eventTarget.addEventListener(\n    Events.ANNOTATION_REMOVED,\n    InterpolationManager.handleAnnotationDelete as EventListener\n  );\n};\n\nconst disable = function () {\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_COMPLETED,\n    InterpolationManager.handleAnnotationCompleted as EventListener\n  );\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_MODIFIED,\n    InterpolationManager.handleAnnotationUpdate as EventListener\n  );\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_REMOVED,\n    InterpolationManager.handleAnnotationDelete as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import {\n  getEnabledElement,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport {\n  math,\n  triggerAnnotationRenderForViewportIds,\n} from '../../../utilities';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport {\n  addAnnotation,\n  removeAnnotation,\n  getAllAnnotations,\n  getChildAnnotations,\n  addChildAnnotation,\n  clearParentAnnotation,\n} from '../../../stateManagement/annotation/annotationState';\nimport {\n  AnnotationCompletedEventType,\n  ContourAnnotationCompletedEventDetail,\n} from '../../../types/EventTypes';\nimport * as contourUtils from '../../../utilities/contours';\nimport * as contourSegUtils from '../../../utilities/contourSegmentation';\nimport { ToolGroupManager, hasTool as cstHasTool } from '../../../store';\nimport { PlanarFreehandContourSegmentationTool } from '../../../tools';\nimport type { Annotation } from '../../../types';\nimport type { ContourAnnotation } from '../../../types/ContourAnnotation';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\n\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\n\nexport default async function contourSegmentationCompletedListener(\n  evt: AnnotationCompletedEventType\n) {\n  const sourceAnnotation = evt.detail\n    .annotation as ContourSegmentationAnnotation;\n\n  if (!contourSegUtils.isContourSegmentationAnnotation(sourceAnnotation)) {\n    return;\n  }\n\n  const viewport = getViewport(sourceAnnotation);\n  const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(\n    viewport,\n    sourceAnnotation\n  );\n\n  if (!contourSegmentationAnnotations.length) {\n    return;\n  }\n\n  const sourcePolyline = convertContourPolylineToCanvasSpace(\n    sourceAnnotation.data.contour.polyline,\n    viewport\n  );\n\n  const targetAnnotationInfo = findIntersectingContour(\n    viewport,\n    sourcePolyline,\n    contourSegmentationAnnotations\n  );\n\n  if (!targetAnnotationInfo) {\n    return;\n  }\n\n  const { targetAnnotation, targetPolyline, isContourHole } =\n    targetAnnotationInfo;\n\n  if (isContourHole) {\n    const { contourHoleProcessingEnabled = false } =\n      evt.detail as ContourAnnotationCompletedEventDetail;\n\n    // Do not create holes when contourHoleProcessingEnabled is `false`\n    if (!contourHoleProcessingEnabled) {\n      return;\n    }\n\n    createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n  } else {\n    combinePolylines(\n      viewport,\n      targetAnnotation,\n      targetPolyline,\n      sourceAnnotation,\n      sourcePolyline\n    );\n  }\n}\n\nfunction isFreehandContourSegToolRegisteredForViewport(\n  viewport: Types.IViewport,\n  silent = false\n) {\n  const { toolName } = PlanarFreehandContourSegmentationTool;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewport.id,\n    viewport.renderingEngineId\n  );\n\n  let errorMessage;\n\n  if (!toolGroup.hasTool(toolName)) {\n    errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n  } else if (!toolGroup.getToolOptions(toolName)) {\n    errorMessage = `Tool ${toolName} must be in active/passive state`;\n  }\n\n  if (errorMessage && !silent) {\n    console.warn(errorMessage);\n  }\n\n  return !errorMessage;\n}\n\nfunction getViewport(annotation: Annotation) {\n  const viewports = getViewportsForAnnotation(annotation);\n  const viewportWithToolRegistered = viewports.find((viewport) =>\n    isFreehandContourSegToolRegisteredForViewport(viewport, true)\n  );\n\n  // Returns the first viewport even if freehand contour segmentation is not\n  // registered because it can be used to project the polyline to create holes.\n  // Another verification is done before appending/removing contours which is\n  // possible only when the tool is registered.\n  return viewportWithToolRegistered ?? viewports[0];\n}\n\nfunction convertContourPolylineToCanvasSpace(\n  polyline: Types.Point3[],\n  viewport: Types.IViewport\n): Types.Point2[] {\n  const numPoints = polyline.length;\n  const projectedPolyline = new Array(numPoints);\n\n  for (let i = 0; i < numPoints; i++) {\n    projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n  }\n\n  return projectedPolyline;\n}\n\nfunction getValidContourSegmentationAnnotations(\n  viewport: Types.IViewport,\n  sourceAnnotation: ContourSegmentationAnnotation\n): ContourSegmentationAnnotation[] {\n  const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n\n  // Get all annotations and filter all contour segmentations locally\n  const allAnnotations = getAllAnnotations();\n  return allAnnotations.filter(\n    (targetAnnotation) =>\n      targetAnnotation.annotationUID &&\n      targetAnnotation.annotationUID !== sourceAnnotationUID &&\n      contourSegUtils.isContourSegmentationAnnotation(targetAnnotation) &&\n      contourSegUtils.areSameSegment(targetAnnotation, sourceAnnotation) &&\n      viewport.isReferenceViewable(targetAnnotation.metadata)\n  ) as ContourSegmentationAnnotation[];\n}\n\n/**\n * Finds other contours on the same slice which intersect the source polyline,\n * represented as canvas points.\n */\nfunction findIntersectingContour(\n  viewport: Types.IViewport,\n  sourcePolyline: Types.Point2[],\n  contourSegmentationAnnotations: ContourSegmentationAnnotation[]\n): {\n  targetAnnotation: ContourSegmentationAnnotation;\n  targetPolyline: Types.Point2[];\n  isContourHole: boolean;\n} {\n  const sourceAABB = math.polyline.getAABB(sourcePolyline);\n\n  for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n    const targetAnnotation = contourSegmentationAnnotations[i];\n    const targetPolyline = convertContourPolylineToCanvasSpace(\n      targetAnnotation.data.contour.polyline,\n      viewport\n    );\n\n    const targetAABB = math.polyline.getAABB(targetPolyline);\n    const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n    const lineSegmentsIntersect =\n      aabbIntersect &&\n      math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n    const isContourHole =\n      aabbIntersect &&\n      !lineSegmentsIntersect &&\n      math.polyline.containsPoints(targetPolyline, sourcePolyline);\n\n    if (lineSegmentsIntersect || isContourHole) {\n      return { targetAnnotation, targetPolyline, isContourHole };\n    }\n  }\n}\n\n/**\n * Modifies the holeAnnotation to work as a contour hole in the targetAnnotation,\n * displayed on the given viewport.\n\n */\nexport function createPolylineHole(\n  viewport: Types.IViewport,\n  targetAnnotation: ContourSegmentationAnnotation,\n  holeAnnotation: ContourSegmentationAnnotation\n) {\n  const { windingDirection: targetWindingDirection } =\n    targetAnnotation.data.contour;\n  const { windingDirection: holeWindingDirection } =\n    holeAnnotation.data.contour;\n\n  // Check if both normals are pointing to the same direction because the\n  // polyline for the hole needs to be in a different direction\n  // if (glMatrix.equals(1, dotNormals)) {\n  if (targetWindingDirection === holeWindingDirection) {\n    holeAnnotation.data.contour.polyline.reverse();\n    holeAnnotation.data.contour.windingDirection = targetWindingDirection * -1;\n  }\n\n  addChildAnnotation(targetAnnotation, holeAnnotation);\n  contourSegUtils.removeContourSegmentationAnnotation(holeAnnotation);\n\n  const { element } = viewport;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine } = enabledElement;\n\n  // Updating a Spline contours, for example, should also update freehand contours\n  const updatedToolNames = new Set([\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\n    targetAnnotation.metadata.toolName,\n    holeAnnotation.metadata.toolName,\n  ]);\n\n  for (const toolName of updatedToolNames.values()) {\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      toolName\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n}\n\nfunction getContourHolesData(\n  viewport: Types.IViewport,\n  annotation: ContourAnnotation\n) {\n  return getChildAnnotations(annotation).map((holeAnnotation) => {\n    const polyline = convertContourPolylineToCanvasSpace(\n      holeAnnotation.data.contour.polyline,\n      viewport\n    );\n\n    return { annotation: holeAnnotation, polyline };\n  });\n}\n\nfunction combinePolylines(\n  viewport: Types.IViewport,\n  targetAnnotation: ContourSegmentationAnnotation,\n  targetPolyline: Types.Point2[],\n  sourceAnnotation: ContourSegmentationAnnotation,\n  sourcePolyline: Types.Point2[]\n) {\n  if (!cstHasTool(PlanarFreehandContourSegmentationTool)) {\n    console.warn(\n      `${PlanarFreehandContourSegmentationTool.toolName} is not registered in cornerstone`\n    );\n    return;\n  }\n\n  // Cannot append/remove an annotation if it will not be available on any viewport\n  if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {\n    return;\n  }\n\n  const sourceStartPoint = sourcePolyline[0];\n  const mergePolylines = math.polyline.containsPoint(\n    targetPolyline,\n    sourceStartPoint\n  );\n\n  const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n  const unassignedContourHolesSet = new Set(contourHolesData);\n  const reassignedContourHolesMap = new Map();\n  const assignHoleToPolyline = (parentPolyline, holeData) => {\n    let holes = reassignedContourHolesMap.get(parentPolyline);\n\n    if (!holes) {\n      holes = [];\n      reassignedContourHolesMap.set(parentPolyline, holes);\n    }\n\n    holes.push(holeData);\n    unassignedContourHolesSet.delete(holeData);\n  };\n  const newPolylines = [];\n\n  if (mergePolylines) {\n    const mergedPolyline = math.polyline.mergePolylines(\n      targetPolyline,\n      sourcePolyline\n    );\n\n    newPolylines.push(mergedPolyline);\n\n    // Keep all holes because the contour can only grow when merging and there\n    // is no chance for any hole to be removed\n    Array.from(unassignedContourHolesSet.keys()).forEach((holeData) =>\n      assignHoleToPolyline(mergedPolyline, holeData)\n    );\n  } else {\n    const subtractedPolylines = math.polyline.subtractPolylines(\n      targetPolyline,\n      sourcePolyline\n    );\n\n    subtractedPolylines.forEach((newPolyline) => {\n      newPolylines.push(newPolyline);\n\n      Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n        const containsHole = math.polyline.containsPoints(\n          newPolyline,\n          holeData.polyline\n        );\n\n        if (containsHole) {\n          assignHoleToPolyline(newPolyline, holeData);\n          unassignedContourHolesSet.delete(holeData);\n        }\n      });\n    });\n  }\n\n  // Make sure the holes that will be added to the new annotation are not\n  // associated to the target annotation that will be deleted\n  Array.from(reassignedContourHolesMap.values()).forEach(\n    (contourHolesDataArray) =>\n      contourHolesDataArray.forEach((contourHoleData) =>\n        clearParentAnnotation(contourHoleData.annotation)\n      )\n  );\n\n  const { element } = viewport;\n  const enabledElement = getEnabledElement(element);\n  const { metadata, data } = targetAnnotation;\n  const { handles, segmentation } = data;\n  const { textBox } = handles;\n\n  removeAnnotation(sourceAnnotation.annotationUID);\n  removeAnnotation(targetAnnotation.annotationUID);\n\n  for (let i = 0; i < newPolylines.length; i++) {\n    const polyline = newPolylines[i];\n    const startPoint = viewport.canvasToWorld(polyline[0]);\n    const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation: ContourSegmentationAnnotation = {\n      metadata: {\n        ...metadata,\n        toolName: DEFAULT_CONTOUR_SEG_TOOLNAME,\n        originalToolName: metadata.originalToolName || metadata.toolName,\n      },\n      data: {\n        cachedStats: {},\n        handles: {\n          points: [startPoint, endPoint],\n          textBox: textBox ? { ...textBox } : undefined,\n        },\n        contour: {\n          polyline: [],\n          closed: true,\n        },\n        spline: targetAnnotation.data.spline,\n        segmentation: {\n          ...segmentation,\n        },\n      },\n      annotationUID: csUtils.uuidv4() as string,\n      highlighted: true,\n      invalidated: true,\n      isLocked: false,\n      isVisible: undefined,\n      // Allow this object to be interpolated against the original interpolation\n      // data.\n      interpolationUID: targetAnnotation.interpolationUID,\n      interpolationCompleted: targetAnnotation.interpolationCompleted,\n    };\n\n    // Calling `updateContourPolyline` method instead of setting it locally\n    // because it is also responsible for checking/setting the winding direction.\n    contourUtils.updateContourPolyline(\n      newAnnotation,\n      {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n      },\n      viewport\n    );\n\n    addAnnotation(newAnnotation, element);\n    contourSegUtils.addContourSegmentationAnnotation(newAnnotation);\n    triggerAnnotationModified(newAnnotation, viewport.element);\n\n    reassignedContourHolesMap\n      .get(polyline)\n      ?.forEach((holeData) =>\n        addChildAnnotation(newAnnotation, holeData.annotation)\n      );\n  }\n\n  updateViewports(enabledElement, targetAnnotation, sourceAnnotation);\n}\n\nfunction updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {\n  const { viewport } = enabledElement;\n  const { element } = viewport;\n  const { renderingEngine } = enabledElement;\n\n  const updatedTtoolNames = new Set([\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\n    targetAnnotation.metadata.toolName,\n    sourceAnnotation.metadata.toolName,\n  ]);\n\n  for (const toolName of updatedTtoolNames.values()) {\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      toolName\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, {\n  mouseDoubleClickIgnoreListener,\n} from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\n\n/**\n * Removes mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\n  element.removeEventListener('mousedown', mouseDownListener);\n  element.removeEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\n/**\n * Registers mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n\n  element.addEventListener('dblclick', mouseDoubleClickListener);\n  element.addEventListener('mousedown', mouseDownListener);\n  element.addEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\n\n/**\n * Removes touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  preventGhostClick.disable(element);\n  element.removeEventListener('touchstart', touchStartListener);\n}\n\n/**\n * Registers touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n  preventGhostClick.enable(element);\n  element.addEventListener('touchstart', touchStartListener, {\n    passive: false,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import wheelListener from './wheelListener';\n\n/**\n * Listens for the wheel event, and handles it. Handled event\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\n *\n * @param element - The HTML element\n */\nfunction enable(element: HTMLDivElement) {\n  disable(element);\n  element.addEventListener('wheel', wheelListener, { passive: false });\n}\n\n/**\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\n * will no longer be emitted.\n *\n * @param element - THe HTML element\n */\nfunction disable(element: HTMLDivElement) {\n  element.removeEventListener('wheel', wheelListener);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationStateModified` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationModifiedListener = function (\n  evt: SegmentationRepresentationModifiedEventType\n): void {\n  const { toolGroupId } = evt.detail;\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationModifiedListener;\n","import {\n  cache,\n  getEnabledElementByIds,\n  utilities as csUtils,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../../types/EventTypes';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../types/LabelmapTypes';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onLabelmapSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\n\n  const { representationData, type } =\n    SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  const labelmapRepresentationData = representationData[type];\n\n  if ('volumeId' in labelmapRepresentationData) {\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\n    performVolumeLabelmapUpdate({\n      modifiedSlicesToUse,\n      representationData,\n      type,\n    });\n  }\n\n  if ('imageIdReferenceMap' in labelmapRepresentationData) {\n    // get the stack from cache, we need the imageData to be updated to GPU\n    performStackLabelmapUpdate({\n      toolGroupIds,\n      segmentationId,\n      representationData,\n      type,\n    });\n  }\n};\n\nfunction performVolumeLabelmapUpdate({\n  modifiedSlicesToUse,\n  representationData,\n  type,\n}) {\n  const segmentationVolume = cache.getVolume(\n    (representationData[type] as LabelmapSegmentationDataVolume).volumeId\n  );\n\n  if (!segmentationVolume) {\n    console.warn('segmentation not found in cache');\n    return;\n  }\n\n  const { imageData, vtkOpenGLTexture } = segmentationVolume;\n\n  // Update the texture for the volume in the GPU\n  let slicesToUpdate;\n  if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n    slicesToUpdate = modifiedSlicesToUse;\n  } else {\n    const numSlices = imageData.getDimensions()[2];\n    slicesToUpdate = [...Array(numSlices).keys()];\n  }\n\n  slicesToUpdate.forEach((i) => {\n    vtkOpenGLTexture.setUpdatedFrame(i);\n  });\n\n  // Trigger modified on the imageData to update the image\n  imageData.modified();\n}\n\nfunction performStackLabelmapUpdate({\n  toolGroupIds,\n  segmentationId,\n  representationData,\n  type,\n}) {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      SegmentationState.getSegmentationRepresentations(toolGroupId);\n\n    const toolGroup = getToolGroup(toolGroupId);\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId !== segmentationId) {\n        return;\n      }\n\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        ).viewport;\n\n        if (viewport instanceof VolumeViewport) {\n          return;\n        }\n\n        const actorEntry = viewport.getActor(\n          representation.segmentationRepresentationUID\n        );\n\n        if (!actorEntry) {\n          return;\n        }\n\n        const currentImageId = viewport.getCurrentImageId();\n\n        const segImageData = actorEntry.actor.getMapper().getInputData();\n\n        const { imageIdReferenceMap } = representationData[\n          type\n        ] as LabelmapSegmentationDataStack;\n\n        const currentSegmentationImageId =\n          imageIdReferenceMap.get(currentImageId);\n\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        segImageData.modified();\n\n        // update the cache with the new image data\n        csUtils.updateVTKImageDataWithCornerstoneImage(\n          segImageData,\n          segmentationImage\n        );\n      });\n    });\n  });\n}\n\nexport default onLabelmapSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\nimport onLabelmapSegmentationDataModified from './labelmap/onLabelmapSegmentationDataModified';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n  const { type } = SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    onLabelmapSegmentationDataModified(evt);\n  }\n\n  toolGroupIds.forEach((toolGroupId) => {\n    triggerSegmentationRender(toolGroupId);\n  });\n};\n\nexport default onSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationRemovedEventListener = function (\n  evt: SegmentationRepresentationRemovedEventType\n): void {\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationRemovedEventListener;\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\nimport {\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\n\n/** A function that listens to the `segmentationModified` event and triggers\n * the triggerSegmentationRepresentationModified on each toolGroup that\n * has a representation of the given segmentationId.\n */\nconst segmentationModifiedListener = function (\n  evt: SegmentationModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n  toolGroupIds.forEach((toolGroupId) => {\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\n    segRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        triggerSegmentationRepresentationModified(\n          toolGroupId,\n          representation.segmentationRepresentationUID\n        );\n      }\n    });\n  });\n};\n\nexport default segmentationModifiedListener;\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Enums,\n  getEnabledElementByIds,\n  cache,\n  utilities,\n  Types,\n} from '@cornerstonejs/core';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\n\nconst enable = function (element: HTMLDivElement): void {\n  const { viewport } = getEnabledElement(element);\n\n  if (viewport instanceof BaseVolumeViewport) {\n    return;\n  }\n\n  element.addEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  // this listener handles the segmentation modifications\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst perToolGroupManualTriggers = new Map();\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nfunction _imageChangeEventListener(evt) {\n  const eventData = evt.detail;\n  const { viewportId, renderingEngineId } = eventData;\n  const { viewport } = getEnabledElementByIds(\n    viewportId,\n    renderingEngineId\n  ) as { viewport: Types.IStackViewport };\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (!toolGroup) {\n    return;\n  }\n\n  let toolGroupSegmentationRepresentations =\n    SegmentationState.getSegmentationRepresentations(toolGroup.id) || [];\n\n  toolGroupSegmentationRepresentations =\n    toolGroupSegmentationRepresentations.filter(\n      (representation) => representation.type === Representations.Labelmap\n    );\n\n  if (!toolGroupSegmentationRepresentations?.length) {\n    return;\n  }\n\n  const segmentationRepresentations = {};\n  toolGroupSegmentationRepresentations.forEach((representation) => {\n    const segmentation = SegmentationState.getSegmentation(\n      representation.segmentationId\n    );\n\n    if (!segmentation || !segmentation.representationData?.LABELMAP) {\n      return;\n    }\n\n    const labelmapData = segmentation.representationData.LABELMAP;\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      return;\n    }\n\n    const { imageIdReferenceMap } =\n      labelmapData as LabelmapSegmentationDataStack;\n\n    segmentationRepresentations[representation.segmentationRepresentationUID] =\n      {\n        imageIdReferenceMap,\n      };\n  });\n\n  const representationList = Object.keys(segmentationRepresentations);\n  const currentImageId = viewport.getCurrentImageId();\n  const actors = viewport.getActors();\n\n  const segmentationFound = actors.find((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!segmentationFound) {\n    // If the segmentation is not found, it could be because of some special cases\n    // where we are in the process of updating the volume conversion to a stack while\n    // the data is still coming in. In such situations, we should trigger the render\n    // to ensure that the segmentation actors are created, even if the data arrives late.\n\n    if (!perToolGroupManualTriggers.has(toolGroup.id)) {\n      perToolGroupManualTriggers.set(toolGroup.id, true);\n      triggerSegmentationRender(toolGroup.id);\n    }\n\n    // we should return here, since there is no segmentation actor to update\n    // we will hit this function later on after the actor is created\n    return;\n  }\n\n  actors.forEach((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return;\n    }\n    const segmentationActor = actor.actor;\n\n    const { imageIdReferenceMap } = segmentationRepresentations[actor.uid];\n\n    const derivedImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImageData = segmentationActor.getMapper().getInputData();\n\n    if (!derivedImageId) {\n      // this means that this slice doesn't have a segmentation for this representation\n      // this can be a case where the segmentation was added to certain slices only\n      // so we can keep the actor but empty out the imageData\n      if (segmentationImageData.setDerivedImage) {\n        // If the image data has a set derived image, then it should be called\n        // to update any vtk or actor data associated with it.  In this case, null\n        // is used to clear the data.  THis allows intercepting/alternative\n        // to vtk calls.  Eventually the vtk version should also use this.\n        segmentationImageData.setDerivedImage(null);\n        return;\n      }\n      // This is the vtk version of the clearing out the image data, and fails\n      // to work for non scalar image data.\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: new Uint8Array(segmentationImageData.getNumberOfPoints()),\n      });\n\n      const imageData = vtkImageData.newInstance();\n      imageData.getPointData().setScalars(scalarArray);\n      segmentationActor.getMapper().setInputData(imageData);\n      return;\n    }\n\n    const derivedImage = cache.getImage(derivedImageId);\n\n    const { dimensions, spacing, direction } =\n      viewport.getImageDataMetadata(derivedImage);\n\n    const currentImage =\n      cache.getImage(currentImageId) ||\n      ({\n        imageId: currentImageId,\n      } as Types.IImage);\n    const { origin: currentOrigin } =\n      viewport.getImageDataMetadata(currentImage);\n\n    // IMPORTANT: We need to make sure that the origin of the segmentation\n    // is the same as the current image origin. This is because due to some\n    // floating point precision issues, when coming from volume to stack\n    // the origin of the segmentation can be slightly different from the\n    // current image origin. This can cause the segmentation to be rendered\n    // in the wrong location.\n    // Todo: This will not work for segmentations that are not in the same frame\n    // of reference or derived from the same image. This can happen when we have\n    // a segmentation that happens to exist in the same space as the image but is\n    // not derived from it. We need to find a way to handle this case, but don't think\n    // it makes sense to do it for the stack viewport, as the volume viewport is designed to handle this case.\n    const originToUse = currentOrigin;\n\n    segmentationImageData.setOrigin(originToUse);\n    segmentationImageData.modified();\n\n    if (\n      segmentationImageData.getDimensions()[0] !== dimensions[0] ||\n      segmentationImageData.getDimensions()[1] !== dimensions[1]\n    ) {\n      // IMPORTANT: Not sure why we can't just update the dimensions\n      // and the orientation of the image data and then call modified\n      // I tried calling modified on everything, but seems like we should remove\n      // and add the actor again below\n      viewport.removeActors([actor.uid]);\n      viewport.addImages(\n        [\n          {\n            imageId: derivedImageId,\n            actorUID: actor.uid,\n            callback: ({ imageActor }) => {\n              const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: [...derivedImage.getPixelData()],\n              });\n\n              const imageData = vtkImageData.newInstance();\n\n              imageData.setDimensions(dimensions[0], dimensions[1], 1);\n              imageData.setSpacing(spacing);\n              imageData.setDirection(direction);\n              imageData.setOrigin(originToUse);\n              imageData.getPointData().setScalars(scalarArray);\n\n              imageActor.getMapper().setInputData(imageData);\n            },\n          },\n        ],\n        true,\n        false\n      );\n\n      triggerSegmentationRender(toolGroup.id);\n      return;\n    }\n\n    if (segmentationImageData.setDerivedImage) {\n      // Update the derived image data, whether vtk or other as appropriate\n      // to the actor(s) displaying the data.\n      segmentationImageData.setDerivedImage(derivedImage);\n    } else {\n      // TODO - use setDerivedImage for this functionality\n      utilities.updateVTKImageDataWithCornerstoneImage(\n        segmentationImageData,\n        derivedImage\n      );\n    }\n    viewport.render();\n\n    // This is put here to make sure that the segmentation is rendered\n    // for the initial image as well after that we don't need it since\n    // stack new image is called when changing slices\n    if (evt.type === Enums.Events.IMAGE_RENDERED) {\n      // unsubscribe after the initial render\n      viewport.element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        _imageChangeEventListener as EventListener\n      );\n    }\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { AnnotationCompletedEventType } from '../../types/EventTypes';\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationCompleted } from './contourSegmentation';\n\nexport default function annotationCompletedListener(\n  evt: AnnotationCompletedEventType\n) {\n  const annotation = evt.detail.annotation;\n\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n    contourSegmentationCompleted(evt);\n  }\n}\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\n\n/**\n * When an annotation is deselected, trigger an annotation render for all viewports.\n * The reason for this is that, drawing an annotation in a different viewport\n * should deselect all other annotations in other viewports. In order to achieve\n * this, we need to trigger an annotation render for all viewports.\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\n * it's probably not going to have a noticeable impact on performance.\n * @param evt - The event object.\n */\nfunction annotationSelectionListener(evt): void {\n  const deselectedAnnotation = evt.detail.removed;\n\n  if (!deselectedAnnotation.length) {\n    return;\n  }\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n    const viewportIds = viewports.map((vp) => vp.id);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  });\n}\n\nexport default annotationSelectionListener;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\n/**\n * This is a callback function that is called when an annotation is modified.\n * Since we are throttling the cachedStats calculation for annotation tools,\n * we need to trigger a final render for the annotation. so that the annotation\n * textBox is updated.\n * Todo: This will trigger all the annotation tools to re-render, although DOM\n * will update those that have changed, but more efficient would be to only\n * update the changed annotation.\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\n * no svg update happens since the attributes for handles are the same)\n */\nfunction annotationModifiedListener(evt): void {\n  const { viewportId, renderingEngineId } = evt.detail;\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\n\nexport default annotationModifiedListener;\n","import { AnnotationRemovedEventType } from '../../types/EventTypes';\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationRemoved } from './contourSegmentation';\n\nexport default function annotationRemovedListener(\n  evt: AnnotationRemovedEventType\n) {\n  const annotation = evt.detail.annotation;\n\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n    contourSegmentationRemoved(evt);\n  }\n}\n","import type { AnnotationRemovedEventType } from '../../../types/EventTypes';\nimport type { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\n\nexport default function contourSegmentationRemovedListener(\n  evt: AnnotationRemovedEventType\n) {\n  const annotation = evt.detail.annotation as ContourSegmentationAnnotation;\n\n  removeContourSegmentationAnnotation(annotation);\n}\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport {\n  annotationCompletedListener,\n  annotationRemovedListener,\n  annotationSelectionListener,\n  annotationModifiedListener,\n  segmentationDataModifiedEventListener,\n  segmentationRepresentationModifiedEventListener,\n  segmentationRepresentationRemovedEventListener,\n  segmentationModifiedListener,\n} from './eventListeners';\nimport { annotationInterpolationEventDispatcher } from './eventDispatchers';\n\nimport * as ToolGroupManager from './store/ToolGroupManager';\n\nlet csToolsInitialized = false;\n\n/**\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\n * and keyboard events.\n * @param defaultConfiguration - A configuration object that will be used to\n * initialize the tool.\n */\nexport function init(defaultConfiguration = {}): void {\n  if (csToolsInitialized) {\n    return;\n  }\n\n  _addCornerstoneEventListeners();\n  _addCornerstoneToolsEventListeners();\n\n  csToolsInitialized = true;\n}\n\n/**\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\n * that were added to the tool groups and restore states. It also removes all\n * event listeners.\n */\nexport function destroy(): void {\n  _removeCornerstoneEventListeners();\n  _removeCornerstoneToolsEventListeners();\n\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\n  // added tools.\n  ToolGroupManager.destroy();\n\n  // Remove all tools\n  resetCornerstoneToolsState();\n\n  // remove all annotation.\n  const annotationManager = getAnnotationManager();\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  annotationManager.restoreAnnotations({});\n  segmentationStateManager.resetState();\n  csToolsInitialized = false;\n}\n\n/**\n * Wires up event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n * @internal\n */\nfunction _addCornerstoneEventListeners(): void {\n  // Clear any listeners that may already be set\n  _removeCornerstoneEventListeners();\n\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n  annotationInterpolationEventDispatcher.enable();\n}\n\n/**\n * Removes event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n */\nfunction _removeCornerstoneEventListeners(): void {\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n  annotationInterpolationEventDispatcher.disable();\n}\n\n/**\n * It adds an event listener to the event target (the cornerstoneTools object) for\n * the annotation selected and annotation modified events.\n */\nfunction _addCornerstoneToolsEventListeners() {\n  // Clear any listeners that may already be set\n  _removeCornerstoneToolsEventListeners();\n\n  /**\n   * Annotation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\n    annotationCompletedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_REMOVED,\n    annotationRemovedListener\n  );\n\n  /**\n   * Segmentation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\n/**\n * Remove the event listener for the the annotation selected and annotation modified events.\n */\nfunction _removeCornerstoneToolsEventListeners() {\n  /**\n   * Annotation\n   */\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\n    annotationCompletedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\nexport default init;\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera by updating all camera\n * values.  See also zoomPanSyncCallback\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default function cameraSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  cameraModifiedEvent: CustomEvent\n): void {\n  const { camera } = cameraModifiedEvent.detail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  tViewport.setCamera(camera);\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createCameraPositionSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const cameraPositionSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    cameraSyncCallback\n  );\n\n  return cameraPositionSynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function presentationViewSyncCallback(\n  _synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  _sourceEvent,\n  options?: Types.ViewPresentationSelector\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  const presentationView = sViewport.getViewPresentation(options);\n\n  tViewport.setView(null, presentationView);\n\n  tViewport.render();\n}\n","import { Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback` based on presentation view\n * values and not based on absolute camera positions.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createPresentationViewSynchronizer(\n  synchronizerName: string,\n  options?: Types.ViewPresentation\n): Synchronizer {\n  const presentationView = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    presentationViewSyncCallback,\n    options\n  );\n\n  return presentationView;\n}\n","import {\n  BaseVolumeViewport,\n  getRenderingEngine,\n  StackViewport,\n  Types,\n} from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\n * in different viewports.\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport.\n * @param modifiedEvent - The COLORMAP_MODIFIED or VOI_MODIFIED event.\n * @param options - Options for the synchronizer.\n */\nexport default function voiSyncCallback(\n  synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  modifiedEvent: any,\n  options?: any\n): void {\n  const eventDetail = modifiedEvent.detail;\n  const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const tProperties:\n    | Types.VolumeViewportProperties\n    | Types.StackViewportProperties = {\n    voiRange: range,\n  };\n\n  if (options?.syncInvertState && invertStateChanged) {\n    tProperties.invert = invert;\n  }\n  if (options?.syncColormap && colormap) {\n    tProperties.colormap = colormap;\n  }\n\n  if (tViewport instanceof BaseVolumeViewport) {\n    const isFusion = tViewport._actors && tViewport._actors.size > 1;\n    if (isFusion) {\n      tViewport.setProperties(tProperties, volumeId);\n    } else {\n      tViewport.setProperties(tProperties);\n    }\n  } else if (tViewport instanceof StackViewport) {\n    tViewport.setProperties(tProperties);\n  } else {\n    throw new Error('Viewport type not supported.');\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\ntype VOISynchronizerOptions = {\n  syncInvertState: boolean;\n  syncColormap :boolean;\n};\n\n/**\n * A helper that creates a new `Synchronizer`\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @param options - The options for the synchronizer. By default the voi\n * synchronizer will also sync the invert state of the volume, but this can be\n * disabled by setting `syncInvertState` to false.\n *\n * @returns A new `Synchronizer` instance.\n */\nexport default function createVOISynchronizer(\n  synchronizerName: string,\n  options: VOISynchronizerOptions\n): Synchronizer {\n  //  = { syncInvertState: true } if options is not provided or undefined or {}\n  options = Object.assign({ syncInvertState: true, syncColormap:true }, options);\n\n  const VOISynchronizer = createSynchronizer(\n    synchronizerName,\n    Enums.Events.VOI_MODIFIED,\n    voiSyncCallback,\n    {\n      auxiliaryEventNames: [Enums.Events.COLORMAP_MODIFIED],\n      ...options,\n    }\n  );\n\n  return VOISynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function zoomPanSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  if (options?.syncZoom !== false) {\n    const srcZoom = sViewport.getZoom();\n    // Do the zoom first, as the pan is relative to the zoom level\n    tViewport.setZoom(srcZoom);\n  }\n  if (options?.syncPan !== false) {\n    const srcPan = sViewport.getPan();\n    tViewport.setPan(srcPan);\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createZoomPanSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const zoomPanSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    zoomPanSyncCallback\n  );\n\n  return zoomPanSynchronizer;\n}\n","import { vec3, mat4 } from 'gl-matrix';\nimport {\n  getRenderingEngine,\n  Types,\n  metaData,\n  utilities,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\n\nconst getSpatialRegistration = (targetId, sourceId) =>\n  utilities.spatialRegistrationMetadataProvider.get(\n    'spatialRegistrationModule',\n    targetId,\n    sourceId\n  );\n\n/**\n * Synchronizer callback to synchronize the source viewport image to the\n * target viewports closest image in its stack.\n *\n * This synchronizer does a setup (which can already be predefined as required)\n * to register the target and soruce viewports.  The registration will default\n * to the identity registration if the same FOR is present in both viewports,\n * unless the option `useInitialPosition` is set in the target viewport.\n *\n * The consuming apps using Cornerstone3D (OHIF, etc) MAY provide such data in\n * the registrationMetadataProvider to override the data here. This can be done\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\n * the user has actually manually scrolled the target viewport to the correct\n * slice before initiating the synchronization 3) using some other method\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default async function imageSliceSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): Promise<void> {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  if (options?.disabled) {\n    return;\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const imageId1 = sViewport.getCurrentImageId();\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n\n  const targetImageIds = tViewport.getImageIds();\n\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\n    return;\n  }\n\n  // if the frame of reference is different we need to use the registrationMetadataProvider\n  // and add that to the imagePositionPatient of the source viewport to get the\n  // imagePositionPatient of the target viewport's closest image in its stack\n  let registrationMatrixMat4 = getSpatialRegistration(\n    targetViewport.viewportId,\n    sourceViewport.viewportId\n  );\n\n  if (!registrationMatrixMat4) {\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n    if (\n      frameOfReferenceUID1 === frameOfReferenceUID2 &&\n      options?.useInitialPosition !== false\n    ) {\n      registrationMatrixMat4 = mat4.identity(mat4.create());\n    } else {\n      utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n      registrationMatrixMat4 = getSpatialRegistration(\n        targetViewport.viewportId,\n        sourceViewport.viewportId\n      );\n    }\n    if (!registrationMatrixMat4) {\n      return;\n    }\n  }\n\n  // apply the registration matrix to the source viewport's imagePositionPatient\n  // to get the target viewport's imagePositionPatient\n  const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\n    vec3.create(),\n    sourceImagePositionPatient,\n    registrationMatrixMat4\n  );\n\n  // find the closest image in the target viewport's stack to the\n  // targetImagePositionPatientWithRegistrationMatrix\n  const closestImageIdIndex2 = _getClosestImageIdIndex(\n    targetImagePositionPatientWithRegistrationMatrix,\n    targetImageIds\n  );\n\n  let imageIndexToSet = closestImageIdIndex2.index;\n  if (tViewport instanceof VolumeViewport) {\n    // since in case of volume viewport our stack is reversed, we should\n    // reverse the index as well\n    imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n  }\n\n  if (\n    closestImageIdIndex2.index !== -1 &&\n    tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\n  ) {\n    await jumpToSlice(tViewport.element, {\n      imageIndex: imageIndexToSet,\n    });\n  }\n}\n\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n  // todo: this does not assume orientation yet, but that can be added later\n  // todo: handle multiframe images\n  return imageIds.reduce(\n    (closestImageIdIndex, imageId, index) => {\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\n\n      if (distance < closestImageIdIndex.distance) {\n        return {\n          distance,\n          index,\n        };\n      }\n      return closestImageIdIndex;\n    },\n    {\n      distance: Infinity,\n      index: -1,\n    }\n  );\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nexport default function areViewportsCoplanar(\n  viewport1: Types.IStackViewport | Types.IVolumeViewport,\n  viewport2: Types.IStackViewport | Types.IVolumeViewport\n): boolean {\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n  return Math.abs(dotProducts) > 0.9;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\n * rendering event and calls the `ImageSliceSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createImageSliceSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const stackImageSynchronizer = createSynchronizer(\n    synchronizerName,\n    STACK_NEW_IMAGE,\n    imageSliceSyncCallback,\n    {\n      auxiliaryEventNames: [VOLUME_NEW_IMAGE],\n    }\n  );\n\n  return stackImageSynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the slab thickness.\n */\nexport default function slabThicknessSyncCallback(\n  _synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  const slabThickness = (\n    sViewport as Types.IVolumeViewport\n  ).getSlabThickness?.();\n  if (!slabThickness) {\n    return;\n  }\n  (tViewport as Types.IVolumeViewport).setSlabThickness?.(slabThickness);\n  tViewport.render();\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback` based on presentation view\n * values and not based on absolute camera positions.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createPresentationViewSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const presentationView = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    slabThicknessSyncCallback\n  );\n\n  return presentationView;\n}\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createPresentationViewSynchronizer from './synchronizers/createPresentationViewSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\nimport createSlabThicknessSynchronizer from './synchronizers/createSlabThicknessSynchronizer';\n\n// for backward compatibility\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\n\nexport {\n  createCameraPositionSynchronizer,\n  createPresentationViewSynchronizer,\n  createVOISynchronizer,\n  createZoomPanSynchronizer,\n  createImageSliceSynchronizer,\n  createStackImageSynchronizer,\n  createSlabThicknessSynchronizer,\n};\n","import { vec3, vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  cache,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRedactionRect as drawRedactionRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { EventTypes, SVGDrawingHelper } from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { VideoRedactionAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nclass VideoRedactionTool extends AnnotationTool {\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportUIDsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  _configuration: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(toolConfiguration = {}) {\n    super(toolConfiguration, {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: { shadow: true, preventHandleOutsideImage: false },\n    });\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): VideoRedactionAnnotation => {\n    const eventData = evt.detail;\n    const { currentPoints, element } = eventData;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      metadata: {\n        // We probably just want a different type of data here, hacking this\n        // together for now.\n        viewPlaneNormal: <Types.Point3>[0, 0, 1],\n        viewUp: <Types.Point3>[0, 1, 0],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        active: true,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    return annotation;\n  };\n\n  getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, <vec2>toolDataCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  };\n\n  isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]] as Types.Point2;\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n  };\n\n  toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { data } = annotation;\n\n    data.active = true;\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt,\n    annotation,\n    handle,\n    interactionType = 'mouse'\n  ) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { data } = annotation;\n\n    data.active = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if (handle.worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  _mouseUpCallback = (evt) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  _mouseDragCallback = (evt) => {\n    this.isDrawing = true;\n\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventData;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      data.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventData;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      data.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  cancel(element) {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportUIDsToRender } = this.editData;\n\n    const { data } = annotation;\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    this.editData = null;\n    return annotation.metadata.annotationUID;\n  }\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n      const toolMetadata = annotation.metadata;\n\n      const data = annotation.data;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        // !isToolDataLocked(toolData) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRedactionRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color: 'black',\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n    let imageVolume, viewport;\n    if (targetUID.startsWith('stackTarget')) {\n      const coloneIndex = targetUID.indexOf(':');\n      const viewportUID = targetUID.substring(coloneIndex + 1);\n      const viewport = renderingEngine.getViewport(viewportUID);\n      imageVolume = viewport.getImageData();\n    } else {\n      imageVolume = cache.getVolume(targetUID);\n    }\n\n    return { imageVolume, viewport };\n  }\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param {object} data - The toolData tool-specific data.\n   * @param {Array<number>} viewPlaneNormal The normal vector of the camera.\n   * @param {Array<number>} viewUp The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetUIDs = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetUIDs.length; i++) {\n      const targetUID = targetUIDs[i];\n\n      const { imageVolume } = this._getImageVolumeFromTargetUID(\n        targetUID,\n        renderingEngine\n      );\n\n      const {\n        dimensions,\n        scalarData,\n        vtkImageData: imageData,\n        metadata,\n      } = imageVolume;\n      const worldPos1Index = vec3.fromValues(0, 0, 0);\n      const worldPos2Index = vec3.fromValues(0, 0, 0);\n\n      imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const area = worldWidth * worldHeight;\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        // This is a triple loop, but one of these 3 values will be constant\n        // In the planar view.\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              count++;\n              mean += value;\n            }\n          }\n        }\n\n        mean /= count;\n\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              const valueMinusMean = value - mean;\n\n              stdDev += valueMinusMean * valueMinusMean;\n            }\n          }\n        }\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          stdDev,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    data.invalidated = false;\n\n    // Dispatching measurement modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail = {\n      annotation,\n      viewportUID,\n      renderingEngineUID,\n      sceneUID: sceneUID,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  _getTargetStackUID(viewport) {\n    return `stackTarget:${viewport.uid}`;\n  }\n\n  _getTargetVolumeUID = (scene) => {\n    if (this.configuration.volumeUID) {\n      return this.configuration.volumeUID;\n    }\n\n    const volumeActors = scene.getVolumeActors();\n\n    if (!volumeActors && !volumeActors.length) {\n      // No stack to scroll through\n      return;\n    }\n\n    return volumeActors[0].uid;\n  };\n}\n\nVideoRedactionTool.toolName = 'VideoRedaction';\nexport default VideoRedactionTool;\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  Annotation,\n  Annotations,\n  AnnotationState,\n  GroupSpecificAnnotations,\n} from '../../types/AnnotationTypes';\n\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\n\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\n\n/**\n * This is the default annotation manager. It stores annotations by default\n * based on the FrameOfReferenceUID. However, it is possible to override the\n * getAnnotationStateKey function to store annotations based on any other\n * property of the element. When you write your custom annotation manager, you\n * can use the setAnnotationManager function to set your custom annotation.\n *\n * Note that this class is a singleton and should not be instantiated directly.\n * To get the stored annotations information you can use ToolState helpers.\n */\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\n  private annotations: AnnotationState;\n  public readonly uid: string;\n\n  /**\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\n   */\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = utilities.uuidv4();\n    }\n    this.annotations = {};\n    this.uid = uid;\n\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\n    eventTarget.addEventListener(\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedHandler\n    );\n  }\n\n  /**\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\n   * manager adds them under the FrameOfReferenceUID for the element being\n   * annotated.\n   *\n   * @param annotationGroupSelector - element or a string that is provided\n   * to the annotation manager to get the key.\n   * @returns - The annotation state key for the element.\n   */\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\n    if (typeof annotationGroupSelector === 'string') {\n      return annotationGroupSelector;\n    }\n\n    const element = annotationGroupSelector;\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      throw new Error(\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\n      );\n    }\n\n    return enabledElement.FrameOfReferenceUID;\n  };\n\n  /**\n   * When a volume is modified we invalidate all of the `annotations` on the\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\n   * when an annotation is drawn whilst data is still loading.\n   *\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\n   */\n  _imageVolumeModifiedHandler = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const eventDetail = evt.detail;\n    const { FrameOfReferenceUID } = eventDetail;\n\n    const annotations = this.annotations;\n    const frameOfReferenceSpecificAnnotations =\n      annotations[FrameOfReferenceUID];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      return;\n    }\n\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      toolSpecificAnnotations.forEach((annotation) => {\n        const invalidated = annotation.invalidated;\n\n        if (invalidated !== undefined) {\n          annotation.invalidated = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * Returns all the available frameOfReferences inside the state manager\n   * @returns - All the added frames of references inside the manager\n   */\n  getFramesOfReference = (): Array<string> => {\n    return Object.keys(this.annotations);\n  };\n\n  /**\n   * Returns the annotations associated with the specified frameOfReference and tool, or\n   * all annotations for the group if the tool name is not provided.\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   * WARNING: The list returned here is internal tool data, not a copy, so do NOT modify it.\n   */\n  getAnnotations = (\n    groupKey: string,\n    toolName?: string\n  ): GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (!annotations[groupKey]) {\n      return [];\n    }\n\n    if (toolName) {\n      return annotations[groupKey][toolName]\n        ? annotations[groupKey][toolName]\n        : [];\n    }\n\n    return annotations[groupKey];\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, returns the `annotation`\n   * from the `annotations`. Each `annotation` has a unique identifier.\n   *\n   * @param annotationUID - The unique identifier of the `annotation`.\n   * @returns The retrieved `annotation`.\n   */\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\n    const annotations = this.annotations;\n\n    for (const frameOfReferenceUID in annotations) {\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n\n      for (const toolName in frameOfReferenceAnnotations) {\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n\n        for (const annotation of toolSpecificAnnotations) {\n          if (annotationUID === annotation.annotationUID) {\n            return annotation;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * A function that returns the number of annotations for a given tool in the\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - The name of the tool to retrieve data for.\n   *\n   * @returns The number of annotations for a given tool in the state\n   */\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\n    const annotations = this.getAnnotations(groupKey, toolName);\n\n    if (!annotations.length) {\n      return 0;\n    }\n\n    if (toolName) {\n      return (annotations as Annotations).length;\n    }\n\n    let total = 0;\n\n    for (const toolName in annotations) {\n      total += annotations[toolName].length;\n    }\n\n    return total;\n  };\n\n  /**\n   * Adds an instance of `Annotation` to the `annotations`.\n   *\n   * @param annotation - The annotation to add.\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\n   */\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\n    const { metadata } = annotation;\n    const { FrameOfReferenceUID, toolName } = metadata;\n\n    groupKey = groupKey || FrameOfReferenceUID;\n\n    const annotations = this.annotations;\n\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      annotations[groupKey] = {};\n\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\n    }\n\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n\n    if (!toolSpecificAnnotations) {\n      frameOfReferenceSpecificAnnotations[toolName] = [];\n\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n    }\n\n    toolSpecificAnnotations.push(annotation);\n    checkAndDefineIsLockedProperty(annotation);\n    checkAndDefineIsVisibleProperty(annotation);\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, removes the `annotation`\n   * from the `annotations`.\n   *\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\n   */\n  removeAnnotation = (annotationUID: string): void => {\n    const { annotations } = this;\n\n    for (const groupKey in annotations) {\n      const groupAnnotations = annotations[groupKey];\n\n      for (const toolName in groupAnnotations) {\n        const toolAnnotations = groupAnnotations[toolName];\n\n        const index = toolAnnotations.findIndex(\n          (annotation) => annotation.annotationUID === annotationUID\n        );\n\n        if (index !== -1) {\n          toolAnnotations.splice(index, 1);\n\n          if (toolAnnotations.length === 0) {\n            delete groupAnnotations[toolName];\n          }\n        }\n      }\n\n      if (Object.keys(groupAnnotations).length === 0) {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   *\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to remove annotations for.\n   */\n  removeAnnotations = (groupKey: string, toolName?: string): void => {\n    const annotations = this.annotations;\n    if (annotations[groupKey]) {\n      if (toolName) {\n        delete annotations[groupKey][toolName];\n      } else {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Returns a section of the annotations. Useful for serialization.\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\n   * for that groupKey (FrameOfReferenceUID) and toolName.\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\n   * for that groupKey.\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns A section of the annotations.\n   */\n  saveAnnotations = (\n    groupKey?: string,\n    toolName?: string\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        return;\n      }\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      return cloneDeep(toolSpecificAnnotations);\n    } else if (groupKey) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\n    }\n\n    return cloneDeep(annotations);\n  };\n\n  /**\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\n   *\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\n   * - If the `FrameOfReferenceUID` is given, the corresponding\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\n   * corresponding `Annotations` instance is restored.\n   *\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\n   */\n  restoreAnnotations = (\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\n    groupKey?: string,\n    toolName?: string\n  ): void => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      // Set Annotations for FrameOfReferenceUID and toolName.\n\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        annotations[groupKey] = {};\n\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      }\n\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\n    } else if (groupKey) {\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\n\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\n    } else {\n      // Set entire annotations\n      this.annotations = <AnnotationState>cloneDeep(state);\n    }\n  };\n\n  /**\n   * return all annotations as a single array\n   */\n  getAllAnnotations = (): Annotations => {\n    return Object.values(this.annotations)\n      .map((frameOfReferenceSpecificAnnotations) =>\n        Object.values(frameOfReferenceSpecificAnnotations)\n      )\n      .flat(2);\n  };\n\n  /**\n   * A function that returns the number of all annotations in the annotation state\n   *\n   * @returns The number of all annotations in the state\n   */\n  getNumberOfAllAnnotations = (): number => {\n    let count = 0;\n    const annotations = this.annotations;\n    for (const groupKey in annotations) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\n        const toolSpecificAnnotations =\n          frameOfReferenceSpecificAnnotations[toolName];\n        count += toolSpecificAnnotations.length;\n      }\n    }\n    return count;\n  };\n\n  /**\n   * Removes all annotations in the annotation state.\n   */\n  removeAllAnnotations = (): void => {\n    this.annotations = {};\n  };\n}\n\nconst defaultFrameOfReferenceSpecificAnnotationManager =\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\n\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\n\n/*\n * Constants\n */\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"Locked\" state of a given annotation instance.\n *\n * @triggers ANNOTATION_LOCK_CHANGE\n *\n * @param annotation - The annotation instance which will have\n * its locked state changed. An event will only be triggered if the locked state\n * of the given annotation instance changed.\n * @param locked - A boolean value indicating if the instance should\n * be locked (true) or not (false)\n */\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\n  const detail = makeEventDetail();\n  if (annotation) {\n    if (locked) {\n      lock(annotation, globalLockedAnnotationsSet, detail);\n    } else {\n      unlock(annotation, globalLockedAnnotationsSet, detail);\n    }\n  }\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Clears all the locked annotation\n *\n */\nfunction unlockAllAnnotations(): void {\n  const detail = makeEventDetail();\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Returns an array of all the annotation that is currently locked\n * @returns An array of tool specific annotation objects.\n *\n */\nfunction getAnnotationsLocked(): Array<Annotation> {\n  return Array.from(globalLockedAnnotationsSet);\n}\n\n/**\n * Given a Annotation object, return true if it is locked.\n * @param annotation - Annotation\n * @returns A boolean value.\n */\nfunction isAnnotationLocked(annotation: Annotation): boolean {\n  return globalLockedAnnotationsSet.has(annotation);\n}\n\n/**\n * Get the number of locked annotation objects in the global set of locked annotation\n * objects.\n * @returns The number of locked annotation objects.\n *\n */\nfunction getAnnotationsLockedCount(): number {\n  return globalLockedAnnotationsSet.size;\n}\n\n/**\n * Properly initialize the isLocked on annotation, and set it as locked if\n * isLocked is true.\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isLocked = !!annotation.isLocked;\n    if (shouldDefineIsLockedProperty(annotation)) {\n      Object.defineProperty(annotation, 'isLocked', {\n        configurable: false,\n        enumerable: true,\n        set: setIsLocked,\n        get: getIsLocked,\n      });\n    }\n    setAnnotationLocked(annotation, isLocked);\n  }\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    locked: [],\n  });\n}\n\nfunction lock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (!lockedAnnotationsSet.has(annotation)) {\n    lockedAnnotationsSet.add(annotation);\n    detail.added.push(annotation);\n  }\n}\n\nfunction unlock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (lockedAnnotationsSet.delete(annotation)) {\n    detail.removed.push(annotation);\n  }\n}\n\nfunction clearLockedAnnotationsSet(\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  lockedAnnotationsSet.forEach((annotation) => {\n    unlock(annotation, lockedAnnotationsSet, detail);\n  });\n}\n\nfunction publish(\n  detail: AnnotationLockChangeEventDetail,\n  lockedAnnotationsSet: Set<Annotation>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsLocked(locked: boolean) {\n  setAnnotationLocked(this as Annotation, locked);\n}\n\nfunction getIsLocked() {\n  return isAnnotationLocked(this as Annotation);\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationLocked,\n  getAnnotationsLocked,\n  getAnnotationsLockedCount,\n  unlockAllAnnotations,\n  isAnnotationLocked,\n  checkAndDefineIsLockedProperty,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\nimport { getAnnotation } from './annotationState';\n\n/*\n * Constants\n */\n\nconst selectedAnnotationUIDs: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set a given annotationUID as selected or deselected based on the provided\n * selected value.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction setAnnotationSelected(\n  annotationUID: string,\n  selected = true,\n  preserveSelected = false\n): void {\n  if (selected) {\n    selectAnnotation(annotationUID, preserveSelected);\n  } else {\n    deselectAnnotation(annotationUID);\n  }\n}\n\n/**\n * Set a given annotation as selected.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction selectAnnotation(\n  annotationUID: string,\n  preserveSelected = false\n): void {\n  const detail = makeEventDetail();\n  if (!preserveSelected) {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n    selectedAnnotationUIDs.add(annotationUID);\n    detail.added.push(annotationUID);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Deselect one or all annotations.\n *\n * @param annotationUID - If an annotation is provided that instance will be removed from\n * the internal selection set. If none is given, ALL selections will be cleared.\n */\nfunction deselectAnnotation(annotationUID?: string): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\n      detail.removed.push(annotationUID);\n    }\n  } else {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Return an array of ALL the selected annotationUIDs\n * @returns An array of Annotation UIDs\n */\nfunction getAnnotationsSelected(): Array<string> {\n  return Array.from(selectedAnnotationUIDs);\n}\n\n/**\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\n * @param toolName - The name of the tool you want to get the selected annotation for\n * @returns An array of annotationUIDs\n */\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\n  return getAnnotationsSelected().filter((annotationUID) => {\n    const annotation = getAnnotation(annotationUID);\n    return annotation?.metadata?.toolName === toolName;\n  });\n}\n\n/**\n * Given an annotationUID, return true if it is selected, false\n * otherwise.\n * @param annotationUID - Annotation UID\n * @returns A boolean value.\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return selectedAnnotationUIDs.has(annotationUID);\n}\n\n/**\n * Return the number of the selected annotation\n * @returns The size of the selected annotation set\n */\nfunction getAnnotationsSelectedCount(): number {\n  return selectedAnnotationUIDs.size;\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    selection: [],\n  });\n}\n\nfunction clearSelectionSet(\n  selectionSet: Set<string>,\n  detail: AnnotationSelectionChangeEventDetail\n): void {\n  selectionSet.forEach((value) => {\n    if (selectionSet.delete(value)) {\n      detail.removed.push(value);\n    }\n  });\n}\n\nfunction publish(\n  detail: AnnotationSelectionChangeEventDetail,\n  selectionSet: Set<string>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    selectionSet.forEach((item) => void detail.selection.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n  }\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationSelected,\n  getAnnotationsSelected,\n  getAnnotationsSelectedByToolName,\n  getAnnotationsSelectedCount,\n  deselectAnnotation,\n  isAnnotationSelected,\n};\n","import {\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\nimport { AnnotationRemovedEventDetail } from '../../types/EventTypes';\nimport { AnnotationGroupSelector } from '../../types';\nimport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n} from './helpers/state';\n\n// our default annotation manager\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n\n/**\n * It returns the default annotations manager.\n * @returns the singleton default annotations manager.\n */\nfunction getAnnotationManager() {\n  return defaultManager;\n}\n\n/**\n * Set the annotation manager to be used for rendering, adding, removing, etc.\n * @param annotationManager - The annotation manager to be used\n */\nfunction setAnnotationManager(annotationManager) {\n  defaultManager = annotationManager;\n}\n\n// set back to default frameOfReferenceSpecificAnnotationManager\nfunction resetAnnotationManager() {\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\n\n/**\n * Returns the annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getAnnotations function will return the annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\n */\nfunction getAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): Annotations {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\n}\n\nfunction getAllAnnotations(): Annotations {\n  const manager = getAnnotationManager();\n  return manager.getAllAnnotations();\n}\n\n/**\n * Removes the association between the annotation passed as parameter and its\n * parent in case it has one (eg: contour holes).\n * @param annotation - Annotation\n */\nfunction clearParentAnnotation(annotation: Annotation): void {\n  const { annotationUID: childUID, parentAnnotationUID } = annotation;\n\n  if (!parentAnnotationUID) {\n    return;\n  }\n\n  const parentAnnotation = getAnnotation(parentAnnotationUID);\n  const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\n\n  parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\n  annotation.parentAnnotationUID = undefined;\n}\n\n/**\n * Creates a parent/child association between annotations.\n * A annotation may have only one parent and multiple children (eg: a contour\n * may have multiple holes in it).\n * @param parentAnnotation - Parent annotation\n * @param childAnnotation - Child annotation\n */\nfunction addChildAnnotation(\n  parentAnnotation: Annotation,\n  childAnnotation: Annotation\n): void {\n  const { annotationUID: parentUID } = parentAnnotation;\n  const { annotationUID: childUID } = childAnnotation;\n\n  // Make sure it is not associated with any other tool\n  clearParentAnnotation(childAnnotation);\n\n  if (!parentAnnotation.childAnnotationUIDs) {\n    parentAnnotation.childAnnotationUIDs = [];\n  }\n\n  // Check if it is already a child\n  if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\n    return;\n  }\n\n  parentAnnotation.childAnnotationUIDs.push(childUID);\n  childAnnotation.parentAnnotationUID = parentUID;\n}\n\n/**\n * Returns the parent annotation of a given one since annotations can be\n * associated in a parent/child way (eg: polyline holes)\n * @param annotation - Annotation\n * @returns Parent annotation\n */\nfunction getParentAnnotation(annotation: Annotation) {\n  return annotation.parentAnnotationUID\n    ? getAnnotation(annotation.parentAnnotationUID)\n    : undefined;\n}\n\n/**\n * Returns all children annotation of a given one since annotations can be\n * associated in a parent/child way (eg: polyline holes)\n * @param annotation - Annotation\n * @returns Child annotations\n */\nfunction getChildAnnotations(annotation: Annotation) {\n  return (\n    annotation.childAnnotationUIDs?.map((childAnnotationUID) =>\n      getAnnotation(childAnnotationUID)\n    ) ?? []\n  );\n}\n\n/**\n * Add the annotation to the annotation manager along with the options that is\n * used to filter the annotation manager and the annotation group that\n * the annotation belongs to.\n *\n * As a result, our default implementation will add the annotation to the\n * default manager using the FrameOfReferenceUID as the group key.\n *\n * @param annotation - The annotation that is being added to the annotations manager.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n */\nfunction addAnnotation(\n  annotation: Annotation,\n  annotationGroupSelector: AnnotationGroupSelector\n): string {\n  if (!annotation.annotationUID) {\n    annotation.annotationUID = csUtils.uuidv4() as string;\n  }\n\n  const manager = getAnnotationManager();\n\n  // if the annotation manager selector is an element, trigger the\n  // annotation added event for that element.\n  if (annotationGroupSelector instanceof HTMLDivElement) {\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    manager.addAnnotation(annotation, groupKey);\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n  } else {\n    // if no element is provided, render all viewports that have the\n    // same frame of reference.\n    // Todo: we should do something else here for other types of annotation managers.\n    manager.addAnnotation(annotation);\n    triggerAnnotationAddedForFOR(annotation);\n  }\n\n  return annotation.annotationUID;\n}\n\n/**\n * Get the number of annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n *\n */\nfunction getNumberOfAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): number {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  return manager.getNumberOfAnnotations(groupKey, toolName);\n}\n\n/**\n * Remove the annotation by UID of the annotation.\n * @param annotationUID - The unique identifier for the annotation.\n */\nfunction removeAnnotation(annotationUID: string): void {\n  if (!annotationUID) {\n    return;\n  }\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  // no need to continue in case there is no annotation.\n  if (!annotation) {\n    return;\n  }\n\n  // Remove all child annotations first\n  annotation.childAnnotationUIDs?.forEach((childAnnotationUID) =>\n    removeAnnotation(childAnnotationUID)\n  );\n\n  manager.removeAnnotation(annotationUID);\n\n  // trigger annotation removed\n  const eventType = Events.ANNOTATION_REMOVED;\n\n  const eventDetail: AnnotationRemovedEventDetail = {\n    annotation,\n    annotationManagerUID: manager.uid,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Get the Annotation object by its UID\n * @param annotationUID - The unique identifier of the annotation.\n */\nfunction getAnnotation(annotationUID: string): Annotation {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  return annotation;\n}\n\n/**\n * It removes all annotations from the default annotation manager\n */\nfunction removeAllAnnotations(): void {\n  const manager = getAnnotationManager();\n  manager.removeAllAnnotations();\n}\n\n/**\n * Invalidate current and all parent annotations (eg: contour holes)\n * @param annotation - Annotation\n */\nfunction invalidateAnnotation(annotation: Annotation): void {\n  let currAnnotation = annotation;\n\n  while (currAnnotation) {\n    currAnnotation.invalidated = true;\n\n    currAnnotation = currAnnotation.parentAnnotationUID\n      ? getAnnotation(currAnnotation.parentAnnotationUID)\n      : undefined;\n  }\n}\n\nexport {\n  getAllAnnotations,\n  getAnnotations,\n  getParentAnnotation,\n  getChildAnnotations,\n  clearParentAnnotation,\n  addChildAnnotation,\n  getNumberOfAnnotations,\n  addAnnotation,\n  getAnnotation,\n  removeAnnotation,\n  removeAllAnnotations,\n  // annotation manager\n  setAnnotationManager,\n  getAnnotationManager,\n  resetAnnotationManager,\n  invalidateAnnotation,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\nimport {\n  isAnnotationSelected,\n  deselectAnnotation,\n} from './annotationSelection';\n\n/*\n * It stores all hidden annotation uids.\n */\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"visible\" state of a given annotation instance.\n *\n * @event ANNOTATION_VISIBILITY_CHANGE\n *\n * @param annotationUID - The annotation uid which will have\n * its visible state changed. An event will only be triggered if the visible state\n * of the given annotation instance changed.\n * @param visible - A boolean value indicating if the instance should\n * be visible (true) or not (false)\n */\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (visible) {\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    } else {\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    }\n  }\n  publish(detail);\n}\n\n/**\n * Clears all the hidden annotations.\n *\n */\nfunction showAllAnnotations(): void {\n  const detail = makeEventDetail();\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n  });\n  publish(detail);\n}\n\n/**\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\n * @param annotationUID - The annotation uid to tell if is visible or not.\n * @returns A boolean value or value if does not exist.\n */\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\n  const annotation = getAnnotation(annotationUID);\n\n  if (annotation) {\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n  }\n}\n/**\n * It decorates given annotation with isVisible property.\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\n *\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isVisible = annotation.isVisible ?? true;\n    if (shouldDefineIsVisibleProperty(annotation)) {\n      Object.defineProperty(annotation, 'isVisible', {\n        configurable: false,\n        enumerable: true,\n        set: setIsVisible,\n        get: getIsVisible,\n      });\n    }\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\n  }\n}\n\n/*\n * Private Helpers\n */\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\n  return Object.freeze({\n    lastVisible: [],\n    lastHidden: [],\n    hidden: [],\n  });\n}\n\nfunction show(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (annotationUIDsSet.delete(annotationUID)) {\n    detail.lastVisible.push(annotationUID);\n  }\n}\n\nfunction hide(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (!annotationUIDsSet.has(annotationUID)) {\n    annotationUIDsSet.add(annotationUID);\n    if (isAnnotationSelected(annotationUID)) {\n      deselectAnnotation(annotationUID);\n    }\n    detail.lastHidden.push(annotationUID);\n  }\n}\n\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n    globalHiddenAnnotationUIDsSet.forEach(\n      (item) => void detail.hidden.push(item)\n    );\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsVisible(hidden: boolean) {\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\n}\n\nfunction getIsVisible() {\n  return isAnnotationVisible((this as Annotation).annotationUID);\n}\n\nexport {\n  setAnnotationVisibility,\n  showAllAnnotations,\n  isAnnotationVisible,\n  checkAndDefineIsVisibleProperty,\n};\n","import {\n  StyleConfig,\n  ToolStyleConfig,\n  StyleSpecifier,\n  AnnotationStyle,\n} from '../../../types/AnnotationStyle';\n\n/**\n * This class handles the configuration of the tool style. You can use it to set\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\n *\n * The hierarchy of the configuration is as follows (each level falls back to the\n * next level if not specified):\n *\n * 1) Annotation-level styles (with annotationUID)\n *     2) Viewport-level tool styles\n *         - Per-tool: Length on the viewport with viewportId\n *         - Global: All tools on the viewport with viewportId\n *             3) ToolGroup tool styles\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\n *                 - Global: All tools in the toolGroupId for all viewports\n *                     4) Default level:\n *                         - Per-tool: Length styles\n *                         - Global: Opinionated styles by CornerstoneJS\n */\nclass ToolStyle {\n  config: StyleConfig;\n\n  constructor() {\n    const defaultConfig = {\n      color: 'rgb(255, 255, 0)',\n      colorHighlighted: 'rgb(0, 255, 0)',\n      colorSelected: 'rgb(0, 220, 0)',\n      colorLocked: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '',\n      shadow: true,\n      textBoxVisibility: true,\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n      textBoxFontSize: '14px',\n      textBoxColor: 'rgb(255, 255, 0)',\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\n      textBoxColorSelected: 'rgb(0, 255, 0)',\n      textBoxColorLocked: 'rgb(255, 255, 0)',\n      textBoxBackground: '',\n      textBoxLinkLineWidth: '1',\n      textBoxLinkLineDash: '2,3',\n      textBoxShadow: true,\n    };\n\n    this._initializeConfig(defaultConfig);\n  }\n\n  /**\n   * It returns the annotation-specific tool styles for the annotation with the given UID\n   * @param annotationUID - The unique identifier of the annotation.\n   * @returns The annotation tool styles for the annotation with the given UID.\n   */\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\n    return this.config.annotations && this.config.annotations[annotationUID];\n  }\n\n  /**\n   * It returns the styles for a given viewport. It includes tool-specific and\n   * global styles (all tools in the viewport)\n   * @param viewportId - The id of the viewport\n   * @returns The viewport tool styles for the given viewport id.\n   */\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\n    return this.config.viewports && this.config.viewports[viewportId];\n  }\n\n  /**\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\n   * global styles (all tools in the toolGroup)\n   * @param toolGroupId - The id of the toolGroup.\n   * @returns The tool styles for the tool group with the given id.\n   */\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n  }\n\n  /**\n   * It returns the default tool styles from the config file. It includes tool-specific and\n   * global styles (all tools in all tooLGroups)\n   * @returns The default tool styles.\n   */\n  getDefaultToolStyles(): ToolStyleConfig {\n    return this.config.default;\n  }\n\n  /**\n   * It takes an annotationUID and a style object and sets the styles at\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\n   * object with key value pairs.\n   * @param annotationUID - string - The unique identifier for the annotation.\n   * @param styles - ToolStyles\n   */\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\n    let annotationSpecificStyles = this.config.annotations;\n\n    if (!annotationSpecificStyles) {\n      this.config = {\n        ...this.config,\n        annotations: {},\n      };\n\n      annotationSpecificStyles = this.config.annotations;\n    }\n\n    annotationSpecificStyles[annotationUID] = styles;\n  }\n\n  /**\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\n   * @param viewportId - The id of the viewport\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\n   */\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\n    let viewportSpecificStyles = this.config.viewports;\n\n    if (!viewportSpecificStyles) {\n      this.config = {\n        ...this.config,\n        viewports: {},\n      };\n\n      viewportSpecificStyles = this.config.viewports;\n    }\n\n    viewportSpecificStyles[viewportId] = styles;\n  }\n\n  /**\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\n   * @param toolGroupId - The id of the toolGroup\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\n   * global styles (All tools in the toolGroup for all viewports)\n   */\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\n    let toolGroupSpecificStyles = this.config.toolGroups;\n\n    if (!toolGroupSpecificStyles) {\n      this.config = {\n        ...this.config,\n        toolGroups: {},\n      };\n\n      toolGroupSpecificStyles = this.config.toolGroups;\n    }\n\n    toolGroupSpecificStyles[toolGroupId] = styles;\n  }\n\n  /**\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\n   * global styles (All tools in all tooLGroups)\n   */\n  setDefaultToolStyles(styles: ToolStyleConfig) {\n    this.config.default = styles;\n  }\n\n  /**\n   * It returns the value for a given style key, based on the provided specifications.\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\n   * then at the toolGroup-specific styles, and finally at the default styles.\n   * @param styleKey - The key of the style.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met\n   * @returns The value for the given style key.\n   */\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n\n    return this._getToolStyle(\n      toolStyle,\n      annotationUID,\n      viewportId,\n      toolGroupId,\n      toolName\n    );\n  }\n\n  private _getToolStyle(\n    property: string,\n    annotationUID: string,\n    viewportId: string,\n    toolGroupId: string,\n    toolName: string\n  ) {\n    if (annotationUID) {\n      const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n\n      if (annotationToolStyles) {\n        // check first in the toolSpecific styles\n        if (annotationToolStyles[property] !== undefined) {\n          return annotationToolStyles[property];\n        }\n      }\n    }\n\n    if (viewportId) {\n      const viewportToolStyles = this.getViewportToolStyles(viewportId);\n\n      if (viewportToolStyles) {\n        // check if we have the viewportId specific style\n        // check first in the toolSpecific styles\n        if (\n          viewportToolStyles[toolName] &&\n          viewportToolStyles[toolName][property] !== undefined\n        ) {\n          return viewportToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the viewport specific global viewportSpecificStyles\n        if (\n          viewportToolStyles.global &&\n          viewportToolStyles.global[property] !== undefined\n        ) {\n          return viewportToolStyles.global[property];\n        }\n      }\n    }\n\n    if (toolGroupId) {\n      const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n\n      if (toolGroupToolStyles) {\n        // check first in the toolSpecific styles\n        if (\n          toolGroupToolStyles[toolName] &&\n          toolGroupToolStyles[toolName][property] !== undefined\n        ) {\n          return toolGroupToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the toolGroup specific global styles\n        if (\n          toolGroupToolStyles.global &&\n          toolGroupToolStyles.global[property] !== undefined\n        ) {\n          return toolGroupToolStyles.global[property];\n        }\n      }\n    }\n\n    const globalStyles = this.getDefaultToolStyles();\n\n    if (\n      globalStyles[toolName] &&\n      globalStyles[toolName][property] !== undefined\n    ) {\n      return globalStyles[toolName][property];\n    }\n\n    if (globalStyles.global && globalStyles.global[property] !== undefined) {\n      return globalStyles.global[property];\n    }\n  }\n\n  private _initializeConfig(config) {\n    const toolStyles = {};\n    for (const name in config) {\n      toolStyles[name] = config[name];\n    }\n\n    this.config = {\n      default: {\n        global: toolStyles as AnnotationStyle,\n      },\n    };\n  }\n}\n\nconst toolStyle = new ToolStyle();\n\nexport default toolStyle;\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport toolStyle from './ToolStyle';\n\n/**\n * Build a list of hierarchal property names in ascending order of priority\n * @param property - The base property name -- e.g., 'color'\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns A list of property names\n */\nfunction getHierarchalPropertyStyles(\n  property: string,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string[] {\n  const list = [`${property}`];\n  if (state) {\n    list.push(`${list[0]}${state}`);\n  }\n  if (mode) {\n    list.push(`${list[list.length - 1]}${mode}`);\n  }\n  return list;\n}\n\n/**\n * Get the value of a style property from the ToolStyle config\n * @param property - The name of the property to get.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - The state of the tool (Default, Locked etc.)\n * @param mode - The current tool mode. (Active, Passive etc.)\n * @returns The value of the property.\n */\nfunction getStyleProperty(\n  property: string,\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  // Hierarchal property styles is a list of property names with priority in ascending\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\n  // property will be used. This is done to ensure that the most specific property is used.\n  // Thus, we attempt resolving property names in reverse order\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\n  for (let i = alternatives.length - 1; i >= 0; --i) {\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n    if (style !== undefined) {\n      return style;\n    }\n  }\n}\n\nexport { getStyleProperty };\n","import { Annotation } from '../../../types';\nimport { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\n\n/**\n * Given a Annotation object, return the annotationStyle State that it\n * should be in based on its data.\n * The ordering of states is:\n *   * Highlighted\n *   * Selected\n *   * Locked\n *   * Autogenerated\n *   * Default\n * So the first one that applies will be returned.\n * For the autogenerated state, it depends on the autoGenerated flag on the\n * annotation, so once that is gone/false, the annotation will go to default.\n *\n * @param annotation - The annotation that we want to style.\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, Selected, or AutoGenerated.\n */\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\n  if (annotation) {\n    if (annotation.data && annotation.highlighted) {\n      return AnnotationStyleStates.Highlighted;\n    }\n    if (isAnnotationSelected(annotation.annotationUID)) {\n      return AnnotationStyleStates.Selected;\n    }\n\n    // Todo: make annotation lock api not to rely on the annotation itself\n    if (isAnnotationLocked(annotation)) {\n      return AnnotationStyleStates.Locked;\n    }\n\n    if (annotation.data && annotation.autoGenerated) {\n      return AnnotationStyleStates.AutoGenerated;\n    }\n  }\n\n  return AnnotationStyleStates.Default;\n}\n\nexport default getState;\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport { getStyleProperty } from './helpers';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\n\n/**\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns The font string.\n */\nfunction getFont(\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  const fontSize = getStyleProperty(\n    'textBoxFontSize',\n    styleSpecifier,\n    state,\n    mode\n  );\n  const fontFamily = getStyleProperty(\n    'textBoxFontFamily',\n    styleSpecifier,\n    state,\n    mode\n  );\n\n  return `${fontSize}px ${fontFamily}`;\n}\n\nexport default getFont;\n","import {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport { Events, ChangeTypes } from '../../../enums';\nimport { Annotation } from '../../../types/AnnotationTypes';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nimport {\n  AnnotationAddedEventDetail,\n  AnnotationModifiedEventDetail,\n  AnnotationCompletedEventDetail,\n  ContourAnnotationCompletedEventDetail,\n} from '../../../types/EventTypes';\n\n/**\n * It triggers an event for the element when an annotation is added\n * @param annotation - Annotation - The annotation that was added.\n * @param element - The element that the annotation was added to.\n */\nfunction triggerAnnotationAddedForElement(\n  annotation: Annotation,\n  element: HTMLDivElement\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewportId } = enabledElement;\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  const eventDetail: AnnotationAddedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId: renderingEngine.id,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\n * event for all the viewports that has the same FrameOfReferenceUID.\n * @param annotation -  Annotation - The annotation that was added\n */\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\n  const { toolName } = annotation.metadata;\n\n  const toolGroups = getToolGroupsWithToolName(toolName);\n  if (!toolGroups.length) {\n    return;\n  }\n\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\n  const viewportsToRender = [];\n  toolGroups.forEach((toolGroup) => {\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n        viewportsToRender.push(viewportInfo);\n      }\n    });\n  });\n\n  const eventType = Events.ANNOTATION_ADDED;\n  const eventDetail: AnnotationAddedEventDetail = { annotation };\n\n  if (!viewportsToRender.length) {\n    triggerEvent(eventTarget, eventType, eventDetail);\n    return;\n  }\n\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n    eventDetail.viewportId = viewportId;\n    eventDetail.renderingEngineId = renderingEngineId;\n    triggerEvent(eventTarget, eventType, eventDetail);\n  });\n}\n\n/**\n * Triggers an annotation modified event.\n */\nfunction triggerAnnotationModified(\n  annotation: Annotation,\n  element: HTMLDivElement,\n  changeType = ChangeTypes.HandlesUpdated\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const eventType = Events.ANNOTATION_MODIFIED;\n  const eventDetail: AnnotationModifiedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId,\n    changeType,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Triggers an annotation completed event.\n */\nfunction triggerAnnotationCompleted(annotation: Annotation): void {\n  const eventDetail: AnnotationCompletedEventDetail = {\n    annotation,\n  };\n\n  _triggerAnnotationCompleted(eventDetail);\n}\n\n/**\n * Triggers an annotation completed event for contours (same annotation completed\n * event but with more specific details).\n */\nfunction triggerContourAnnotationCompleted(\n  annotation: Annotation,\n  contourHoleProcessingEnabled = false\n): void {\n  const eventDetail: ContourAnnotationCompletedEventDetail = {\n    annotation,\n    contourHoleProcessingEnabled,\n  };\n\n  _triggerAnnotationCompleted(eventDetail);\n}\n\n/**\n * Triggers an annotation completed event for the `detail` provided\n * @param eventDetail - Event detail\n */\nfunction _triggerAnnotationCompleted(\n  eventDetail: AnnotationCompletedEventDetail\n) {\n  const eventType = Events.ANNOTATION_COMPLETED;\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\nexport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n  triggerAnnotationModified,\n  triggerAnnotationCompleted,\n  triggerContourAnnotationCompleted,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\n\nexport type BaseEventDetail = {\n  viewportId: string;\n  renderingEngineId: string;\n};\n\n/**\n * An annotation group\n */\n\nexport default class AnnotationGroup {\n  private annotationUIDs = new Set<string>();\n  private _isVisible = true;\n\n  public visibleFilter: (uid: string) => boolean;\n\n  constructor() {\n    this.visibleFilter = this.unboundVisibleFilter.bind(this);\n  }\n\n  /**\n   * Returns true if other groups are free to hide this annotation.\n   * That is, if the annotation is not a member or is hidden.\n   */\n  protected unboundVisibleFilter(uid: string): boolean {\n    return !this._isVisible || !this.annotationUIDs.has(uid);\n  }\n\n  public has(uid: string): boolean {\n    return this.annotationUIDs.has(uid);\n  }\n  /**\n   * Sets whether annotations belonging to this group are visible or not.\n   * If there are multiple groups, then the set visible false should be called\n   * before before re-enabling the other groups with setVisible true.\n   */\n  public setVisible(\n    isVisible = true,\n    baseEvent: BaseEventDetail,\n    filter?: (annotationUID: string) => boolean\n  ) {\n    if (this._isVisible === isVisible) {\n      return;\n    }\n    this._isVisible = isVisible;\n    this.annotationUIDs.forEach((uid) => {\n      const annotation = getAnnotation(uid);\n      if (!annotation) {\n        this.annotationUIDs.delete(uid);\n        return;\n      }\n      if (annotation.isVisible === isVisible) {\n        return;\n      }\n      if (!isVisible && filter?.(uid) === false) {\n        return;\n      }\n      annotation.isVisible = isVisible;\n      const eventDetail = {\n        ...baseEvent,\n        annotation,\n      };\n      triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n    });\n  }\n\n  public get isVisible() {\n    return this._isVisible;\n  }\n\n  /** Finds the nearby/next annotation in the given direction */\n  public findNearby(uid: string, direction: 1) {\n    const uids = [...this.annotationUIDs];\n    if (uids.length === 0) {\n      return null;\n    }\n    if (!uid) {\n      return uids[direction === 1 ? 0 : uids.length - 1];\n    }\n    const index = uids.indexOf(uid);\n    if (\n      index === -1 ||\n      index + direction < 0 ||\n      index + direction >= uids.length\n    ) {\n      return null;\n    }\n    return uids[index + direction];\n  }\n\n  /**\n   * Adds the annotation to the group\n   * Does NOT change the visibility status of the annotation.\n   */\n  public add(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.add(annotationUID)\n    );\n  }\n\n  /**\n   * Removes the annotation from the group.\n   * Does not affect the visibility status of the annotation.\n   */\n  public remove(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.delete(annotationUID)\n    );\n  }\n\n  /**\n   * Removes everything from the group.\n   */\n  public clear() {\n    this.annotationUIDs.clear();\n  }\n}\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\nimport {\n  getDefaultSegmentationStateManager,\n  getSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the active segmentation representation for the tool group with\n * the given toolGroupId.\n * @param toolGroupId - The Id of the tool group\n * @returns The active segmentation representation for the tool group.\n */\nfunction getActiveSegmentationRepresentation(\n  toolGroupId: string\n): ToolGroupSpecificRepresentation {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const toolGroupSegmentationRepresentations =\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\n    (representation) => representation.active\n  );\n\n  return activeRepresentation;\n}\n\n/**\n * Retrieves the active segmentation for a given tool group.\n * @param toolGroupId - The ID of the tool group.\n * @returns The active segmentation Id, or undefined if no active segmentation is found.\n */\nfunction getActiveSegmentation(toolGroupId: string) {\n  const activeRepresentation = getActiveSegmentationRepresentation(toolGroupId);\n\n  if (!activeRepresentation) {\n    return;\n  }\n\n  const activeSegmentation = getSegmentation(\n    activeRepresentation.segmentationId\n  );\n\n  return activeSegmentation;\n}\n\n/**\n * Set the active segmentation for the given tool group for all its viewports\n *\n * @param toolGroupId - The Id of the tool group to set the active\n * segmentation for.\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\n * active.\n */\nfunction setActiveSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  segmentationStateManager.setActiveSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  // get\n  getActiveSegmentationRepresentation,\n  getActiveSegmentation,\n  // set\n  setActiveSegmentationRepresentation,\n};\n","import * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\nimport { getUniqueSegmentIndices } from '../../../utilities/segmentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * Set the visibility of a segmentation representation for a given tool group. It fires\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\n * and visibility false will hide all segments\"\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param visibility - boolean\n */\nfunction setSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  visibility: boolean\n): void {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // if visibility is set to be true, we need to remove all the segments\n  // from the segmentsHidden set, otherwise we need to add all the segments\n  // to the segmentsHidden set\n  if (visibility) {\n    segmentsHidden.clear();\n  } else {\n    indices.forEach((index) => {\n      segmentsHidden.add(index);\n    });\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    representation.segmentationRepresentationUID\n  );\n}\n\n/**\n * Get the visibility of a segmentation data for a given tool group.\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The id of the segmentation data to get\n * @returns A boolean value that indicates whether the segmentation data is visible or\n * not on the toolGroup\n */\nfunction getSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): boolean | undefined {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // Create a set that contains all segments indices\n  const indicesSet = new Set(indices);\n\n  // Remove a indices that are hidden\n  segmentsHidden.forEach((segmentIndex) => indicesSet.delete(segmentIndex));\n\n  // Check if there is at least one segment visible\n  return !!indicesSet.size;\n}\n\n/**\n * Set the visibility of the given segment indices to the given visibility. This\n * is a helper to set the visibility of multiple segments at once and reduces\n * the number of events fired.\n *\n * @param toolGroupId -  The tool group id of the segmentation representation.\n * @param segmentationRepresentationUID -  The UID of the segmentation\n * representation.\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\n * @param visibility -  The visibility to set the segments to.\n *\n */\nfunction setSegmentsVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndices: number[],\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  segmentIndices.forEach((segmentIndex) => {\n    visibility\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\n      : segRepresentation.segmentsHidden.add(segmentIndex);\n  });\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation\n * @param segmentationRepresentationUID - The id of the segmentation representation that contains the segment\n * @param segmentIndex - Index of the segment that will be updated\n * @param visibility - True to show the segment or false to hide it\n * @returns True if the segment is visible or false otherwise\n */\nfunction setSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  visibility\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\n    : segRepresentation.segmentsHidden.add(segmentIndex);\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param segmentIndex - Index of the segment\n * @returns True if the segment is visible or false otherwise\n */\nfunction getSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): boolean {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return false;\n  }\n\n  return !segRepresentation.segmentsHidden.has(segmentIndex);\n}\n\nexport {\n  setSegmentationVisibility,\n  getSegmentationVisibility,\n  setSegmentVisibility,\n  setSegmentsVisibility,\n  getSegmentVisibility,\n};\n","import {\n  Types,\n  Enums,\n  getWebWorkerManager,\n  eventTarget,\n  triggerEvent,\n} from '@cornerstonejs/core';\n\nimport { WorkerTypes } from '../../../enums';\nimport { pointToString } from '../../../utilities';\nimport { registerPolySegWorker } from '../polySeg/registerPolySegWorker';\nconst workerManager = getWebWorkerManager();\n\n/**\n * Surfaces info for clipping\n */\nexport type SurfacesInfo = {\n  id: string;\n  points: number[];\n  polys: number[];\n  segmentIndex: number;\n};\n\n/**\n * The result of the surface clipping\n */\nexport type SurfaceClipResult = {\n  points: number[];\n  lines: number[];\n  numberOfCells: number;\n};\n\nexport type PolyDataClipCacheType = Map<string, Map<string, SurfaceClipResult>>;\n\n/**\n * a cache from actorUID to cacheId to SurfaceClipResult\n * Map<actorUID, Map<cacheId, SurfaceClipResult>>\n * cacheId is slice specific (viewPlaneNormal, sliceIndex)\n */\nconst polyDataCache = new Map() as PolyDataClipCacheType;\nconst surfacesAABBCache = new Map();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.SURFACE_CLIPPING,\n  });\n};\n\n/**\n * Clips and caches surfaces for a specific viewport.\n *\n * @param surfacesInfo - An array of surfaces information.\n * @param viewport - The volume viewport.\n * @param segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns The cached polydata.\n */\nexport async function clipAndCacheSurfacesForViewport(\n  surfacesInfo: SurfacesInfo[],\n  viewport: Types.IVolumeViewport,\n  segmentationRepresentationUID: string\n) {\n  registerPolySegWorker();\n  // All planes is an array of planes pairs for each slice, so we should loop over them and\n  // add the planes to the clipping filter and cache the results for that slice\n\n  // Fix these ts ignores\n  // @ts-ignore\n  const planesInfo = viewport.getSlicesClippingPlanes?.();\n\n  if (!planesInfo) {\n    // this means it is probably the stack viewport not being ready\n    // in terms of planes which we should wait for the first render to\n    // get the planes\n    return;\n  }\n\n  // @ts-ignore\n  const currentSliceIndex = viewport.getSliceIndex();\n\n  // Reorder planesInfo based on proximity to currentSliceIndex\n  planesInfo.sort((a, b) => {\n    const diffA = Math.abs(a.sliceIndex - currentSliceIndex);\n    const diffB = Math.abs(b.sliceIndex - currentSliceIndex);\n    return diffA - diffB;\n  });\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  // check which surfaces don't have a cached AABB\n  // make a list of the surfaces that don't have a cached AABB\n  await updateSurfacesAABBCache(surfacesInfo);\n\n  const surfacesAABB = new Map();\n  surfacesInfo.forEach((surface) => {\n    surfacesAABB.set(surface.id, surfacesAABBCache.get(surface.id));\n  });\n\n  const camera = viewport.getCamera();\n\n  await workerManager\n    .executeTask(\n      'polySeg',\n      'cutSurfacesIntoPlanes',\n      {\n        surfacesInfo,\n        planesInfo,\n        surfacesAABB,\n      },\n      {\n        callbacks: [\n          // progress callback\n          ({ progress }) => {\n            triggerWorkerProgress(eventTarget, progress);\n          },\n          // update cache callback\n          ({ sliceIndex, polyDataResults }) => {\n            polyDataResults.forEach((polyDataResult, surfaceId) => {\n              const actorUID = `${segmentationRepresentationUID}_${surfaceId}`;\n              const cacheId = generateCacheId(\n                viewport,\n                camera.viewPlaneNormal,\n                sliceIndex\n              );\n              updatePolyDataCache(actorUID, cacheId, polyDataResult);\n            });\n          },\n        ],\n      }\n    )\n    .catch((error) => {\n      console.error(error);\n    });\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return polyDataCache;\n}\n\n/**\n * Updates the surfaces AABB cache with the AABB information for the given surfaces.\n * If the AABB information for a surface already exists in the cache, it will not be updated.\n * @param surfacesInfo - An array of surfaces information.\n * @returns A Promise that resolves when the surfaces AABB cache has been updated.\n */\nasync function updateSurfacesAABBCache(surfacesInfo: SurfacesInfo[]) {\n  const surfacesWithoutAABB = surfacesInfo.filter(\n    (surface) => !surfacesAABBCache.has(surface.id)\n  );\n\n  if (!surfacesWithoutAABB.length) {\n    return;\n  }\n\n  const surfacesAABB = await workerManager.executeTask(\n    'polySeg',\n    'getSurfacesAABBs',\n    {\n      surfacesInfo: surfacesWithoutAABB,\n    },\n    {\n      callbacks: [\n        // progress callback\n        ({ progress }) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  // update the surfacesAABBCache with the new surfacesAABB\n  surfacesAABB.forEach((aabb, id) => {\n    surfacesAABBCache.set(id, aabb);\n  });\n}\n\nexport function getSurfaceActorUID(\n  segmentationRepresentationUID: string,\n  surfaceId: string\n) {\n  return `${segmentationRepresentationUID}_${surfaceId}`;\n}\n\n// Helper function to generate a cache ID\nexport function generateCacheId(viewport, viewPlaneNormal, sliceIndex) {\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${sliceIndex}`;\n}\n\n// Helper function to update PolyData cache\nexport function updatePolyDataCache(\n  actorUID: string,\n  cacheId: string,\n  polyDataResult: SurfaceClipResult\n) {\n  const { points, lines, numberOfCells } = polyDataResult;\n\n  let actorCache = polyDataCache.get(actorUID);\n  if (!actorCache) {\n    actorCache = new Map<string, SurfaceClipResult>();\n    polyDataCache.set(actorUID, actorCache);\n  }\n  actorCache.set(cacheId, { points, lines, numberOfCells });\n}\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\n\nimport {\n  getSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n} from './segmentationState';\n\n/**\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\n * @param immediate - if True the viewport will be re-rendered immediately.\n */\nfunction removeSegmentationsFromToolGroup(\n  toolGroupId: string,\n  segmentationRepresentationUIDs?: string[] | undefined,\n  immediate?: boolean\n): void {\n  const toolGroupSegRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (\n    !toolGroupSegRepresentations ||\n    toolGroupSegRepresentations.length === 0\n  ) {\n    return;\n  }\n\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\n    (representation) => representation.segmentationRepresentationUID\n  );\n\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n  if (segRepresentationUIDsToRemove) {\n    // make sure the segmentationDataUIDs that are going to be removed belong\n    // to the toolGroup\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\n      (segRepresentationUID) =>\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\n    );\n\n    if (invalidSegRepresentationUIDs.length > 0) {\n      throw new Error(\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\n          invalidSegRepresentationUIDs\n        )}`\n      );\n    }\n  } else {\n    // remove all segmentation representations\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n  }\n\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n  });\n}\n\nfunction _removeSegmentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  immediate?: boolean\n): void {\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  const { type } = segmentationRepresentation;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    labelmapDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else if (type === SegmentationRepresentations.Contour) {\n    contourDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else {\n    throw new Error(`The representation ${type} is not supported yet`);\n  }\n}\n\nexport default removeSegmentationsFromToolGroup;\n","import * as Enums from '../../../enums';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport { validatePublic as validatePublicLabelmap } from '../../../tools/displayTools/Labelmap/validateLabelmap';\n\n/**\n * Validates the given segmentationInputArray to ensure it contains\n * appropriate representationProps for the representation type being used.\n *\n * @param segmentationInputArray - Array of segmentation inputs\n * @throws If the segmentationInputArray is undefined or empty\n * @throws If the segmentationInput.segmentationId is undefined\n * @throws If the segmentationInput.representation is undefined\n * @internal\n */\nfunction validateSegmentationInput(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  if (!segmentationInputArray || segmentationInputArray.length === 0) {\n    throw new Error(\n      'The segmentationInputArray is undefined or an empty array'\n    );\n  }\n\n  segmentationInputArray.forEach((segmentationInput) => {\n    if (segmentationInput.segmentationId === undefined) {\n      throw new Error(\n        'Undefined segmentationInput.segmentationId. Please provide a valid segmentationId'\n      );\n    }\n\n    if (segmentationInput.representation === undefined) {\n      throw new Error(\n        'Undefined segmentationInput.representation. Please provide a valid representation'\n      );\n    }\n\n    if (\n      segmentationInput.representation.type ===\n      Enums.SegmentationRepresentations.Labelmap\n    ) {\n      validatePublicLabelmap(segmentationInput);\n    }\n  });\n}\n\nexport default validateSegmentationInput;\n","import cloneDeep from 'lodash.clonedeep';\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\n/**\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\n * noted that segmentations are not added to any toolGroup's viewports. In order to\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\n * using addSegmentationRepresentations helper. The reason for this is that there\n * can be multiple representations of the same segmentation (e.g. Labelmap and\n * Contour, etc. - Currently only Labelmap representations is supported).\n * @param segmentationInputArray - The array of segmentation input, each of which\n * defining the segmentationId and the main representation data for the segmentation.\n */\nfunction addSegmentations(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  validateSegmentationInput(segmentationInputArray);\n\n  segmentationInputArray.map((segInput) => {\n    const segmentationInput = cloneDeep(segInput);\n\n    addSegmentationToState(segmentationInput);\n  });\n}\n\nexport default addSegmentations;\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\n\nimport {\n  RepresentationConfig,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It returns the global segmentation config.\n * @returns The global segmentation config containing the representations\n * config for each representation type and renderInactiveSegmentations flag.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  return SegmentationState.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation config\n * @param segmentationConfig - SegmentationConfig\n */\nfunction setGlobalConfig(\n  segmentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setGlobalConfig(segmentationConfig);\n}\n\n/**\n * Given a representation type, return the corresponding global representation config\n * @param representationType - The type of representation to query\n * @returns A representation configuration object.\n */\nfunction getGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations\n): RepresentationConfig['LABELMAP'] {\n  const globalConfig = getGlobalConfig();\n  return globalConfig.representations[representationType];\n}\n\n/**\n * Set the global configuration for a given representation type. It fires\n * a SEGMENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param representationType - The type of representation to set config for\n * @param config - The configuration for the representation.\n */\nfunction setGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations,\n  config: RepresentationConfig['LABELMAP']\n): void {\n  const globalConfig = getGlobalConfig();\n\n  setGlobalConfig({\n    ...globalConfig,\n    representations: {\n      ...globalConfig.representations,\n      [representationType]: {\n        ...globalConfig.representations[representationType],\n        ...config,\n      },\n    },\n  });\n}\n\n/**\n * Get the toolGroup specific segmentation config\n * @param toolGroupId - The Id of the tool group\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Sets the tool group specific configuration for the segmentation\n * representation. This will apply to all segmentation representations.\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\n * the segmentation representation.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setToolGroupSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationConfig\n  );\n}\n\n/**\n * Give the segmentation representation UID, return the corresponding config\n * which is shared by all segments in the segmentation representation. This is\n * an optional level of configuration that can be set by the user, by default\n * it will fallback to the toolGroup specific config, if not set, it will fallback\n * to the global config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n * @returns - The configuration for the representation.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Set the segmentation representation specific configuration for the\n * segmentation representation. This will apply to all segments in the\n * segmentation representation and has higher priority than the toolGroup\n * specific config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig\n): void {\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\n/**\n * Get the segment specific configuration for the segmentation representation.\n *\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\n */\nfunction getSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\n/**\n * Set the segment specific configuration for the segmentation representation.\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @param config - The configuration for the representation. This is an object\n */\nfunction setSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig\n): void {\n  SegmentationState.setSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport {\n  // Global\n  getGlobalConfig,\n  setGlobalConfig,\n  getGlobalRepresentationConfig,\n  setGlobalRepresentationConfig,\n  // ToolGroup Specific\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  // segmentation representation specific config\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  // segment specific config\n  getSegmentSpecificConfig,\n  setSegmentSpecificConfig,\n};\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { RepresentationPublicInput } from '../../../types';\nimport { getRepresentationRenderingConfig as getLabelmapRenderingConfig } from '../../../tools/displayTools/Labelmap/labelmapDisplay';\n\nexport function getRepresentationSpecificConfig(\n  representationInput: RepresentationPublicInput\n) {\n  const { type } = representationInput;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    return getLabelmapRenderingConfig();\n  } else {\n    return {};\n  }\n}\n","import { getRenderingEngine, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n  ToolGroupSpecificRepresentation,\n  RepresentationPublicInputOptions,\n} from '../../types/SegmentationStateTypes';\nimport * as SegmentationConfig from './config/segmentationConfig';\nimport {\n  addSegmentationRepresentation as addSegmentationRepresentationToState,\n  getNextColorLUTIndex,\n  addColorLUT,\n} from './segmentationState';\nimport { getRepresentationSpecificConfig } from './helpers/getRepresentationSpecificConfig';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { SegmentationRepresentations } from '../../enums';\n\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId, options = {} as RepresentationPublicInputOptions } =\n    representationInput;\n\n  const segmentationRepresentationUID =\n    representationInput.options?.segmentationRepresentationUID ||\n    utilities.uuidv4();\n\n  // Todo: make segmentsHidden also an option that can get passed by\n  // the user\n  const segmentsHidden = new Set() as Set<number>;\n\n  const colorLUTIndexToUse = getColorLUTIndex(options);\n\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: representationInput.type,\n    segmentsHidden,\n    colorLUTIndex: colorLUTIndexToUse,\n    active: true,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: getRepresentationSpecificConfig(representationInput),\n    polySeg: options.polySeg,\n  };\n\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n\n  addSegmentationRepresentationToState(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n\n  if (representationInput.type === SegmentationRepresentations.Contour) {\n    getToolGroup(toolGroupId)\n      .getViewportsInfo()\n      .forEach(({ viewportId, renderingEngineId }) => {\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n      });\n  }\n\n  return segmentationRepresentationUID;\n}\n\nfunction getColorLUTIndex(options = {} as RepresentationPublicInputOptions) {\n  const colorLUTOrIndexInput = options.colorLUTOrIndex;\n  let colorLUTIndexToUse;\n\n  if (typeof colorLUTOrIndexInput === 'number') {\n    colorLUTIndexToUse = colorLUTOrIndexInput;\n  } else {\n    const nextIndex = getNextColorLUTIndex();\n    const colorLUTToAdd = Array.isArray(colorLUTOrIndexInput)\n      ? colorLUTOrIndexInput\n      : CORNERSTONE_COLOR_LUT;\n    addColorLUT(colorLUTToAdd as Types.ColorLUT, nextIndex);\n    colorLUTIndexToUse = nextIndex;\n  }\n  return colorLUTIndexToUse;\n}\n\nexport { addSegmentationRepresentation };\n","import {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n} from '../../types/SegmentationStateTypes';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\nimport { addSegmentationRepresentation } from './addSegmentationRepresentation';\n\n/**\n * Set the specified segmentation representations on the viewports of the specified\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\n * configuration.\n *\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\n * for the segmentation representations\n */\nasync function addSegmentationRepresentations(\n  toolGroupId: string,\n  representationInputArray: RepresentationPublicInput[],\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string[]> {\n  // Check if there exists a toolGroup with the toolGroupId\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (!toolGroup) {\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n  }\n\n  const promises = representationInputArray.map((representationInput) => {\n    return addSegmentationRepresentation(\n      toolGroupId,\n      representationInput,\n      toolGroupSpecificRepresentationConfig\n    );\n  });\n\n  const segmentationRepresentationUIDs = await Promise.all(promises);\n\n  return segmentationRepresentationUIDs;\n}\n\nexport default addSegmentationRepresentations;\n","import { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { ContourSegmentationData } from '../../types/ContourTypes';\nimport { SurfaceSegmentationData } from '../../types/SurfaceTypes';\nimport { getSegmentation } from './segmentationState';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\ntype SegmentationData =\n  | LabelmapSegmentationData\n  | ContourSegmentationData\n  | SurfaceSegmentationData;\n\ntype AddRepresentationData = {\n  segmentationId: string;\n  type: SegmentationRepresentations;\n  data: SegmentationData;\n};\n\n/**\n * This will add representation data to the segmentation, for rendering.\n * Each segmentation can have multiple representation data, for example\n * labelmap, contour and surface representation data. For each representation\n * the relevant data should be provided, for instance for the labelmap\n * representation the volumeId should be provided, for contour the contour data\n * which includes geometryIds of the contour sets, and for surface the surface\n * data which includes geometryId of the points and cells.\n *\n * Note: if the representation data already exists for the segmentation, it will\n * be overwritten.\n *\n * @param segmentationId - id of the segmentation\n * @param representationData - representation data to add, it can be either\n * labelmap, contour or surface representation data.\n */\nfunction addRepresentationData({\n  segmentationId,\n  type,\n  data,\n}: AddRepresentationData) {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation.representationData[type]) {\n    console.warn(\n      `Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`\n    );\n\n    // update the representation data class\n  }\n\n  switch (type) {\n    case SegmentationRepresentations.Labelmap:\n      if (data) {\n        segmentation.representationData[type] =\n          data as LabelmapSegmentationData;\n      }\n      break;\n    case SegmentationRepresentations.Contour:\n      if (data) {\n        segmentation.representationData[type] = data as ContourSegmentationData;\n      }\n      break;\n    case SegmentationRepresentations.Surface:\n      if (data) {\n        segmentation.representationData[type] = data as SurfaceSegmentationData;\n      }\n      break;\n    default:\n      throw new Error(`Invalid representation type ${type}`);\n  }\n}\n\nexport default addRepresentationData;\n","import {\n  volumeLoader,\n  utilities as csUtils,\n  eventTarget,\n  cache,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport { triggerSegmentationRender } from '../../utilities/segmentation';\nimport { getSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\nasync function computeVolumeSegmentationFromStack({\n  imageIdReferenceMap,\n  options,\n}: {\n  imageIdReferenceMap: Map<string, string>;\n  options?: {\n    volumeId?: string;\n  };\n}): Promise<{ volumeId: string }> {\n  const segmentationImageIds = Array.from(imageIdReferenceMap.values());\n\n  const additionalDetails = {\n    imageIdReferenceMap,\n  };\n\n  const volumeId = options?.volumeId ?? csUtils.uuidv4();\n\n  await volumeLoader.createAndCacheVolumeFromImages(\n    volumeId,\n    segmentationImageIds,\n    {\n      additionalDetails,\n    }\n  );\n\n  return { volumeId };\n}\n\n/**\n * Converts a stack-based segmentation to a volume-based segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId to use for the segmentation.\n * @param [params.options.volumeId] - the new volumeId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.newSegmentationId] - the new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nasync function convertStackToVolumeSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    volumeId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataStack;\n\n  const { volumeId } = await computeVolumeSegmentationFromStack({\n    imageIdReferenceMap: data.imageIdReferenceMap,\n    options,\n  });\n\n  await updateSegmentationState({\n    segmentationId,\n    toolGroupId: options.toolGroupId,\n    options,\n    volumeId,\n  });\n}\n\n// This function is responsible for updating the segmentation state\nasync function updateSegmentationState({\n  segmentationId,\n  toolGroupId,\n  volumeId,\n  options,\n}: {\n  segmentationId: string;\n  toolGroupId: string;\n  volumeId: string;\n  options?: {\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (options?.removeOriginal) {\n    const data = segmentation.representationData\n      .LABELMAP as LabelmapSegmentationDataStack;\n\n    const imageIdReferenceMap = data.imageIdReferenceMap;\n\n    Array.from(imageIdReferenceMap.values()).forEach((imageId) => {\n      cache.removeImageLoadObject(imageId);\n    });\n\n    segmentation.representationData.LABELMAP = {\n      volumeId,\n    };\n  } else {\n    segmentation.representationData.LABELMAP = {\n      ...segmentation.representationData.LABELMAP,\n      volumeId,\n    };\n  }\n\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  // Note: It is crucial to trigger the data modified event. This ensures that the\n  // old texture is updated to the GPU, especially in scenarios where it may not be getting updated.\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(segmentationId)\n  );\n}\n\nexport { convertStackToVolumeSegmentation, computeVolumeSegmentationFromStack };\n","import {\n  Types,\n  cache,\n  eventTarget,\n  getRenderingEngines,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport {\n  triggerSegmentationRender,\n  createImageIdReferenceMap,\n} from '../../utilities/segmentation';\nimport { getSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataVolume } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\n// This function is responsible for the conversion calculations\nexport async function computeStackSegmentationFromVolume({\n  volumeId,\n}: {\n  volumeId: string;\n}): Promise<{ imageIdReferenceMap: Map<string, string> }> {\n  const segmentationVolume = cache.getVolume(volumeId) as Types.IImageVolume;\n\n  // we need to decache the segmentation Volume so that we use it\n  // for the conversion\n\n  // So here we have two scenarios that we need to handle:\n  // 1. the volume was derived from a stack and we need to decache it, this is easy\n  // since we just need purge the volume from the cache and those images will get\n  // their copy of the image back\n  // 2. It was actually a native volume and we need to decache it, this is a bit more\n  // complicated since then we need to decide on the imageIds for it to get\n  // decached to\n  const hasCachedImages = segmentationVolume.imageCacheOffsetMap.size > 0;\n  // Initialize the variable to hold the final result\n  let isAllImagesCached = false;\n\n  if (hasCachedImages) {\n    // Check if every imageId in the volume is in the _imageCache\n    isAllImagesCached = segmentationVolume.imageIds.every((imageId) =>\n      cache.getImage(imageId)\n    );\n  }\n\n  //Todo: This is a hack to get the rendering engine\n  const renderingEngine = getRenderingEngines()[0];\n  const volumeUsedInOtherViewports = renderingEngine\n    .getVolumeViewports()\n    .find((vp) => vp.hasVolumeId(volumeId));\n\n  segmentationVolume.decache(!volumeUsedInOtherViewports && isAllImagesCached);\n\n  const imageIdReferenceMap =\n    _getImageIdReferenceMapForStackSegmentation(segmentationVolume);\n\n  // check if the imageIds have been cache, if not we should actually copy\n\n  return { imageIdReferenceMap };\n}\n\n// Updated original function to call the new separate functions\nexport async function convertVolumeToStackSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    newSegmentationId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataVolume;\n  const { imageIdReferenceMap } = await computeStackSegmentationFromVolume({\n    volumeId: data.volumeId,\n  });\n\n  await updateStackSegmentationState({\n    segmentationId,\n    toolGroupId: options.toolGroupId,\n    imageIdReferenceMap,\n    options,\n  });\n}\n\n/**\n * Converts a volume segmentation to a stack segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId that the new segmentation will belong to.\n * @param [params.options.newSegmentationId] -  The new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nexport async function updateStackSegmentationState({\n  segmentationId,\n  toolGroupId,\n  imageIdReferenceMap,\n  options,\n}: {\n  segmentationId: string;\n  toolGroupId: string;\n  imageIdReferenceMap: Map<any, any>;\n  options?: {\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (options?.removeOriginal) {\n    const data = segmentation.representationData\n      .LABELMAP as LabelmapSegmentationDataVolume;\n\n    if (cache.getVolume(data.volumeId)) {\n      cache.removeVolumeLoadObject(data.volumeId);\n    }\n\n    segmentation.representationData.LABELMAP = {\n      imageIdReferenceMap,\n    };\n  } else {\n    segmentation.representationData.LABELMAP = {\n      ...segmentation.representationData.LABELMAP,\n      imageIdReferenceMap,\n    };\n  }\n\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(segmentationId)\n  );\n}\n\nfunction _getImageIdReferenceMapForStackSegmentation(\n  segmentationVolume: Types.IImageVolume\n) {\n  // There might be or might not be segmentationImageIds, if it is a volume\n  // segmentation converted from stack segmentation, there will be segmentationImageIds\n  // otherwise, if it is empty volume segmentation derived from\n  // a volume that is not a stack, there will be no segmentationImageIds\n\n  if (segmentationVolume.additionalDetails?.imageIdReferenceMap) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the imageIdReferenceMap from the additionalDetails\n    return segmentationVolume.additionalDetails.imageIdReferenceMap;\n  } else if (\n    segmentationVolume.referencedImageIds?.length &&\n    !segmentationVolume.referencedImageIds[0].startsWith('derived')\n  ) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the referencedImageIds from the segmentationVolume\n    const referencedImageIds = segmentationVolume.referencedImageIds;\n    const segmentationImageIds = segmentationVolume.imageIds;\n\n    return createImageIdReferenceMap(\n      referencedImageIds,\n      [...segmentationImageIds].reverse()\n    );\n  } else {\n    // check if the segmentation volume is derived from another volume and\n    // whether if that volume has imageIds\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n\n    if (!referencedVolume) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without referenced volume to stack segmentation yet'\n      );\n    }\n\n    if (!referencedVolume?.imageIds?.length) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without imageIds to stack segmentation yet'\n      );\n    }\n\n    if (referencedVolume.imageIds?.[0].startsWith('derived')) {\n      throw new Error(\n        `Cannot convert volume segmentation that is derived from another segmentation\n         to stack segmentation yet, include the additionalDetails.imageIdReferenceMap\n         in the volume segmentation in case you need it for the conversion`\n      );\n    }\n\n    // if the referenced volume has imageIds, and itself is not derived from\n    // another segmentation then we can use the imageIds from the referenced volume\n    const referencedImageIds = referencedVolume.imageIds;\n\n    let segmentationImageIdsToUse = segmentationVolume.imageIds;\n    if (!segmentationImageIdsToUse?.length) {\n      // If segmentation Ids don't exist it means that the segmentation is literally\n      // just a volume so we need to assume imageIds and decache it to the _imageCache\n      // so that it can be used for the conversion\n      segmentationImageIdsToUse =\n        segmentationVolume.convertToImageSlicesAndCache();\n    }\n\n    return createImageIdReferenceMap(\n      referencedImageIds,\n      [...segmentationImageIdsToUse].reverse()\n    );\n  }\n}\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the locked status for a segment index in a segmentation\n * @param segmentationId - The id of the segmentation that the segment\n * belongs to.\n * @param segmentIndex - The index of the segment\n * @returns A boolean value indicating whether the segment is locked or not.\n */\nfunction isSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number\n): boolean {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return segmentsLocked.has(segmentIndex);\n}\n\n/**\n * Set the locked status of a segment index in a segmentation\n * @param segmentationId - The id of the segmentation whose segment\n * index is being modified.\n * @param segmentIndex - The index of the segment to lock/unlock.\n */\nfunction setSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number,\n  locked = true\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n\n  if (locked) {\n    segmentsLocked.add(segmentIndex);\n  } else {\n    segmentsLocked.delete(segmentIndex);\n  }\n\n  triggerSegmentationModified(segmentationId);\n}\n\n/**\n * Get the locked segments for a segmentation\n * @param segmentationId - The id of the segmentation to get locked\n * segments for.\n * @returns An array of locked segment indices.\n */\nfunction getLockedSegments(segmentationId: string): number[] | [] {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return Array.from(segmentsLocked);\n}\n\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\n * If no colorLUT is provided, a new color LUT is generated.\n *\n * @param colorLUTIndex - the index of the colorLUT in the state\n * @param colorLUT - An array of The colorLUT to set.\n * @returns\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex: number): void {\n  if (!colorLUT) {\n    throw new Error('addColorLUT: colorLUT is required');\n  }\n\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n    console.warn(\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\n    );\n    colorLUT.unshift([0, 0, 0, 0]);\n  }\n\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\n\n/**\n * It sets the toolGroup's segmentationRepresentation to use the provided\n * colorLUT at the given colorLUTIndex.\n * @param toolGroupId - the id of the toolGroup that renders the representation\n * @param segmentationRepresentationUID - the representationUID for the segmentation\n * @param colorLUTIndex - the index of the colorLUT to use\n */\nfunction setColorLUT(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  colorLUTIndex: number\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    throw new Error(\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\n    );\n  }\n\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n    throw new Error(\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\n    );\n  }\n\n  segRepresentation.colorLUTIndex = colorLUTIndex;\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\n * color for that segment. It can be used for segmentation tools that need to\n * display the color of their annotation.\n *\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment in the segmentation\n * @returns A color.\n */\nfunction getColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): Types.Color {\n  const segmentationRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segmentationRepresentation) {\n    throw new Error(\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\n    );\n  }\n\n  const { colorLUTIndex } = segmentationRepresentation;\n\n  // get colorLUT\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  let colorValue = colorLUT[segmentIndex];\n  if (!colorValue) {\n    if (typeof segmentIndex !== 'number') {\n      throw new Error(`Can't create colour for LUT index ${segmentIndex}`);\n    }\n    colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n  }\n  return colorValue;\n}\n\nfunction setColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  color: Types.Color\n): void {\n  // Get the reference to the color in the colorLUT.\n  const colorReference = getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n\n  // Modify the values by reference\n  for (let i = 0; i < color.length; i++) {\n    colorReference[i] = color[i];\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  getColorForSegmentIndex,\n  addColorLUT,\n  setColorLUT,\n  setColorForSegmentIndex,\n};\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport addRepresentationData from '../addRepresentationData';\nimport { triggerSegmentationModified } from '../triggerSegmentationEvents';\nimport { debounce } from '../../../utilities';\nimport { registerPolySegWorker } from './registerPolySegWorker';\n\nconst computedRepresentations = new Map<\n  string,\n  SegmentationRepresentations[]\n>();\n\n/**\n * Computes a representation using the provided computation function, adds the computed data,\n * subscribes to segmentation changes, and triggers segmentation modification.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param representationType - The type of the segmentation representation.\n * @param computeFunction - The function that computes the representation data.\n * @param options - Additional options for computing the representation.\n * @returns - A promise that resolves with the computed representation data.\n */\nasync function computeAndAddRepresentation<T>(\n  segmentationId: string,\n  representationType: SegmentationRepresentations,\n  computeFunction: () => Promise<T>,\n  updateFunction?: () => void\n): Promise<T> {\n  // register the worker if it hasn't been registered yet\n  registerPolySegWorker();\n\n  // Compute the specific representation data\n  const data = await computeFunction();\n\n  // Add the computed data to the system\n  addRepresentationData({\n    segmentationId,\n    type: representationType,\n    data,\n  });\n\n  // Update internal structures and possibly UI components\n  if (!computedRepresentations.has(segmentationId)) {\n    computedRepresentations.set(segmentationId, []);\n  }\n\n  const representations = computedRepresentations.get(segmentationId);\n  if (!representations.includes(representationType)) {\n    representations.push(representationType);\n  }\n\n  // Subscribe to any changes in the segmentation data for real-time updates\n  subscribeToSegmentationChanges(updateFunction);\n\n  // Notify other system parts that segmentation data has been modified\n  triggerSegmentationModified(segmentationId);\n\n  return data;\n}\n\n/**\n * Subscribes to segmentation changes by adding an event listener for the SEGMENTATION_DATA_MODIFIED event.\n * If there is an existing listener, it will be unsubscribed before adding the new listener.\n */\nfunction subscribeToSegmentationChanges(updateFunction) {\n  const debouncedUpdateFunction = (event) => {\n    _debouncedSegmentationModified(event, updateFunction);\n  };\n\n  updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n\n  eventTarget.removeEventListener(\n    Events.SEGMENTATION_DATA_MODIFIED,\n    updateFunction._debouncedUpdateFunction\n  );\n\n  eventTarget.addEventListener(\n    Events.SEGMENTATION_DATA_MODIFIED,\n    updateFunction._debouncedUpdateFunction\n  );\n}\n\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n  const segmentationId = event.detail.segmentationId;\n  const representations = computedRepresentations.get(segmentationId);\n  if (!representations || !representations.length) {\n    return;\n  }\n\n  updateFunction(segmentationId);\n\n  if (representations.length) {\n    triggerSegmentationModified(segmentationId);\n  }\n}, 300);\n\nexport { computeAndAddRepresentation };\n","import { Enums, Types, eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getWebWorkerManager } from '@cornerstonejs/core';\nimport { ContourSegmentationData } from '../../../../types';\nimport { getAnnotation } from '../../../annotation/annotationState';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_SURFACE,\n  });\n};\n\n/**\n * Converts a contour representation to a surface representation.\n *\n * @param contourRepresentationData - The contour segmentation data.\n * @param segmentIndex - The index of the segment to convert.\n * @returns A promise that resolves to the surface data.\n */\nexport async function convertContourToSurface(\n  contourRepresentationData: ContourSegmentationData,\n  segmentIndex: number\n): Promise<Types.SurfaceData> {\n  const { annotationUIDsMap } = contourRepresentationData;\n\n  // loop over all annotations in the segment and flatten their polylines\n  const polylines = [];\n  const numPointsArray = [];\n  const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n\n  for (const annotationUID of annotationUIDs) {\n    const annotation = getAnnotation(annotationUID);\n    const { polyline } = annotation.data.contour;\n    numPointsArray.push(polyline.length);\n    polyline.forEach((polyline) => polylines.push(...polyline));\n  }\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const results = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToSurface',\n    {\n      polylines,\n      numPointsArray,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return results;\n}\n","import { Enums, Types, geometryLoader } from '@cornerstonejs/core';\nimport { getColorForSegmentIndex } from '../../config/segmentationColor';\nimport {\n  findSegmentationRepresentationByUID,\n  getSegmentation,\n} from '../../segmentationState';\nimport { RawSurfacesData } from './surfaceComputationStrategies';\nimport { PolySegConversionOptions } from '../../../../types';\n\n/**\n * Creates and caches surfaces from raw surface data.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param rawSurfacesData - The raw surface data.\n * @param options - Additional options for creating and caching surfaces.\n * @param options.segmentIndices - An array of segment indices.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns An object containing the IDs of the created surfaces.\n */\nexport async function createAndCacheSurfacesFromRaw(\n  segmentationId: string,\n  rawSurfacesData: RawSurfacesData,\n  options: PolySegConversionOptions = {}\n) {\n  // Initialize segmentationRepresentation and toolGroupId if a representation UID is provided\n  let segmentationRepresentation: any, toolGroupId: any;\n  if (options.segmentationRepresentationUID) {\n    ({ segmentationRepresentation, toolGroupId } =\n      findSegmentationRepresentationByUID(\n        options.segmentationRepresentationUID\n      ));\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n\n  const geometryIds = new Map<number, string>();\n\n  // Loop through raw surfaces data and create surfaces\n  const promises = Object.keys(rawSurfacesData).map(async (index: string) => {\n    const rawSurfaceData = rawSurfacesData[index];\n    const segmentIndex = rawSurfaceData.segmentIndex;\n\n    // Get the color either from the segmentation representation or randomly generated\n    const color = segmentationRepresentation;\n    getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID,\n      segmentIndex\n    ).slice(0, 3);\n\n    if (!color) {\n      throw new Error(\n        'No color found for segment index, unable to create surface'\n      );\n    }\n\n    const closedSurface = {\n      id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,\n      color,\n      frameOfReferenceUID: 'test-frameOfReferenceUID',\n      data: {\n        points: rawSurfaceData.data.points,\n        polys: rawSurfaceData.data.polys,\n      },\n    };\n\n    const geometryId = closedSurface.id;\n    geometryIds.set(segmentIndex, geometryId);\n\n    return geometryLoader.createAndCacheGeometry(geometryId, {\n      type: Enums.GeometryType.SURFACE,\n      geometryData: closedSurface as Types.PublicSurfaceData,\n    });\n  });\n\n  await Promise.all(promises);\n\n  return {\n    geometryIds,\n  };\n}\n","import {\n  Types,\n  cache,\n  eventTarget,\n  triggerEvent,\n  Enums,\n} from '@cornerstonejs/core';\nimport { getWebWorkerManager } from '@cornerstonejs/core';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport { computeVolumeSegmentationFromStack } from '../../convertStackToVolumeSegmentation';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_LABELMAP_TO_SURFACE,\n  });\n};\n\n/**\n * Converts a labelmap representation to a surface representation.\n *\n * @param labelmapRepresentationData - The labelmap segmentation data.\n * @param segmentIndex - The index of the segment to convert.\n * @param isVolume - Optional flag indicating whether the labelmap is a volume or a stack. Default is true.\n * @returns A promise that resolves to the surface data.\n */\nexport async function convertLabelmapToSurface(\n  labelmapRepresentationData: LabelmapSegmentationData,\n  segmentIndex: number,\n  isVolume = true\n): Promise<Types.SurfaceData> {\n  let volumeId;\n  if (isVolume) {\n    volumeId = (labelmapRepresentationData as LabelmapSegmentationDataVolume)\n      .volumeId;\n  } else {\n    const { imageIdReferenceMap } =\n      labelmapRepresentationData as LabelmapSegmentationDataStack;\n    ({ volumeId } = await computeVolumeSegmentationFromStack({\n      imageIdReferenceMap,\n    }));\n  }\n\n  const volume = cache.getVolume(volumeId);\n\n  const scalarData = volume.getScalarData();\n  const { dimensions, spacing, origin, direction } = volume;\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const results = await workerManager.executeTask(\n    'polySeg',\n    'convertLabelmapToSurface',\n    {\n      scalarData,\n      dimensions,\n      spacing,\n      origin,\n      direction,\n      segmentIndex,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return results;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  ContourSegmentationData,\n  PolySegConversionOptions,\n} from '../../../../types';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport { getSegmentation } from '../../segmentationState';\nimport { convertContourToSurface } from './convertContourToSurface';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { convertLabelmapToSurface } from './convertLabelmapToSurface';\n\nexport type RawSurfacesData = {\n  segmentIndex: number;\n  data: Types.SurfaceData;\n}[];\n\n/**\n * Computes surface data for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Additional options for surface computation.\n * @returns A promise that resolves to the computed surface data.\n * @throws An error if there is no surface data available for the segmentation.\n */\nexport async function computeSurfaceData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawSurfacesData: RawSurfacesData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.CONTOUR) {\n      rawSurfacesData = await computeSurfaceFromContourSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.LABELMAP as LabelmapSegmentationData) {\n      // convert volume labelmap to surface\n      rawSurfacesData = await computeSurfaceFromLabelmapSegmentation(\n        segmentation.segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawSurfacesData) {\n    throw new Error(\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\n    );\n  }\n\n  const surfacesData = await createAndCacheSurfacesFromRaw(\n    segmentationId,\n    rawSurfacesData,\n    options\n  );\n\n  return surfacesData;\n}\n\nasync function computeSurfaceFromLabelmapSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<RawSurfacesData> {\n  // Todo: validate valid labelmap representation\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation?.representationData?.LABELMAP) {\n    console.warn('Only support surface update from labelmaps');\n    return;\n  }\n\n  const isVolume = isVolumeSegmentation(\n    segmentation.representationData.LABELMAP\n  );\n\n  const labelmapRepresentationData = segmentation.representationData.LABELMAP;\n\n  const segmentIndices =\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n\n  const promises = segmentIndices.map((index) => {\n    const surface = convertLabelmapToSurface(\n      labelmapRepresentationData as\n        | LabelmapSegmentationDataVolume\n        | LabelmapSegmentationDataStack,\n      index,\n      isVolume\n    );\n\n    return surface;\n  });\n\n  const surfaces = await Promise.allSettled(promises);\n  const errors = surfaces.filter((p) => p.status === 'rejected');\n\n  if (errors.length > 0) {\n    console.error(errors);\n    throw new Error('Failed to convert labelmap to surface');\n  }\n\n  const rawSurfacesData = surfaces\n    .map((surface, index) => {\n      if (surface.status === 'fulfilled') {\n        return { segmentIndex: segmentIndices[index], data: surface.value };\n      }\n    })\n    .filter(Boolean);\n\n  return rawSurfacesData;\n}\n\n/**\n * Computes the surface from contour segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for surface computation.\n * @returns A promise that resolves to the raw surfaces data.\n */\nasync function computeSurfaceFromContourSegmentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n): Promise<RawSurfacesData> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const contourRepresentationData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices =\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n\n  const promises = segmentIndices.map(async (index) => {\n    const surface = await convertContourToSurface(\n      contourRepresentationData as ContourSegmentationData,\n      index\n    );\n\n    return { segmentIndex: index, data: surface };\n  });\n\n  const surfaces = await Promise.all(promises);\n\n  return surfaces;\n}\n\nexport {\n  computeSurfaceFromContourSegmentation,\n  computeSurfaceFromLabelmapSegmentation,\n};\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeSurfaceData } from './surfaceComputationStrategies';\nimport { updateSurfaceData } from './updateSurfaceData';\n\n/**\n * Computes and adds a surface representation for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Additional options for computing the surface representation.\n * @param options.segmentIndices - The indices of the segments to compute the surface for.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation to compute the surface for.\n *\n * @returns A promise that resolves when the surface representation is computed and added.\n */\nexport function computeAndAddSurfaceRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Surface,\n    () => computeSurfaceData(segmentationId, options),\n    () => updateSurfaceData(segmentationId)\n  );\n}\n","import { Types, cache } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport {\n  getSegmentation,\n  getSegmentationRepresentations,\n  getToolGroupIdsWithSegmentation,\n} from '../../segmentationState';\nimport { triggerSegmentationModified } from '../../triggerSegmentationEvents';\nimport { ToolGroupSpecificRepresentations } from '../../../../types/SegmentationStateTypes';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { computeSurfaceFromLabelmapSegmentation } from './surfaceComputationStrategies';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\n\nexport async function updateSurfaceData(segmentationId) {\n  const surfacesObj = await computeSurfaceFromLabelmapSegmentation(\n    segmentationId\n  );\n\n  if (!surfacesObj) {\n    return;\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  if (!indices.length) {\n    // means all segments were removed so we need to empty out\n    // the geometry data\n    const geometryIds = segmentation.representationData.SURFACE.geometryIds;\n    geometryIds.forEach((geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints([]);\n      surface.setPolys([]);\n    });\n\n    triggerSegmentationModified(segmentationId);\n\n    return;\n  }\n\n  const promises = surfacesObj.map(({ data, segmentIndex }) => {\n    const geometryId = `segmentation_${segmentationId}_surface_${segmentIndex}`;\n\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      // means it is a new segment getting added while we were\n      // listening to the segmentation data modified event\n      const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n      return toolGroupIds.map((toolGroupId) => {\n        const segmentationRepresentations = getSegmentationRepresentations(\n          toolGroupId\n        ) as ToolGroupSpecificRepresentations;\n\n        return segmentationRepresentations.map((segmentationRepresentation) => {\n          if (\n            segmentationRepresentation.type !==\n            SegmentationRepresentations.Surface\n          ) {\n            return;\n          }\n          segmentation.representationData.SURFACE.geometryIds.set(\n            segmentIndex,\n            geometryId\n          );\n\n          return createAndCacheSurfacesFromRaw(\n            segmentationId,\n            [{ segmentIndex, data }],\n            {\n              segmentationRepresentationUID:\n                segmentationRepresentation.segmentationRepresentationUID,\n            }\n          );\n        });\n      });\n    } else if (indices.includes(segmentIndex)) {\n      // if the geometry already exists and the segmentIndex is\n      // still present, update the geometry data\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints(data.points);\n      surface.setPolys(data.polys);\n    } else {\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints([]);\n      surface.setPolys([]);\n    }\n  });\n\n  await Promise.all(promises);\n\n  triggerSegmentationModified(segmentationId);\n}\n","import { vec3 } from 'gl-matrix';\nimport {\n  Types,\n  cache,\n  utilities,\n  getWebWorkerManager,\n  volumeLoader,\n  imageLoader,\n  metaData,\n  Enums,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport {\n  Annotation,\n  ContourAnnotation,\n  ContourSegmentationData,\n  PolySegConversionOptions,\n} from '../../../../types';\nimport { getAnnotation } from '../../..';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_LABELMAP,\n  });\n};\n\nexport async function convertContourToVolumeLabelmap(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  const { viewport } = options;\n\n  const imageIds = utilities.getViewportImageIds(viewport);\n\n  if (!imageIds) {\n    throw new Error(\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\n    );\n  }\n\n  const segmentationVolumeId = utilities.uuidv4();\n\n  const volumeProps = utilities.generateVolumePropsFromImageIds(\n    imageIds,\n    segmentationVolumeId\n  );\n\n  const { metadata, dimensions, origin, direction, spacing, scalarData } =\n    volumeProps;\n\n  const segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\n    {\n      dimensions,\n      origin,\n      direction,\n      spacing,\n      metadata,\n      imageIds: imageIds.map((imageId) => `generated://${imageId}`),\n      referencedImageIds: imageIds,\n    },\n    segmentationVolumeId\n  );\n\n  const { segmentIndices, annotationUIDsInSegmentMap } =\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToVolumeLabelmap',\n    {\n      segmentIndices,\n      dimensions,\n      scalarData,\n      origin,\n      direction,\n      spacing,\n      annotationUIDsInSegmentMap,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  segmentationVolume.imageData\n    .getPointData()\n    .getScalars()\n    .setData(newScalarData);\n  segmentationVolume.imageData.modified();\n\n  // update the scalarData in the volume as well\n  segmentationVolume.modified();\n\n  return {\n    volumeId: segmentationVolume.volumeId,\n  };\n}\n\nexport async function convertContourToStackLabelmap(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  if (!options.viewport) {\n    throw new Error(\n      'No viewport provided, labelmap computation from contour requires viewports'\n    );\n  }\n\n  const viewport = options.viewport as Types.IStackViewport;\n\n  const imageIds = viewport.getImageIds();\n\n  if (!imageIds) {\n    throw new Error(\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\n    );\n  }\n\n  // check if the imageIds are already cached\n  imageIds.forEach((imageId) => {\n    if (!cache.getImageLoadObject(imageId)) {\n      throw new Error(\n        'ImageIds must be cached before converting contour to labelmap'\n      );\n    }\n  });\n\n  // create\n  const { imageIds: segmentationImageIds } =\n    await imageLoader.createAndCacheDerivedSegmentationImages(imageIds);\n\n  const { segmentIndices, annotationUIDsInSegmentMap } =\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\n\n  // information for the referenced to the segmentation image\n  // Define constant to hold segmentation information\n  const segmentationsInfo = new Map();\n\n  // Loop through each segmentation image ID\n  segmentationImageIds.forEach((segImageId, index) => {\n    // Fetch the image from cache\n    const segImage = cache.getImage(segImageId);\n\n    // Fetch metadata for the image\n    const imagePlaneModule = metaData.get(\n      Enums.MetadataModules.IMAGE_PLANE,\n      segImageId\n    );\n\n    // Extract properties from image metadata\n    let {\n      columnCosines,\n      rowCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n      imagePositionPatient,\n    } = imagePlaneModule;\n\n    // Set defaults if necessary\n    columnCosines = columnCosines ?? [0, 1, 0];\n    rowCosines = rowCosines ?? [1, 0, 0];\n    rowPixelSpacing = rowPixelSpacing ?? 1;\n    columnPixelSpacing = columnPixelSpacing ?? 1;\n    imagePositionPatient = imagePositionPatient ?? [0, 0, 0];\n\n    // Create vector from row and column cosines\n    const rowCosineVec = vec3.fromValues(\n      rowCosines[0],\n      rowCosines[1],\n      rowCosines[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      columnCosines[0],\n      columnCosines[1],\n      columnCosines[2]\n    );\n\n    // Calculate scan axis normal\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n\n    // Define direction and spacing\n    const direction = [...rowCosineVec, ...colCosineVec, ...scanAxisNormal];\n    const spacing = [rowPixelSpacing, columnPixelSpacing, 1];\n\n    // Set origin\n    const origin = imagePositionPatient;\n\n    // Store segmentation information\n    segmentationsInfo.set(imageIds[index], {\n      direction,\n      spacing,\n      origin,\n      scalarData: segImage.getPixelData(),\n      imageId: segImageId,\n      dimensions: [segImage.width, segImage.height, 1],\n    });\n  });\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newSegmentationsScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToStackLabelmap',\n    {\n      segmentationsInfo,\n      annotationUIDsInSegmentMap,\n      segmentIndices,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  const imageIdReferenceMap = new Map();\n  newSegmentationsScalarData.forEach(({ scalarData }, referencedImageId) => {\n    const segmentationInfo = segmentationsInfo.get(referencedImageId);\n    const { imageId: segImageId } = segmentationInfo;\n\n    const segImage = cache.getImage(segImageId);\n    segImage.getPixelData().set(scalarData);\n    segImage.imageFrame?.pixelData?.set(scalarData);\n\n    imageIdReferenceMap.set(referencedImageId, segImageId);\n  });\n\n  return {\n    imageIdReferenceMap,\n  };\n}\n\nfunction _getAnnotationMapFromSegmentation(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  const annotationMap = contourRepresentationData.annotationUIDsMap;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : Array.from(annotationMap.keys());\n\n  const annotationUIDsInSegmentMap = new Map<number, any>();\n  segmentIndices.forEach((index) => {\n    const annotationUIDsInSegment = annotationMap.get(index);\n\n    // Todo: there is a bug right now where the annotationUIDsInSegment has both\n    // children and parent annotations, so we need to filter out the parent\n    // annotations only\n\n    let uids = Array.from(annotationUIDsInSegment);\n\n    uids = uids.filter(\n      (uid) => !(getAnnotation(uid) as Annotation).parentAnnotationUID\n    );\n\n    const annotations = uids.map((uid) => {\n      const annotation = getAnnotation(uid) as ContourAnnotation;\n      const hasChildAnnotations = annotation.childAnnotationUIDs?.length;\n\n      return {\n        polyline: annotation.data.contour.polyline,\n        referencedImageId: annotation.metadata.referencedImageId,\n        holesPolyline:\n          hasChildAnnotations &&\n          annotation.childAnnotationUIDs.map((childUID) => {\n            const childAnnotation = getAnnotation(\n              childUID\n            ) as ContourAnnotation;\n            return childAnnotation.data.contour.polyline;\n          }),\n      };\n    });\n\n    annotationUIDsInSegmentMap.set(index, annotations);\n  });\n\n  return { segmentIndices, annotationUIDsInSegmentMap };\n}\n","import {\n  Enums,\n  Types,\n  cache,\n  eventTarget,\n  getWebWorkerManager,\n  triggerEvent,\n} from '@cornerstonejs/core';\nimport { SurfaceSegmentationData } from '../../../../types/SurfaceTypes';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_SURFACE_TO_LABELMAP,\n  });\n};\n\nexport async function convertSurfaceToVolumeLabelmap(\n  surfaceRepresentationData: SurfaceSegmentationData,\n  segmentationVolume: Types.IImageVolume\n) {\n  const { geometryIds } = surfaceRepresentationData;\n  if (!geometryIds?.size) {\n    throw new Error('No geometry IDs found for surface representation');\n  }\n\n  const segmentsInfo = new Map() as Map<\n    number,\n    {\n      points: number[];\n      polys: number[];\n    }\n  >;\n\n  geometryIds.forEach((geometryId, segmentIndex) => {\n    const geometry = cache.getGeometry(geometryId);\n    const geometryData = geometry.data as Types.ISurface;\n    const points = geometryData.getPoints();\n    const polys = geometryData.getPolys();\n\n    segmentsInfo.set(segmentIndex, {\n      points,\n      polys,\n    });\n  });\n\n  const { dimensions, direction, origin, spacing } = segmentationVolume;\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertSurfacesToVolumeLabelmap',\n    {\n      segmentsInfo,\n      dimensions,\n      spacing,\n      direction,\n      origin,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  segmentationVolume.imageData\n    .getPointData()\n    .getScalars()\n    .setData(newScalarData);\n  segmentationVolume.imageData.modified();\n\n  // update the scalarData in the volume as well\n  segmentationVolume.modified();\n\n  return {\n    volumeId: segmentationVolume.volumeId,\n  };\n}\n\nexport async function convertSurfaceToStackLabelmap() {\n  // TODO\n}\n","import { VolumeViewport, volumeLoader, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport { getSegmentation } from '../../segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  convertContourToStackLabelmap,\n  convertContourToVolumeLabelmap,\n} from './convertContourToLabelmap';\nimport { convertSurfaceToVolumeLabelmap } from './convertSurfaceToLabelmap';\nimport { computeStackSegmentationFromVolume } from '../../convertVolumeToStackSegmentation';\nimport { PolySegConversionOptions } from '../../../../types';\n\nexport type RawLabelmapData =\n  | LabelmapSegmentationDataVolume\n  | LabelmapSegmentationDataStack;\n\nexport async function computeLabelmapData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawLabelmapData: RawLabelmapData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.CONTOUR) {\n      rawLabelmapData = await computeLabelmapFromContourSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.SURFACE) {\n      rawLabelmapData = await computeLabelmapFromSurfaceSegmentation(\n        segmentation.segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawLabelmapData) {\n    throw new Error(\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\n    );\n  }\n\n  return rawLabelmapData;\n}\n\nasync function computeLabelmapFromContourSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\n\n  if (isVolume && !options.viewport) {\n    // Todo: we don't have support for volume viewport without providing the\n    // viewport, since we need to get the referenced volumeId from the viewport\n    // but we can alternatively provide the volumeId directly, or even better\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\n    // and then we can create the volume from that\n    throw new Error(\n      'Cannot compute labelmap from contour segmentation without providing the viewport'\n    );\n  }\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData.CONTOUR;\n\n  const convertFunction = isVolume\n    ? convertContourToVolumeLabelmap\n    : convertContourToStackLabelmap;\n\n  const result = await convertFunction(representationData, {\n    segmentIndices,\n    segmentationRepresentationUID: options.segmentationRepresentationUID,\n    viewport: options.viewport,\n  });\n\n  return result;\n}\n\nasync function computeLabelmapFromSurfaceSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentation = getSegmentation(segmentationId);\n\n  const segmentsGeometryIds = new Map() as Map<number, string>;\n  const representationData = segmentation.representationData.SURFACE;\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\n    if (segmentIndices.includes(segmentIndex)) {\n      segmentsGeometryIds.set(segmentIndex, geometryId);\n    }\n  });\n\n  if (isVolume && !options.viewport) {\n    // Todo: we don't have support for volume viewport without providing the\n    // viewport, since we need to get the referenced volumeId from the viewport\n    // but we can alternatively provide the volumeId directly, or even better\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\n    // and then we can create the volume from that\n    throw new Error(\n      'Cannot compute labelmap from surface segmentation without providing the viewport'\n    );\n  }\n\n  let segmentationVolume;\n  if (isVolume) {\n    const defaultActor = options.viewport.getDefaultActor();\n    const { uid: volumeId } = defaultActor;\n    segmentationVolume =\n      await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId);\n  } else {\n    // for stack we basically need to create a volume from the stack\n    // imageIds and then create a segmentation volume from that and finally\n    // convert the surface to a labelmap and later on convert the labelmap\n    // to a stack labelmap\n    const imageIds = (options.viewport as Types.IStackViewport).getImageIds();\n    const volumeId = 'generatedSegmentationVolumeId';\n    const volumeProps = utilities.generateVolumePropsFromImageIds(\n      imageIds,\n      volumeId\n    );\n\n    // we don't need the imageIds for the viewport (e.g., CT), but rather\n    // want to use the imageIds as a reference\n    delete volumeProps.imageIds;\n\n    segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\n      {\n        ...volumeProps,\n        scalarData: volumeProps.scalarData as Types.PixelDataTypedArray,\n        referencedImageIds: imageIds,\n      },\n      volumeId\n    );\n  }\n\n  const result = await convertSurfaceToVolumeLabelmap(\n    { geometryIds: segmentsGeometryIds },\n    segmentationVolume\n  );\n\n  if (isVolume) {\n    return result;\n  }\n\n  // we need to convert the volume labelmap to a stack labelmap\n  const stackData = (await computeStackSegmentationFromVolume({\n    volumeId: segmentationVolume.volumeId,\n  })) as LabelmapSegmentationDataStack;\n\n  return stackData;\n}\n\nexport { computeLabelmapFromContourSegmentation };\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeLabelmapData } from './labelmapComputationStrategies';\nimport { PolySegConversionOptions } from '../../../../types';\n\n/**\n * Computes and adds the labelmap representation for a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for computing the labelmap representation.\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns A promise that resolves when the labelmap representation is computed and added.\n */\nexport function computeAndAddLabelmapRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Labelmap,\n    () => computeLabelmapData(segmentationId, options),\n    () => undefined\n  );\n}\n","import { PolyDataClipCacheType } from '../../../helpers/clipAndCacheSurfacesForViewport';\nimport { RawContourData } from '../contourComputationStrategies';\n\n/**\n * Extracts contour data from the given polyDataCache.\n * @param polyDataCache - The polyData cache containing intersection information.\n * @param segmentIndexMap - Optional map for mapping surface IDs to segment indices.\n * @returns A map of segment indices to an array of contour results.\n */\nexport function extractContourData(\n  polyDataCache: PolyDataClipCacheType,\n  segmentIndexMap?: Map<string, number>\n) {\n  const rawResults = new Map() as RawContourData;\n\n  for (const [cacheId, intersectionInfo] of polyDataCache) {\n    // Todo; fix this\n    const surfaceId = cacheId.split('_')[1];\n\n    for (const [_, result] of intersectionInfo) {\n      if (!result) {\n        continue;\n      }\n      const segmentIndex = Number(surfaceId) || segmentIndexMap?.get(surfaceId);\n\n      if (!segmentIndex) {\n        continue;\n      }\n\n      if (!rawResults.has(segmentIndex)) {\n        rawResults.set(segmentIndex, []);\n      }\n\n      rawResults.get(segmentIndex).push(result);\n    }\n  }\n  return rawResults;\n}\n","import { PlanarFreehandContourSegmentationTool } from '../../../../../tools';\nimport { addAnnotation } from '../../../../annotation/annotationState';\nimport { RawContourData } from '../contourComputationStrategies';\nimport { utilities, type Types } from '@cornerstonejs/core';\n\n/**\n * Creates and adds contour segmentations from a clipped surface.\n *\n * @param rawContourData - The raw contour data.\n * @param viewport - The viewport.\n * @param segmentationId - The segmentation ID.\n */\nexport function createAndAddContourSegmentationsFromClippedSurfaces(\n  rawContourData: RawContourData,\n  viewport: Types.IViewport,\n  segmentationId: string\n) {\n  const annotationUIDsMap = new Map<number, Set<string>>();\n\n  for (const [segmentIndex, contoursData] of rawContourData) {\n    for (const contourData of contoursData) {\n      const { points } = contourData;\n\n      const { lineSegments, linesNumberOfPoints } =\n        _extractLineSegments(contourData);\n\n      // There may be a few lines as the surface might not be closed and could have holes in it.\n      // Currently, we simply render the generated contour as empty fill to indicate\n      // the presence of holes. However, filling the proper area with\n      //  fillAlpha requires further work.\n      for (let i = 0; i < lineSegments.length; i++) {\n        const line = lineSegments[i];\n        const polyline = [];\n\n        for (let j = 0; j < linesNumberOfPoints[i]; j++) {\n          const pointIndex = line[j];\n          polyline.push([\n            points[3 * pointIndex],\n            points[3 * pointIndex + 1],\n            points[3 * pointIndex + 2],\n          ]);\n        }\n\n        if (polyline.length < 3) {\n          continue;\n        }\n\n        const contourSegmentationAnnotation = {\n          annotationUID: utilities.uuidv4(),\n          data: {\n            contour: {\n              closed: true,\n              polyline,\n            },\n            segmentation: {\n              segmentationId,\n              segmentIndex,\n            },\n            handles: {},\n          },\n          handles: {},\n          highlighted: false,\n          autoGenerated: false,\n          invalidated: false,\n          isLocked: false,\n          isVisible: true,\n          metadata: {\n            toolName: PlanarFreehandContourSegmentationTool.toolName,\n            ...viewport.getViewReference(),\n          },\n        };\n\n        addAnnotation(contourSegmentationAnnotation, viewport.element);\n\n        const currentSet = annotationUIDsMap.get(segmentIndex) || new Set();\n        currentSet.add(contourSegmentationAnnotation.annotationUID);\n        annotationUIDsMap.set(segmentIndex, currentSet);\n      }\n    }\n  }\n\n  return annotationUIDsMap;\n}\n\nconst _extractLineSegments = (contourData) => {\n  const { numberOfCells, lines } = contourData;\n\n  const lineSegments = [];\n  const linesNumberOfPoints = [];\n\n  for (let i = 0; i < lines.length; ) {\n    const pointsInLine = lines[i];\n    linesNumberOfPoints.push(pointsInLine);\n    lineSegments.push(lines.slice(i + 1, i + pointsInLine + 1));\n    i += pointsInLine + 1;\n\n    if (lineSegments.length === numberOfCells) {\n      break;\n    }\n  }\n\n  return { lineSegments, linesNumberOfPoints };\n};\n","import { cache } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport {\n  getSegmentation,\n  setSegmentationRepresentationSpecificConfig,\n} from '../../segmentationState';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeSurfaceFromLabelmapSegmentation } from '../Surface/surfaceComputationStrategies';\nimport {\n  SurfaceClipResult,\n  clipAndCacheSurfacesForViewport,\n} from '../../helpers/clipAndCacheSurfacesForViewport';\nimport { extractContourData } from './utils/extractContourData';\nimport { createAndAddContourSegmentationsFromClippedSurfaces } from './utils/createAndAddContourSegmentationsFromClippedSurfaces';\nimport { getToolGroupForViewport } from '../../../../store/ToolGroupManager';\n\n// the map between segment index and the intersection points and lines\nexport type RawContourData = Map<number, SurfaceClipResult[]>;\n\n/**\n * Computes contour data for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for the computation.\n * @returns An object containing the annotation UIDs map.\n * @throws Error if there is not enough data to convert to contour.\n */\nexport async function computeContourData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawContourData: RawContourData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.SURFACE) {\n      rawContourData = await computeContourFromSurfaceSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.LABELMAP) {\n      rawContourData = await computeContourFromLabelmapSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawContourData) {\n    throw new Error(\n      'Not enough data to convert to contour, currently only support converting volume labelmap to contour if available'\n    );\n  }\n\n  const { viewport, segmentationRepresentationUID } = options;\n\n  // create the new annotations and add them to the segmentation state representation\n  // data for the contour representation\n  const annotationUIDsMap = createAndAddContourSegmentationsFromClippedSurfaces(\n    rawContourData,\n    viewport,\n    segmentationId\n  );\n\n  // make the segmentation configuration fillAlpha 0 since\n  // we don't have proper hole support right now\n  // Todo: add hole support\n  const toolGroupId = getToolGroupForViewport(viewport.id)?.id;\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    {\n      CONTOUR: {\n        fillAlpha: 0,\n      },\n    }\n  );\n\n  return {\n    annotationUIDsMap,\n  };\n}\n\n/**\n * Computes the contour from a labelmap segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for the contour computation.\n * @returns The raw contour data.\n */\nasync function computeContourFromLabelmapSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n) {\n  if (!options.viewport) {\n    throw new Error('Viewport is required to compute contour from labelmap');\n  }\n\n  const results = await computeSurfaceFromLabelmapSegmentation(\n    segmentationId,\n    options\n  );\n\n  if (!results?.length) {\n    console.error('Failed to convert labelmap to surface or labelmap is empty');\n    return;\n  }\n\n  const { viewport, segmentationRepresentationUID } = options;\n\n  const pointsAndPolys = results.map((surface) => {\n    return {\n      id: surface.segmentIndex.toString(),\n      points: surface.data.points,\n      polys: surface.data.polys,\n      segmentIndex: surface.segmentIndex,\n    };\n  });\n\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\n    pointsAndPolys,\n    viewport as Types.IVolumeViewport,\n    segmentationRepresentationUID\n  );\n\n  const rawResults = extractContourData(polyDataCache);\n\n  return rawResults;\n}\n\n/**\n * Computes the contour from a surface segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for the contour computation.\n * @returns A promise that resolves to the raw contour data.\n * @throws An error if the viewport is not provided.\n */\nasync function computeContourFromSurfaceSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<RawContourData> {\n  if (!options.viewport) {\n    throw new Error('Viewport is required to compute contour from surface');\n  }\n  const { viewport, segmentationRepresentationUID } = options;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentIndexToSurfaceId = new Map() as Map<number, string>;\n  const surfaceIdToSegmentIndex = new Map() as Map<string, number>;\n\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData.SURFACE;\n\n  const surfacesInfo = [];\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\n    if (segmentIndices.includes(segmentIndex)) {\n      segmentIndexToSurfaceId.set(segmentIndex, geometryId);\n      const surface = cache.getGeometry(geometryId)?.data as Types.ISurface;\n      if (surface) {\n        surfacesInfo.push({\n          id: geometryId,\n          points: surface.getPoints(),\n          polys: surface.getPolys(),\n        });\n      }\n    }\n  });\n\n  segmentIndexToSurfaceId.forEach((surfaceId, segmentIndex) => {\n    surfaceIdToSegmentIndex.set(surfaceId, segmentIndex);\n  });\n\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\n    surfacesInfo,\n    viewport as Types.IVolumeViewport,\n    segmentationRepresentationUID\n  );\n\n  const rawResults = extractContourData(polyDataCache, surfaceIdToSegmentIndex);\n\n  return rawResults;\n}\n\nexport { computeContourFromLabelmapSegmentation };\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeContourData } from './contourComputationStrategies';\n/**\n * Computes and adds the contour representation for a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for computing the labelmap representation.\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns A promise that resolves when the labelmap representation is computed and added.\n */\nexport function computeAndAddContourRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Contour,\n    () => computeContourData(segmentationId, options),\n    () => undefined\n  );\n}\n","import { SegmentationRepresentations } from '../../../enums';\nimport { validateLabelmap } from '../../../tools/displayTools/Labelmap';\nimport { SegmentationRepresentationData } from '../../../types';\nimport {\n  findSegmentationRepresentationByUID,\n  getSegmentation,\n} from '../segmentationState';\n\n// Map of conversion paths between source and target representations\n// You should read it as \"source\" -> \"targets\"\nconst conversionPaths = new Map<\n  SegmentationRepresentations,\n  Set<SegmentationRepresentations>\n>([\n  [\n    SegmentationRepresentations.Labelmap,\n    new Set([\n      SegmentationRepresentations.Surface,\n      SegmentationRepresentations.Contour,\n    ]),\n  ],\n  [\n    SegmentationRepresentations.Contour,\n    new Set([\n      SegmentationRepresentations.Labelmap,\n      SegmentationRepresentations.Surface,\n    ]),\n  ],\n  [\n    SegmentationRepresentations.Surface,\n    new Set([SegmentationRepresentations.Labelmap]),\n  ],\n]);\n\n/**\n * Determines whether the requested representation can be computed, based on\n * the existing representation types and available conversion paths.\n * This is used in the labelmapDisplay and surfaceDisplay logic if the\n * requested representation is not available whether we can use the existing\n * representation to compute the requested representation. You can checkout the polySeg\n * examples to see how this is used polyDataActorManipulationTools and others\n *\n * @param segmentationRepresentationUID - The UID of the desired segmentation representation.\n * @returns true if the requested representation can be computed, otherwise false.\n */\nfunction canComputeRequestedRepresentation(\n  segmentationRepresentationUID: string\n): boolean {\n  const representationInfo = findSegmentationRepresentationByUID(\n    segmentationRepresentationUID\n  );\n\n  if (!representationInfo?.segmentationRepresentation) {\n    return false;\n  }\n\n  const { segmentationRepresentation } = representationInfo;\n  const { type: representationType, polySeg } = segmentationRepresentation;\n\n  if (!polySeg || !polySeg.enabled) {\n    return false;\n  }\n\n  const { representationData } = getSegmentation(\n    segmentationRepresentation.segmentationId\n  );\n\n  const existingRepresentationTypes =\n    getExistingRepresentationTypes(representationData);\n\n  return existingRepresentationTypes.some((existingRepresentationType) =>\n    canConvertFromTo(existingRepresentationType, representationType)\n  );\n}\n\n/**\n * Retrieves the existing representation types for the given representationData\n * by verifying the validity of each representation type.\n *\n * @param representationData - The representation data\n * @returns supportedTypes - An array of valid representation types\n */\nfunction getExistingRepresentationTypes(\n  representationData: SegmentationRepresentationData\n): string[] {\n  const supportedTypes: string[] = [];\n\n  Object.keys(representationData).forEach((representationType) => {\n    const representationTypeData = representationData[representationType];\n\n    let validateFn;\n    switch (representationType) {\n      case SegmentationRepresentations.Labelmap:\n        validateFn = validateLabelmap;\n        break;\n      // Todo: add validation for other representation types\n    }\n\n    if (validateFn) {\n      try {\n        validateFn(representationTypeData);\n        supportedTypes.push(representationType);\n      } catch (error) {\n        console.warn(\n          `Validation failed for labelmap of type ${representationType}`\n        );\n      }\n    } else {\n      supportedTypes.push(representationType);\n    }\n  });\n\n  return supportedTypes;\n}\n\nasync function canConvertFromTo(fromRepresentationType, toRepresentationType) {\n  return (\n    conversionPaths.get(fromRepresentationType)?.has(toRepresentationType) ||\n    false\n  );\n}\n\nexport { canComputeRequestedRepresentation };\n","import { getWebWorkerManager } from '@cornerstonejs/core';\n\nlet registered = false;\n\nexport function registerPolySegWorker() {\n  if (registered) {\n    return;\n  }\n\n  registered = true;\n\n  const workerFn = () => {\n    // @ts-ignore\n    return new Worker(\n      // @ts-ignore\n      new URL('../../../workers/polySegConverters', import.meta.url),\n      {\n        name: 'polySeg',\n      }\n    );\n  };\n\n  const workerManager = getWebWorkerManager();\n\n  const options = {\n    maxWorkerInstances: 1, // Todo, make this configurable\n    autoTerminateOnIdle: {\n      enabled: true,\n      idleTimeThreshold: 2000,\n    },\n  };\n\n  workerManager.registerWorker('polySeg', workerFn, options);\n}\n","import { invalidateBrushCursor } from '../../utilities/segmentation/';\nimport {\n  getSegmentation,\n  getToolGroupIdsWithSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Set the active segment index for a segmentation Id. It fires a global state\n * modified event. Also it invalidates the brush cursor for all toolGroups that\n * has the segmentationId as active segment (since the brush cursor color\n * should change as well)\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param segmentationId - The id of the segmentation that the segment belongs to.\n * @param segmentIndex - The index of the segment to be activated.\n */\nfunction setActiveSegmentIndex(\n  segmentationId: string,\n  segmentIndex: number\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (typeof segmentIndex === 'string') {\n    console.warn('segmentIndex is a string, converting to number');\n    segmentIndex = Number(segmentIndex);\n  }\n\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    triggerSegmentationModified(segmentationId);\n  }\n\n  // get all toolGroups that has the segmentationId as active\n  // segment and call invalidateBrushCursor on them\n  const toolGroups = getToolGroupIdsWithSegmentation(segmentationId);\n  toolGroups.forEach((toolGroupId) => {\n    invalidateBrushCursor(toolGroupId);\n  });\n}\n\n/**\n * Get the active segment index for a segmentation in the global state\n * @param segmentationId - The id of the segmentation to get the active segment index from.\n * @returns The active segment index for the given segmentation.\n */\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation) {\n    return segmentation.activeSegmentIndex;\n  }\n}\n\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n","import cloneDeep from 'lodash.clonedeep';\nimport type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport getDefaultSurfaceConfig from '../../tools/displayTools/Surface/surfaceConfig';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationRepresentationConfig,\n  SegmentationState,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\n\n// Initialize the default configuration\n// Note: when we get other representations, we should set their default representations too.\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\nconst defaultSurfaceConfig = getDefaultSurfaceConfig();\n\nconst newGlobalConfig: SegmentationRepresentationConfig = {\n  renderInactiveSegmentations: true,\n  representations: {\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\n    [SegmentationRepresentations.Surface]: defaultSurfaceConfig,\n  },\n};\n\n/* A default initial state for the segmentation manager. */\nconst initialDefaultState: SegmentationState = {\n  colorLUT: [],\n  segmentations: [],\n  globalConfig: newGlobalConfig,\n  toolGroups: {},\n};\n\n/**\n * The SegmentationStateManager Class is responsible for managing the state of the\n * segmentations. It stores the segmentations and toolGroup specific representations\n * of the segmentation. It also stores a global config and a toolGroup specific\n * config. Note that this is a singleton state manager.\n */\nexport default class SegmentationStateManager {\n  private state: SegmentationState;\n  public readonly uid: string;\n\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = csUtils.uuidv4();\n    }\n    this.state = cloneDeep(initialDefaultState);\n    this.uid = uid;\n  }\n\n  /**\n   * It returns a copy of the current state of the segmentation\n   * @returns A deep copy of the state.\n   */\n  getState(): SegmentationState {\n    return this.state;\n  }\n\n  /**\n   * It returns an array of toolGroupIds currently in the segmentation state.\n   * @returns An array of strings.\n   */\n  getToolGroups(): string[] {\n    return Object.keys(this.state.toolGroups);\n  }\n\n  /**\n   * It returns the colorLUT at the specified index.\n   * @param lutIndex - The index of the color LUT to retrieve.\n   * @returns A ColorLUT object.\n   */\n  getColorLUT(lutIndex: number): Types.ColorLUT | undefined {\n    return this.state.colorLUT[lutIndex];\n  }\n\n  getNextColorLUTIndex(): number {\n    return this.state.colorLUT.length;\n  }\n\n  /**\n   * Reset the state to the default state\n   */\n  resetState(): void {\n    this.state = cloneDeep(initialDefaultState);\n  }\n\n  /**\n   * Given a segmentation Id, return the segmentation state\n   * @param segmentationId - The id of the segmentation to get the data for.\n   * @returns - The segmentation data\n   */\n  getSegmentation(segmentationId: string): Segmentation | undefined {\n    return this.state.segmentations.find(\n      (segmentation) => segmentation.segmentationId === segmentationId\n    );\n  }\n\n  /**\n   * It adds a segmentation to the segmentations array.\n   * @param segmentation - Segmentation\n   */\n  addSegmentation(segmentation: Segmentation): void {\n    // Check if the segmentation already exists with the segmentationId\n    if (this.getSegmentation(segmentation.segmentationId)) {\n      throw new Error(\n        `Segmentation with id ${segmentation.segmentationId} already exists`\n      );\n    }\n\n    this.state.segmentations.push(segmentation);\n  }\n\n  /**\n   * Get the segmentation representations for a tool group\n   * @param toolGroupId - string\n   * @returns A list of segmentation representations.\n   */\n  getSegmentationRepresentations(\n    toolGroupId: string\n  ): ToolGroupSpecificRepresentations | undefined {\n    const toolGroupSegRepresentationsWithConfig =\n      this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupSegRepresentationsWithConfig) {\n      return;\n    }\n\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n  }\n\n  /**\n   * Returns an array of all segmentation representations for all tool groups.\n   * @returns An array of ToolGroupSpecificRepresentations.\n   */\n  getAllSegmentationRepresentations(): Record<\n    string,\n    ToolGroupSpecificRepresentation[]\n  > {\n    const toolGroupSegReps: Record<string, ToolGroupSpecificRepresentation[]> =\n      {};\n    Object.entries(this.state.toolGroups).forEach(\n      ([toolGroupId, toolGroupSegRepresentationsWithConfig]) => {\n        toolGroupSegReps[toolGroupId] =\n          toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n      }\n    );\n    return toolGroupSegReps;\n  }\n\n  /**\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\n   * @param toolGroupId - The Id of the tool group .\n   * @param segmentationRepresentation - The segmentation representation to add.\n   */\n  addSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    // Initialize the default toolGroup state if not created yet\n    if (!this.state.toolGroups[toolGroupId]) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {} as SegmentationRepresentationConfig,\n      };\n    }\n\n    // local toolGroupSpecificSegmentationState\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\n      segmentationRepresentation\n    );\n\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n  }\n\n  /**\n   * Get the global config containing both representation config\n   * and render inactive segmentations config\n   * @returns The global config object.\n   */\n  getGlobalConfig(): SegmentationRepresentationConfig {\n    return this.state.globalConfig;\n  }\n\n  /**\n   * It sets the global segmentation config including both representation config\n   * and render inactive segmentations config\n   * @param config - The global configuration for the segmentations.\n   */\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\n    this.state.globalConfig = config;\n  }\n\n  /**\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\n   * representation for that tool group.\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - string\n   * @returns The segmentation representation.\n   */\n  getSegmentationRepresentationByUID(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): ToolGroupSpecificRepresentation | undefined {\n    const toolGroupSegRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    const segmentationData = toolGroupSegRepresentations?.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    return segmentationData;\n  }\n\n  /**\n   * It removes the segmentation from the segmentation state.\n   * @param segmentationId - The id of the segmentation to remove.\n   */\n  removeSegmentation(segmentationId: string): void {\n    this.state.segmentations = this.state.segmentations.filter(\n      (segmentation) => segmentation.segmentationId !== segmentationId\n    );\n  }\n\n  /**\n   * Remove a segmentation representation from the toolGroup\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\n   * @param immediate - If true, the viewport will be updated immediately.\n   */\n  removeSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      !toolGroupSegmentationRepresentations.length\n    ) {\n      throw new Error(\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\n      );\n    }\n\n    const state =\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\n    const index = state.findIndex(\n      (segData) =>\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\n    );\n\n    if (index === -1) {\n      console.warn(\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    const removedSegmentationRepresentation =\n      toolGroupSegmentationRepresentations[index];\n\n    toolGroupSegmentationRepresentations.splice(index, 1);\n\n    this._handleActiveSegmentation(\n      toolGroupId,\n      removedSegmentationRepresentation\n    );\n  }\n\n  /**\n   * Set the active segmentation data for a tool group\n   * @param toolGroupId - The Id of the tool group that owns the\n   * segmentation data.\n   * @param segmentationRepresentationUID - string\n   */\n  setActiveSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n      throw new Error(\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\n      );\n    }\n\n    const segmentationData = toolGroupSegmentations.find(\n      (segmentationData) =>\n        segmentationData.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (!segmentationData) {\n      throw new Error(\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    segmentationData.active = true;\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\n  }\n\n  /**\n   * Given a tool group Id it returns the tool group specific representation config\n   *\n   * @param toolGroupId - The Id of the tool group\n   * @returns A SegmentationConfig object.\n   */\n  getToolGroupSpecificConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig | undefined {\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      return;\n    }\n\n    return toolGroupStateWithConfig.config;\n  }\n\n  getSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n  }\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: RepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\n      config;\n  }\n\n  getSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    segmentIndex: number\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n  }\n\n  setSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: SegmentSpecificRepresentationConfig,\n    options?: {\n      clear: false;\n    }\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    if (!segmentationRepresentation.segmentSpecificConfig || options?.clear) {\n      segmentationRepresentation.segmentSpecificConfig = {};\n    }\n\n    Object.keys(config).forEach((key) => {\n      segmentationRepresentation.segmentSpecificConfig[key] = config[key];\n    });\n  }\n\n  /**\n   * Set the segmentation representations config for a given tool group. It will create a new\n   * tool group specific config if one does not exist.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation\n   * belongs to.\n   * @param config - SegmentationConfig\n   */\n  setSegmentationRepresentationConfig(\n    toolGroupId: string,\n    config: SegmentationRepresentationConfig\n  ): void {\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {\n          renderInactiveSegmentations: true,\n          representations: {},\n        },\n      };\n\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n    }\n\n    toolGroupStateWithConfig.config = {\n      ...toolGroupStateWithConfig.config,\n      ...config,\n    };\n  }\n\n  /**\n   * It adds a color LUT to the state.\n   * @param colorLUT - ColorLUT\n   * @param lutIndex - The index of the color LUT table to add.\n   */\n  addColorLUT(colorLUT: Types.ColorLUT, lutIndex: number): void {\n    if (this.state.colorLUT[lutIndex]) {\n      console.warn('Color LUT table already exists, overwriting');\n    }\n\n    this.state.colorLUT[lutIndex] = cloneDeep(colorLUT);\n  }\n\n  /**\n   * Removes a color LUT to the state.\n   * @param colorLUTIndex - The index of the color LUT table to remove.\n   */\n  removeColorLUT(colorLUTIndex: number): void {\n    delete this.state.colorLUT[colorLUTIndex];\n  }\n\n  /**\n   * It handles the active segmentation representation based on the active status of the\n   * segmentation representation that was added or removed.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\n   */\n  _handleActiveSegmentation(\n    toolGroupId: string,\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    // 1. If there is no segmentation representations, return early\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // 2. If there is only one segmentation representation, make that one active\n    if (segmentationRepresentations.length === 1) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 3. If removed Segmentation representation was active, make the first one active\n    const activeSegmentationRepresentations =\n      segmentationRepresentations.filter(\n        (representation) => representation.active\n      );\n\n    if (activeSegmentationRepresentations.length === 0) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 4. If the added segmentation representation is active, make other segmentation\n    // representations inactive\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n      segmentationRepresentations.forEach((representation) => {\n        if (\n          representation.segmentationRepresentationUID !==\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\n        ) {\n          representation.active = false;\n        }\n      });\n    }\n\n    // 5. if added/removed segmentation is is inactive, do nothing\n  }\n}\n\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n","import { SegmentationRepresentations } from '../../../enums';\nimport {\n  SegmentationPublicInput,\n  Segmentation,\n} from '../../../types/SegmentationStateTypes';\nimport type { ContourSegmentationData } from '../../../types/ContourTypes';\n\n/**\n * It takes in a segmentation input and returns a segmentation with default values\n * @param segmentationInput - The input to the segmentation.\n * @returns A Segmentation object.\n * @internal\n */\nfunction normalizeSegmentationInput(\n  segmentationInput: SegmentationPublicInput\n): Segmentation {\n  const { segmentationId, representation } = segmentationInput;\n  const isContourRepresentation =\n    representation.type === SegmentationRepresentations.Contour;\n  let data = representation.data ? { ...representation.data } : null;\n\n  // Contour representation data is defined internally\n  data = !data && isContourRepresentation ? {} : data;\n\n  // Data cannot be undefined for labelmap and surface\n  if (!data) {\n    throw new Error('Segmentation representation data may not be undefined');\n  }\n\n  if (isContourRepresentation) {\n    const contourData = <ContourSegmentationData>data;\n\n    // geometryIds will be removed in a near future. It still exist in the\n    // code for compatibility only but it is optional from now on.\n    contourData.geometryIds = contourData.geometryIds ?? [];\n\n    // Make sure annotationUIDsMap is defined because an empty contour is\n    // created before adding contour annotations to the map. Also it prevents\n    // breaking legacy code after moving from geometryIds to annotationUIDsMap.\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n  }\n\n  // Todo: we should be able to let the user pass in non-default values for\n  // cachedStats, label, activeSegmentIndex, etc.\n  return {\n    segmentationId,\n    cachedStats: {},\n    segmentLabels: {},\n    label: null,\n    segmentsLocked: new Set(),\n    type: representation.type,\n    activeSegmentIndex: 1,\n    representationData: {\n      [representation.type]: {\n        ...data,\n      },\n    },\n  };\n}\n\nexport default normalizeSegmentationInput;\n","import type { Types } from '@cornerstonejs/core';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationPublicInput,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport {\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n} from './triggerSegmentationEvents';\n\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\n\n/**\n * It returns the defaultSegmentationStateManager.\n */\nfunction getDefaultSegmentationStateManager() {\n  return defaultSegmentationStateManager;\n}\n\n/*************************\n *\n * Segmentation State\n *\n **************************/\n\n/**\n * Get the segmentation for the given segmentationId\n * @param segmentationId - The Id of the segmentation\n * @returns A GlobalSegmentationData object\n */\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentation(segmentationId);\n}\n\n/**\n * Get the segmentations inside the state\n * @returns Segmentation array\n */\nfunction getSegmentations(): Segmentation[] | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n\n  return state.segmentations;\n}\n\n/**\n * It takes a segmentation input and adds it to the segmentation state manager\n * @param segmentationInput - The segmentation to add.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction addSegmentation(\n  segmentationInput: SegmentationPublicInput,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const segmentation = normalizeSegmentationInput(segmentationInput);\n\n  segmentationStateManager.addSegmentation(segmentation);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified(segmentation.segmentationId);\n  }\n}\n\n/**\n * Get the segmentation state for a tool group. It will return an array of\n * segmentation representation objects.\n * @param toolGroupId - The unique identifier of the tool group.\n * @returns An array of segmentation representation objects.\n */\nfunction getSegmentationRepresentations(\n  toolGroupId: string\n): ToolGroupSpecificRepresentations | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\n\n/**\n * Get all segmentation representations in the state\n * @returns An array of segmentation representation objects.\n */\nfunction getAllSegmentationRepresentations(): Record<\n  string,\n  ToolGroupSpecificRepresentation[]\n> {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getAllSegmentationRepresentations();\n}\n\n/**\n * Finds all segmentation representations with the given segmentationId.\n * @param segmentationId - The ID of the segmentation.\n * @returns An array of found segmentation representations.\n */\nfunction getSegmentationIdRepresentations(segmentationId) {\n  const allRepresentations = getAllSegmentationRepresentations() || {};\n  const foundRepresentations = [];\n\n  for (const toolGroupId in allRepresentations) {\n    const toolGroupRepresentations = allRepresentations[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) => representation.segmentationId === segmentationId\n    );\n\n    if (foundRepresentation) {\n      foundRepresentations.push(foundRepresentation);\n    }\n  }\n\n  return foundRepresentations;\n}\n\n/**\n * Finds a segmentation representation by its UID.\n *\n * @param segmentationRepresentationUID - The UID of the segmentation representation to find.\n * @returns The found segmentation representation, or undefined if not found.\n */\nfunction findSegmentationRepresentationByUID(\n  segmentationRepresentationUID: string\n): {\n  toolGroupId: string;\n  segmentationRepresentation: ToolGroupSpecificRepresentation;\n} {\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\n\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\n\n  for (const toolGroupId of toolGroupIds) {\n    const toolGroupRepresentations =\n      getAllSegmentationRepresentations()[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (foundRepresentation) {\n      return {\n        segmentationRepresentation: foundRepresentation,\n        toolGroupId,\n      };\n    }\n  }\n}\n\n/**\n * Get the tool group IDs that have a segmentation representation with the given\n * segmentationId\n * @param segmentationId - The id of the segmentation\n * @returns An array of tool group IDs.\n */\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\n  if (!segmentationId) {\n    throw new Error('getToolGroupIdsWithSegmentation: segmentationId is empty');\n  }\n\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n  const toolGroupIds = Object.keys(state.toolGroups);\n\n  const foundToolGroupIds = [];\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        foundToolGroupIds.push(toolGroupId);\n      }\n    });\n  });\n\n  return foundToolGroupIds;\n}\n\n/**\n * Get the segmentation representations config for a given tool group\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config belongs to.\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\n * configuration overwrites the global configuration for each representation.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config is being set for.\n * @param config - The new configuration for the tool group.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationConfig(\n    toolGroupId,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(toolGroupId);\n  }\n}\n\n/**\n * It sets the segmentation representation specific config for all the segments\n * inside the segmentation.\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\n * different representation types, and values of the configuration for each representation type.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the segmentation representation specific config which is the same for all the segments\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @returns - The segmentation representation specific config.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction getSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\nfunction setSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  // Todo: this can be even more performant if we create a new event for\n  // triggering a specific segment config change.\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nfunction getToolGroupIdFromSegmentationRepresentationUID(\n  segmentationRepresentationUID: string\n): string {\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\n\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\n\n  for (const toolGroupId of toolGroupIds) {\n    const toolGroupRepresentations =\n      getAllSegmentationRepresentations()[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (foundRepresentation) {\n      return toolGroupId;\n    }\n  }\n}\n\n/**\n * Add the given segmentation representation data to the given tool group state. It fires\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\n * @param segmentationData - The data to add to the segmentation state.\n * @param suppressEvents - boolean\n */\nfunction addSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentation\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the global segmentation config. Note that the toolGroup-specific\n * configuration has higher priority than the global configuration and overwrites\n * the global configuration for each representation.\n * @returns The global segmentation configuration for all segmentations.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\n * event if not suppressed.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param config - The new global segmentation config.\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\n */\nfunction setGlobalConfig(\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setGlobalConfig(config);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified();\n  }\n}\n\n/**\n * Get the segmentation data object for a given tool group and\n * segmentation data UID. It searches all the toolGroup specific segmentation\n * data objects and returns the first one that matches the UID.\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @returns Segmentation Data object.\n */\nfunction getSegmentationRepresentationByUID(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): ToolGroupSpecificRepresentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * It removes the segmentation from the segmentation state manager\n *\n * @triggers SEGMENTATION_REMOVED\n *\n * @param segmentationId - The id of the segmentation\n */\nfunction removeSegmentation(segmentationId: string): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentation(segmentationId);\n  triggerSegmentationRemoved(segmentationId);\n}\n\n/**\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\n * remove.\n * @param - immediate - If true, the viewports will be updated immediately.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationRemoved(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Removes all segmentation representations associated with a tool group.\n * @param toolGroupId - The ID of the tool group.\n */\nfunction removeSegmentationRepresentations(toolGroupId: string): void {\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((representation) => {\n    removeSegmentationRepresentation(\n      toolGroupId,\n      representation.segmentationRepresentationUID\n    );\n  });\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction removeColorLUT(colorLUTIndex: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n\n/**\n * Get the color lut for a given index\n * @param index - The index of the color lut to retrieve.\n * @returns A ColorLUT array.\n */\nfunction getColorLUT(index: number): Types.ColorLUT | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getColorLUT(index);\n}\n\nfunction getNextColorLUTIndex(): number {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getNextColorLUTIndex();\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, index: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addColorLUT(colorLUT, index);\n  // Todo: trigger event color LUT added\n}\n\nexport {\n  getDefaultSegmentationStateManager,\n  // Segmentation\n  getSegmentation,\n  getSegmentations,\n  addSegmentation,\n  removeSegmentation,\n  // ToolGroup specific Segmentation Representation\n  getSegmentationRepresentations,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n  removeSegmentationRepresentations,\n  // config\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  getGlobalConfig,\n  setGlobalConfig,\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  getSegmentSpecificRepresentationConfig,\n  setSegmentSpecificRepresentationConfig,\n  // helpers s\n  getToolGroupIdsWithSegmentation,\n  getAllSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n  getSegmentationIdRepresentations,\n  // color\n  addColorLUT,\n  getColorLUT,\n  getNextColorLUTIndex,\n  removeColorLUT,\n  //\n  findSegmentationRepresentationByUID,\n  getToolGroupIdFromSegmentationRepresentationUID,\n};\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\n\nimport { Events } from '../../enums';\nimport {\n  getSegmentationRepresentations,\n  getSegmentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  SegmentationRepresentationModifiedEventDetail,\n  SegmentationDataModifiedEventDetail,\n  SegmentationModifiedEventDetail,\n  SegmentationRepresentationRemovedEventDetail,\n  SegmentationRemovedEventDetail,\n} from '../../types/EventTypes';\nimport { setSegmentationDirty } from '../../utilities/segmentation/getUniqueSegmentIndices';\n\n/**\n * Trigger an event that a segmentation is removed\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationRemoved(segmentationId: string): void {\n  const eventDetail: SegmentationRemovedEventDetail = {\n    segmentationId,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n\n/**\n * Trigger an event that a segmentation representation was removed\n * @param toolGroupId - The id of the tool group that the segmentation\n * representation was removed from.\n * @param segmentationRepresentationUID - The UID of the segmentation\n * representation that was removed.\n */\nfunction triggerSegmentationRepresentationRemoved(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  triggerEvent(\n    eventTarget,\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\n    eventDetail\n  );\n}\n\n/**\n * Trigger an event on the eventTarget that the segmentation representation for\n * toolGroupId has been updated\n * @param toolGroupId - The Id of the toolGroup\n */\nfunction triggerSegmentationRepresentationModified(\n  toolGroupId: string,\n  segmentationRepresentationUID?: string\n): void {\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  if (segmentationRepresentationUID) {\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n    return;\n  }\n\n  // If no segmentationRepresentationUID is provided, then we need to trigger\n  // the event for all segmentation representations in the toolGroup\n\n  // Get all segmentation representations in the toolGroup\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n      toolGroupId,\n      segmentationRepresentationUID,\n    };\n\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n  });\n}\n\n/**\n * Triggers segmentation global state updated event, notifying all toolGroups\n * that the global state has been updated, If a segmentationId is provided\n * the event will only be triggered for that segmentation, otherwise it will\n * be triggered for all segmentations.\n *\n * @param segmentationId - The id of the segmentation that has been updated\n */\nfunction triggerSegmentationModified(segmentationId?: string): void {\n  let segmentationIds;\n\n  if (segmentationId) {\n    segmentationIds = [segmentationId];\n  } else {\n    // get all toolGroups\n    segmentationIds = getSegmentations().map(\n      ({ segmentationId }) => segmentationId\n    );\n  }\n\n  // 1. Trigger an event notifying all listeners about the segmentationId\n  // that has been updated.\n  segmentationIds.forEach((segmentationId) => {\n    const eventDetail: SegmentationModifiedEventDetail = {\n      segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n  });\n\n  // Todo: I don't think we need the following lines of code\n  // // 2. Notify all viewports that render the segmentationId in order to update the\n  // // rendering based on the new global state.\n  // toolGroupIds.forEach((toolGroupId) => {\n  //   triggerSegmentationRepresentationModified(toolGroupId)\n  // })\n}\n\n/**\n * Trigger an event that a segmentation data has been modified\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationDataModified(\n  segmentationId: string,\n  modifiedSlicesToUse?: number[]\n): void {\n  const eventDetail: SegmentationDataModifiedEventDetail = {\n    segmentationId,\n    modifiedSlicesToUse,\n  };\n\n  // set it to dirty to force the next call to getUniqueSegmentIndices to\n  // recalculate the segment indices\n  setSegmentationDirty(segmentationId);\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n\nexport {\n  // ToolGroup Specific\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n  // Global\n  triggerSegmentationDataModified,\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n};\n","import {\n  getRenderingEngine,\n  getEnabledElement,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\n\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Synchronizer is a class that listens to a specific event on a specific source\n * targets and fires a specific event on a specific target elements. Use cases\n * include: synchronizing a camera between two viewports, synchronizing a\n * windowLevel between various viewports.\n */\nclass Synchronizer {\n  //\n  private _enabled: boolean;\n  private _eventName: string;\n  private _auxiliaryEventNames: string[];\n  private _eventHandler: ISynchronizerEventHandler;\n  private _ignoreFiredEvents: boolean;\n  private _sourceViewports: Array<Types.IViewportId>;\n  private _targetViewports: Array<Types.IViewportId>;\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\n  private _options: any;\n  public id: string;\n\n  constructor(\n    synchronizerId: string,\n    eventName: string,\n    eventHandler: ISynchronizerEventHandler,\n    options?: any\n  ) {\n    this._enabled = true;\n    this._eventName = eventName;\n    this._eventHandler = eventHandler;\n    this._ignoreFiredEvents = false;\n    this._sourceViewports = [];\n    this._targetViewports = [];\n    this._options = options || {};\n    this._auxiliaryEventNames = this._options.auxiliaryEventNames || [];\n\n    //\n    this.id = synchronizerId;\n  }\n\n  /**\n   * \"Returns true if the synchronizer is disabled.\"\n   * @returns A boolean value.\n   */\n  public isDisabled(): boolean {\n    return !this._enabled || !this._hasSourceElements();\n  }\n\n  /**\n   * Sets the options for the viewport id.  This can be used to\n   * provide configuration on a viewport basis for things like offsets\n   * to the general synchronization, or turn on/off synchronization of certain\n   * attributes.\n   */\n  public setOptions(\n    viewportId: string,\n    options: Record<string, unknown> = {}\n  ): void {\n    this._viewportOptions[viewportId] = options;\n  }\n\n  /**\n   * Sets a synchronizer enabled\n   */\n  public setEnabled(enabled: boolean) {\n    this._enabled = enabled;\n  }\n\n  /** Gets the options for the given viewport id */\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\n    return this._viewportOptions[viewportId];\n  }\n\n  /**\n   * Add a viewport to the list of targets and sources both.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public add(viewportInfo: Types.IViewportId): void {\n    this.addTarget(viewportInfo);\n    this.addSource(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of sources (source ONLY)\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addSource(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = viewportInfo;\n\n    const viewport =\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\n\n    if (!viewport) {\n      console.warn(\n        `Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`\n      );\n      return;\n    }\n\n    const element = viewport.element;\n\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\n\n    if (this._auxiliaryEventNames.length) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        element.addEventListener(eventName, this._onEvent.bind(this));\n      });\n    }\n\n    this._updateDisableHandlers();\n\n    this._sourceViewports.push(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of viewports that will get the eventHandler\n   * executed when the event is fired on the source viewport.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addTarget(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\n      return;\n    }\n\n    this._targetViewports.push(viewportInfo);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getSourceViewports(): Array<Types.IViewportId> {\n    return this._sourceViewports;\n  }\n\n  /**\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getTargetViewports(): Array<Types.IViewportId> {\n    return this._targetViewports;\n  }\n\n  public destroy(): void {\n    this._sourceViewports.forEach((s) => this.removeSource(s));\n    this._targetViewports.forEach((t) => this.removeTarget(t));\n  }\n\n  /**\n   * Remove the viewport from the list of targets and sources\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public remove(viewportInfo: Types.IViewportId): void {\n    this.removeTarget(viewportInfo);\n    this.removeSource(viewportInfo);\n  }\n\n  /**\n   * Remove the viewport from the list of source viewports\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public removeSource(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    const element = _getViewportElement(viewportInfo);\n\n    this._sourceViewports.splice(index, 1);\n\n    //@ts-ignore\n    element.removeEventListener(this._eventName, this._eventHandler);\n\n    if (this._auxiliaryEventNames) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        //@ts-ignore\n        element.removeEventListener(eventName, this._eventHandler);\n      });\n    }\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Remove the viewport from the list of viewports that are currently targeted by\n   * this handler\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   *\n   */\n  public removeTarget(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._targetViewports.splice(index, 1);\n    this._updateDisableHandlers();\n  }\n\n  public hasSourceViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._sourceViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  public hasTargetViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._targetViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\n    if (this.isDisabled() || this._ignoreFiredEvents) {\n      return;\n    }\n\n    this._ignoreFiredEvents = true;\n    const promises = [];\n    try {\n      for (let i = 0; i < this._targetViewports.length; i++) {\n        const targetViewport = this._targetViewports[i];\n        const targetIsSource =\n          sourceViewport.viewportId === targetViewport.viewportId;\n\n        if (targetIsSource) {\n          continue;\n        }\n        const result = this._eventHandler(\n          this,\n          sourceViewport,\n          targetViewport,\n          sourceEvent,\n          this._options\n        );\n\n        // if the result is a promise, then add it to the list of promises\n        // to wait for before setting _ignoreFiredEvents to false\n        if (result instanceof Promise) {\n          promises.push(result);\n        }\n      }\n    } catch (ex) {\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n    } finally {\n      if (promises.length) {\n        Promise.allSettled(promises).then(() => {\n          this._ignoreFiredEvents = false;\n        });\n      } else {\n        this._ignoreFiredEvents = false;\n      }\n    }\n  }\n\n  private _onEvent = (evt: any): void => {\n    if (this._ignoreFiredEvents === true) {\n      return;\n    }\n\n    // If no target viewports, then return immediately, this is useful\n    // when switching between layouts, when previous layout has disabled\n    // its viewports, and the new layout has not yet enabled them.\n    // Right now we don't \"delete\" the synchronizer if all source and targets\n    // are removed, but we may want to do that in the future.\n    if (!this._targetViewports.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(evt.currentTarget);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    // If the viewport has been removed from the synchronizer before the event is\n    // fired, then return immediately.\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n      return;\n    }\n\n    this.fireEvent(\n      {\n        renderingEngineId,\n        viewportId,\n      },\n      evt\n    );\n  };\n\n  private _hasSourceElements(): boolean {\n    return this._sourceViewports.length !== 0;\n  }\n\n  private _updateDisableHandlers(): void {\n    const viewports = _getUniqueViewports(\n      this._sourceViewports,\n      this._targetViewports\n    );\n    const _remove = this.remove;\n    const disableHandler = (elementDisabledEvent) => {\n      _remove(elementDisabledEvent.detail.element);\n    };\n\n    viewports.forEach(function (vUid) {\n      const renderingEngine = getRenderingEngine(vUid.renderingEngineId);\n\n      if (!renderingEngine) {\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(vUid.viewportId);\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.ELEMENT_DISABLED,\n        disableHandler\n      );\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n    });\n  }\n}\n\nfunction _getUniqueViewports(\n  vp1: Array<Types.IViewportId>,\n  vp2: Array<Types.IViewportId>\n): Array<Types.IViewportId> {\n  const unique = [];\n\n  const vps = vp1.concat(vp2);\n\n  for (let i = 0; i < vps.length; i++) {\n    const vp = vps[i];\n    if (\n      !unique.some(\n        (u) =>\n          vp.renderingEngineId === u.renderingEngineId &&\n          vp.viewportId === u.viewportId\n      )\n    ) {\n      unique.push(vp);\n    }\n  }\n\n  return unique;\n}\n\nfunction _getViewportIndex(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n): number {\n  return arr.findIndex(\n    (ar) =>\n      vp.renderingEngineId === ar.renderingEngineId &&\n      vp.viewportId === ar.viewportId\n  );\n}\n\nfunction _containsViewport(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n) {\n  return arr.some(\n    (ar) =>\n      ar.renderingEngineId === vp.renderingEngineId &&\n      ar.viewportId === vp.viewportId\n  );\n}\n\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n  }\n\n  return renderingEngine.getViewport(vp.viewportId).element;\n}\n\nexport default Synchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * It returns all synchronizers that are not disabled and have a source viewport\n * with the given rendering engine Id and viewport Id\n * @param renderingEngineId - The Id of the rendering engine\n * @param viewportId - The Id of the viewport\n * @returns An array of synchronizers\n */\nfunction getSynchronizersForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): Array<Synchronizer> {\n  const synchronizersFilteredByIds = [];\n\n  if (!renderingEngineId && !viewportId) {\n    throw new Error(\n      'At least one of renderingEngineId or viewportId should be given'\n    );\n  }\n\n  for (let i = 0; i < state.synchronizers.length; i++) {\n    const synchronizer = state.synchronizers[i];\n    const notDisabled = !synchronizer.isDisabled();\n    const hasSourceViewport = synchronizer.hasSourceViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    const hasTargetViewport = synchronizer.hasTargetViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n      synchronizersFilteredByIds.push(synchronizer);\n    }\n  }\n\n  return synchronizersFilteredByIds;\n}\n\nexport default getSynchronizersForViewport;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Create a new synchronizer instance from Synchronizer class\n * @param synchronizerId - The id of the synchronizer.\n * @param eventName - The name of the event that will be emitted by the\n * synchronizer.\n * @param eventHandler - The event handler that will be\n * called when the event is emitted.\n * @param options - Options for the synchronizer.\n * @returns A reference to the synchronizer.\n */\nfunction createSynchronizer(\n  synchronizerId: string,\n  eventName: string,\n  eventHandler: ISynchronizerEventHandler,\n  options?: any\n): Synchronizer {\n  const synchronizerWithSameIdExists = state.synchronizers.some(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerWithSameIdExists) {\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n  }\n\n  // Create\n  const synchronizer = new Synchronizer(\n    synchronizerId,\n    eventName,\n    eventHandler,\n    options\n  );\n\n  // Update state\n  state.synchronizers.push(synchronizer);\n\n  // Return reference\n  return synchronizer;\n}\n\nexport default createSynchronizer;\n","import { state } from '../index';\n\n/**\n * \"Destroy all synchronizers.\"\n */\nfunction destroy(): void {\n  while (state.synchronizers.length > 0) {\n    const synchronizer = state.synchronizers.pop();\n\n    synchronizer.destroy();\n  }\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Get the synchronizer with the given id from the state.\n * @param synchronizerId - The id of the synchronizer to be retrieved.\n * @returns A synchronizer object.\n */\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\n  return state.synchronizers.find((s) => s.id === synchronizerId);\n}\n\nexport default getSynchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Return the array of synchronizers\n * @returns An array of synchronizers.\n */\nfunction getAllSynchronizers(): Array<Synchronizer> {\n  return state.synchronizers;\n}\n\nexport default getAllSynchronizers;\n","import { state } from '../index';\n\n// Synchronizers are a bit more tenacious. We need to make sure we remove\n// any attached events\n// We should probably just have a destroySynchronizer call\n// then use getByX to allow versatility in how we can call destroy\n\n/**\n * Destroy a synchronizer by its ID.\n * @param synchronizerId - The id of the synchronizer to destroy.\n */\nfunction destroySynchronizer(synchronizerId: string): void {\n  const synchronizerIndex = state.synchronizers.findIndex(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerIndex > -1) {\n    const synchronizer = state.synchronizers[synchronizerIndex];\n\n    synchronizer.destroy();\n    state.synchronizers.splice(synchronizerIndex, 1);\n  }\n}\n\nexport default destroySynchronizer;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a rendering engine Id and a viewport Id, return the tool group that\n * contains that rendering engine and viewport. Note: A viewport can only be\n * associated with a single tool group. You cannot have a viewport that belongs\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\n * for it. This will not impact memory usage much as the volume textures are\n * shared across all viewports rendering the same image.\n *\n * @param viewportId - The Id of the viewport that the tool is being\n * added to.\n * @param renderingEngineId - The Id of the rendering engine that the\n * tool group is associated with.\n * @returns A tool group.\n */\nfunction getToolGroupForViewport(\n  viewportId: string,\n  renderingEngineId?: string\n): IToolGroup | undefined {\n  if (!renderingEngineId) {\n    renderingEngineId = getRenderingEngines().find((re) =>\n      re.getViewports().find((vp) => vp.id === viewportId)\n    )?.id;\n  }\n\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\n    tg.viewportsInfo.some(\n      (vp) =>\n        vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)\n    )\n  );\n\n  if (!toolGroupFilteredByIds.length) {\n    return;\n  }\n\n  if (toolGroupFilteredByIds.length > 1) {\n    throw new Error(\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`\n    );\n  }\n\n  return toolGroupFilteredByIds[0];\n}\n\nexport default getToolGroupForViewport;\n","import { state } from './state';\n\n/**\n * Adds the tool class to the cornerstoneTools to be used later. This function\n * should be called before creating the toolGroups and adding tools and setting their mode.\n * The flow is:\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\n * - createToolGroup(toolGroupId)\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\n * - toolGroup.setToolActive(${toolName})\n *\n * @param ToolClass - A tool calls to instantiate.\n * @param toolOptions - The tool-specific configuration options for the tool.\n * @returns\n */\nexport function addTool(ToolClass): void {\n  // Check if tool exists and name is not undefined\n  const toolName = ToolClass.toolName;\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\n\n  if (!toolName) {\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n  }\n\n  if (toolAlreadyAdded) {\n    throw new Error(`${toolName} has already been added globally`);\n  }\n\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\n  state.tools[toolName] = {\n    toolClass: ToolClass,\n  };\n}\n\n/**\n * Check if a given tool is already registered\n * @param ToolClass - A tool class to check\n * @returns True if the tool is alredy registered or false otherwise\n */\nexport function hasTool(ToolClass): boolean {\n  const toolName = ToolClass.toolName;\n\n  return !!(toolName && state.tools[toolName]);\n}\n\n/**\n * Removes the tool class from the cornerstoneTools.\n *\n * @param ToolClass - A tool calls to instantiate.\n */\nexport function removeTool(ToolClass): void {\n  const toolName = ToolClass.toolName;\n\n  if (!toolName) {\n    throw new Error(`No tool found for: ${ToolClass.name}`);\n  }\n\n  if (!state.tools[toolName] !== undefined) {\n    delete state.tools[toolName];\n  } else {\n    throw new Error(\n      `${toolName} cannot be removed because it has not been added`\n    );\n  }\n}\n\nexport default addTool;\n","import { Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  touchToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n} from '../eventDispatchers';\nimport { state } from './state';\n\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\n/**\n * When an element is \"enabled\", add event listeners and dispatchers to it\n * so we can use interactions to affect tool behaviors\n *\n * @param evt - The ELEMENT_ENABLED event\n */\nexport default function addEnabledElement(\n  evt: Types.EventTypes.ElementEnabledEvent\n): void {\n  const { element, viewportId } = evt.detail;\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\n\n  // Reset/Create svgNodeCache for element\n  _setSvgNodeCache(element);\n  _appendChild(svgLayer, element);\n\n  // Add this element to the annotation rendering engine\n  annotationRenderingEngine.addViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.enable(element);\n  wheelEventListener.enable(element);\n  touchEventListeners.enable(element);\n  keyEventListener.enable(element);\n  imageChangeEventListener.enable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.enable(element);\n  cameraModifiedEventDispatcher.enable(element);\n  imageSpacingCalibratedEventDispatcher.enable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.enable(element);\n  keyboardToolEventDispatcher.enable(element);\n  touchToolEventDispatcher.enable(element);\n\n  // labelmap\n  // State\n  state.enabledElements.push(element);\n}\n\n/**\n *\n */\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgLayer = document.createElementNS(svgns, 'svg');\n\n  const svgLayerId = `svg-layer-${viewportId}`;\n  svgLayer.classList.add('svg-layer');\n  svgLayer.setAttribute('id', svgLayerId);\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgLayer.style.width = '100%';\n  svgLayer.style.height = '100%';\n  svgLayer.style.pointerEvents = 'none';\n  svgLayer.style.position = 'absolute';\n  // TODO: we should test this on high-res monitors\n  //svgLayer.style.textRendering = 'optimizeSpeed'\n\n  // Single dropshadow config for now\n  const defs = document.createElementNS(svgns, 'defs');\n  const filter = document.createElementNS(svgns, 'filter');\n  const feOffset = document.createElementNS(svgns, 'feOffset');\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n  const feBlend = document.createElementNS(svgns, 'feBlend');\n\n  //\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\n\n  //\n  feOffset.setAttribute('result', 'offOut');\n  feOffset.setAttribute('in', 'SourceGraphic');\n  feOffset.setAttribute('dx', '0.5');\n  feOffset.setAttribute('dy', '0.5');\n\n  //\n  feColorMatrix.setAttribute('result', 'matrixOut');\n  feColorMatrix.setAttribute('in', 'offOut');\n  feColorMatrix.setAttribute('in2', 'matrix');\n  feColorMatrix.setAttribute(\n    'values',\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\n  );\n\n  //\n  feBlend.setAttribute('in', 'SourceGraphic');\n  feBlend.setAttribute('in2', 'matrixOut');\n  feBlend.setAttribute('mode', 'normal');\n\n  filter.appendChild(feOffset);\n  filter.appendChild(feColorMatrix);\n  filter.appendChild(feBlend);\n  defs.appendChild(filter);\n  svgLayer.appendChild(defs);\n\n  return svgLayer;\n}\n\nfunction _setSvgNodeCache(element) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  // Create or reset\n  // TODO: If... Reset, we should blow out any nodes in DOM\n  state.svgNodeCache[elementHash] = {};\n}\n\n/**\n *\n * @param newNode\n * @param referenceNode\n */\nfunction _appendChild(\n  newNode: SVGElement,\n  referenceNode: HTMLDivElement\n): void {\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  touchToolEventDispatcher,\n} from '../eventDispatchers';\n// ~~\n\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\nfunction removeEnabledElement(\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\n): void {\n  // Is DOM element\n  const { element, viewportId } = elementDisabledEvt.detail;\n\n  _resetSvgNodeCache(element);\n  _removeSvgNode(element);\n\n  // Remove this element from the annotation rendering engine\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.disable(element);\n  wheelEventListener.disable(element);\n  touchEventListeners.disable(element);\n  keyEventListener.disable(element);\n\n  // labelmap\n  imageChangeEventListener.disable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.disable(element);\n  cameraModifiedEventDispatcher.disable(element);\n  imageSpacingCalibratedEventDispatcher.disable(element);\n\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.disable(element);\n  keyboardToolEventDispatcher.disable(element);\n  touchToolEventDispatcher.disable(element);\n\n  // State\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\n  _removeViewportFromSynchronizers(element);\n  _removeViewportFromToolGroup(element);\n\n  // _removeAllToolsForElement(canvas)\n  _removeEnabledElement(element);\n}\n\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\n  const enabledElement = getEnabledElement(element);\n\n  const synchronizers = getSynchronizersForViewport(\n    enabledElement.viewportId,\n    enabledElement.renderingEngineId\n  );\n  synchronizers.forEach((sync) => {\n    sync.remove(enabledElement);\n  });\n};\n\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (toolGroup) {\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n  }\n};\n\nconst _removeAllToolsForElement = function (element) {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  toolsWithData.forEach(({ annotations }) => {\n    annotations.forEach((annotation) => {\n      removeAnnotation(annotation.annotationUID);\n    });\n  });\n};\n\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  delete state.svgNodeCache[elementHash];\n}\n\nfunction _removeSvgNode(element: HTMLDivElement) {\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n  const svgLayer = internalViewportNode.querySelector('svg');\n  if (svgLayer) {\n    internalViewportNode.removeChild(svgLayer);\n  }\n}\n\n/**\n * @private\n * @param enabledElement\n */\nconst _removeEnabledElement = function (element: HTMLDivElement) {\n  const foundElementIndex = state.enabledElements.findIndex(\n    (el) => el === element\n  );\n\n  if (foundElementIndex > -1) {\n    state.enabledElements.splice(foundElementIndex, 1);\n  }\n};\n\nexport default removeEnabledElement;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\n\n/**\n * Cancel the current active manipulation that is being performed on the provided\n * element. It filters all the active and passive tools for the enabledElement\n * and calls cancel() method for all of them, and returns the tool that has executed its\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\n * short circuit early. Note: not all tools currently implement a cancel method.\n *\n * @param element - canvas element\n * @returns annotationUID that is cancelled\n */\nexport default function cancelActiveManipulations(\n  element: HTMLDivElement\n): string | undefined {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  for (const { tool } of toolsWithData) {\n    const annotationUID = tool.cancel(element);\n    if (annotationUID) {\n      return annotationUID;\n    }\n  }\n}\n","import { IToolGroup, IToolClassReference } from '../types';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nimport cloneDeep from 'lodash.clonedeep';\n\ninterface ICornerstoneTools3dState {\n  isInteractingWithTool: boolean;\n  isMultiPartToolActive: boolean;\n  tools: Record<\n    string,\n    {\n      toolClass: IToolClassReference;\n    }\n  >;\n  toolGroups: Array<IToolGroup>;\n  synchronizers: Array<Synchronizer>;\n  svgNodeCache: Record<string, unknown>;\n  enabledElements: Array<unknown>;\n  handleRadius: number;\n}\n\nconst defaultState: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nlet state: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nfunction resetCornerstoneToolsState(): void {\n  resetSvgNodeCache();\n  state = {\n    ...cloneDeep({\n      ...defaultState,\n      svgNodeCache: {},\n    }),\n    svgNodeCache: {\n      ...defaultState.svgNodeCache,\n    },\n  };\n}\n\nexport {\n  ICornerstoneTools3dState,\n  resetCornerstoneToolsState,\n  state,\n  state as default,\n};\n","let svgNodeCache = {};\n\nexport function resetSvgNodeCache(): void {\n  svgNodeCache = {};\n}\n\nexport default svgNodeCache;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const scale = getCalibratedScale(image);\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: getCalibratedLengthUnits(null, image),\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats, label } = data;\n  const { length, width, unit } = cachedStats[targetId];\n\n  const textLines = [];\n  if (label) {\n    textLines.push(label);\n  }\n  if (length === undefined) {\n    return textLines;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  textLines.push(\n    `L: ${roundNumber(length)} ${unit}`,\n    `W: ${roundNumber(width)} ${unit}`\n  );\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { utilities } from '@cornerstonejs/core';\nimport type { PublicToolProps } from '../../types';\nimport type { AnnotationRenderContext } from '../../types';\nimport { PlanarFreehandContourSegmentationAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\n\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n          /**\n           * Allow open contours false means to not allow a final/complete\n           * annotation to be done as an open contour.  This does not mean\n           * that the contour won't be open during creation.\n           */\n          allowOpenContours: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by PlanarFreehandROITool\n    return true;\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const annotation =\n      renderContext.annotation as PlanarFreehandContourSegmentationAnnotation;\n    const { invalidated } = annotation;\n\n    // Render the annotation before triggering events\n    const renderResult = super.renderAnnotationInstance(renderContext);\n\n    if (invalidated) {\n      const { segmentationId } = annotation.data.segmentation;\n\n      // This event is trigged by ContourSegmentationBaseTool but PlanarFreehandROITool\n      // is the only contour class that does not call `renderAnnotationInstace` from\n      // its base class.\n      triggerSegmentationDataModified(segmentationId);\n    }\n\n    return renderResult;\n  }\n}\n\nPlanarFreehandContourSegmentationTool.toolName =\n  'PlanarFreehandContourSegmentationTool';\n\nexport default PlanarFreehandContourSegmentationTool;\n","import {\n  utilities,\n  getEnabledElement,\n  StackViewport,\n  cache,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationDisplayTool extends BaseTool {\n  static toolName;\n\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\n   * request animation frame\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  abstract renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  );\n\n  /**\n   * @virtual Given the element and annotations which is an array of annotation, it\n   * filters the annotations array to only include the annotation based on the viewportType.\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\n   * if the viewport is volumeViewport, it only returns those that are within the\n   * same slice as the current rendered slice in the volume viewport.\n   * imageId as the enabledElement.\n   * @param element - The HTML element\n   * @param annotations - The annotations to filter (array of annotation)\n   * @returns The filtered annotations\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    return filterAnnotationsForDisplay(viewport, annotations);\n  }\n\n  /**\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\n   * new position for the annotations in the space of the new imageData.\n   *\n   * @param evt - The calibration event\n   *\n   */\n  public onImageSpacingCalibrated = (\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\n  ) => {\n    const { element, imageId } = evt.detail;\n\n    const imageURI = utilities.imageIdToURI(imageId);\n    const annotationManager = getAnnotationManager();\n    const framesOfReference = annotationManager.getFramesOfReference();\n\n    // For each frame Of Reference\n    framesOfReference.forEach((frameOfReference) => {\n      const frameOfReferenceSpecificAnnotations =\n        annotationManager.getAnnotations(frameOfReference);\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\n\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n        return;\n      }\n\n      // for this specific tool\n      toolSpecificAnnotations.forEach((annotation) => {\n        if (!annotation.metadata?.referencedImageId) {\n          return;\n        }\n\n        // if the annotation is drawn on the same imageId\n        const referencedImageURI = utilities.imageIdToURI(\n          annotation.metadata.referencedImageId\n        );\n\n        if (referencedImageURI === imageURI) {\n          // make them invalid since the image has been calibrated so that\n          // we can update the cachedStats and also rendering\n          annotation.invalidated = true;\n          annotation.data.cachedStats = {};\n        }\n      });\n      triggerAnnotationRender(element);\n    });\n  };\n\n  protected getReferencedImageId(\n    viewport: Types.IViewport,\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else if (viewport instanceof VideoViewport) {\n      referencedImageId = targetId.split('videoId:')[1];\n    } else {\n      const volumeId = utilities.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = utilities.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    return referencedImageId;\n  }\n\n  /**\n   * It takes the property (color, lineDash, etc.) and based on the state of the\n   * annotation (selected, highlighted etc.) it returns the appropriate value\n   * based on the central toolStyle settings for each level of specification.\n   * @param property - The name of the style property to get.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns The value of the property.\n   */\n  public getStyle(\n    property: string,\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): unknown {\n    return getStyleProperty(\n      property,\n      specifications,\n      getState(annotation),\n      this.mode\n    );\n  }\n}\n\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import {\n  BaseVolumeViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  /**\n   * Creates a base annotation object, adding in any annotation base data provided\n   */\n  public static createAnnotation(...annotationBaseData): Annotation {\n    let annotation: Annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.toolName,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    } as unknown as Annotation;\n    for (const baseData of annotationBaseData) {\n      annotation = csUtils.deepMerge(annotation, baseData);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates a new annotation for the given viewport.  This just adds the\n   * viewport reference data to the metadata, and otherwise returns the\n   * static class createAnnotation data.\n   */\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\n    return this.createAnnotation(\n      { metadata: viewport.getViewReference() },\n      ...annotationBaseData\n    );\n  }\n\n  /**\n   * Creates and adds an annotation of the given type, firing the annotation\n   * modified event on the new annotation.\n   * This implicitly uses the static class when you call it on the correct\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\n   *\n   */\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\n    const annotation = this.createAnnotationForViewport(\n      viewport,\n      ...annotationBaseData\n    );\n    addAnnotation(annotation, viewport.element);\n    triggerAnnotationModified(annotation, viewport.element);\n  }\n\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { isCanvasAnnotation } = data;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points?.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = isCanvasAnnotation\n        ? point.slice(0, 2)\n        : viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(\n          canvasCoords,\n          annotationCanvasCoordinate as Types.Point2\n        ) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = csUtils.getVolumeId(targetId);\n      const volume = cache.getVolume(volumeId);\n      return volume.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Get the style that will be applied to all annotations such as length, cobb\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const { annotation, styleSpecifier } = context;\n    const getStyle = (property) =>\n      this.getStyle(property, styleSpecifier, annotation);\n    const { annotationUID } = annotation;\n    const visibility = isAnnotationVisible(annotationUID);\n    const locked = isAnnotationLocked(annotation);\n\n    const lineWidth = getStyle('lineWidth') as number;\n    const lineDash = getStyle('lineDash') as string;\n    const color = getStyle('color') as string;\n    const shadow = getStyle('shadow') as boolean;\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    return {\n      visibility,\n      locked,\n      color,\n      lineWidth,\n      lineDash,\n      lineOpacity: 1,\n      fillColor: color,\n      fillOpacity: 0,\n      shadow,\n      textbox: textboxStyle,\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { utilities, BaseVolumeViewport } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nimport StrategyCallbacks from '../../enums/StrategyCallbacks';\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\n\nexport interface IBaseTool {\n  /** ToolGroup ID the tool instance belongs to */\n  toolGroupId: string;\n  /** Tool supported interaction types */\n  supportedInteractionTypes: InteractionTypes[];\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\n  mode: ToolModes;\n  /** Tool Configuration */\n  configuration: {\n    preventHandleOutsideImage?: boolean;\n    strategies?: Record<string, any>;\n    defaultStrategy?: string;\n    activeStrategy?: string;\n    strategyOptions?: Record<string, unknown>;\n  };\n}\n\n/**\n * Abstract base class from which all tools derive.\n * Deals with cleanly merging custom and default configuration, and strategy\n * application.\n */\nabstract class BaseTool implements IBaseTool {\n  static toolName;\n  /** Supported Interaction Types - currently only Mouse */\n  public supportedInteractionTypes: InteractionTypes[];\n  public configuration: Record<string, any>;\n  /** ToolGroup ID the tool instance belongs to */\n  public toolGroupId: string;\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\n  public mode: ToolModes;\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n\n    const {\n      configuration = {},\n      supportedInteractionTypes,\n      toolGroupId,\n    } = initialProps;\n\n    // If strategies are not initialized in the tool config\n    if (!configuration.strategies) {\n      configuration.strategies = {};\n      configuration.defaultStrategy = undefined;\n      configuration.activeStrategy = undefined;\n      configuration.strategyOptions = {};\n    }\n\n    this.toolGroupId = toolGroupId;\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\n    this.configuration = Object.assign({}, configuration);\n    this.mode = ToolModes.Disabled;\n  }\n\n  /**\n   * Returns the name of the tool\n   * @returns The name of the tool.\n   */\n  public getToolName(): string {\n    // Since toolName is static we get it from the class constructor\n    return (<typeof BaseTool>this.constructor).toolName;\n  }\n\n  /**\n   * Applies the active strategy function to the enabled element with the specified\n   * operation data.\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategy(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * Applies the active strategy, with a given event type being applied.\n   * The event type function is found by indexing it on the active strategy\n   * function.\n   *\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @param callbackType - the type of the callback\n   *\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategyCallback(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown,\n    callbackType: StrategyCallbacks | string\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n\n    if (!strategies[activeStrategy]) {\n      throw new Error(\n        `applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`\n      );\n    }\n\n    return strategies[activeStrategy][callbackType]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * merges the new configuration with the tool configuration\n   * @param configuration - toolConfiguration\n   */\n  public setConfiguration(newConfiguration: Record<string, any>): void {\n    this.configuration = utilities.deepMerge(\n      this.configuration,\n      newConfiguration\n    );\n  }\n\n  /**\n   * Sets the active strategy for a tool. Strategies are\n   * multiple implementations of tool behavior that can be switched by tool\n   * configuration.\n   *\n   * @param strategyName - name of the strategy to be set as active\n   */\n  public setActiveStrategy(strategyName: string): void {\n    this.setConfiguration({ activeStrategy: strategyName });\n  }\n\n  /**\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\n   * from the volumeId if particularly specified in the tool configuration, or if\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\n   * can have multiple representations, use segmentation helpers to get the volumeId\n   * based on the actorUID.\n   *\n   * @param viewport - Volume viewport\n   * @returns the volumeId for the viewport if specified in the tool configuration,\n   * or the first actorUID in the viewport if not.\n   */\n  private getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n    if (this.configuration.volumeId) {\n      return this.configuration.volumeId;\n    }\n\n    // If volume not specified, then return the actorUID for the\n    // default actor - first actor\n    const actorEntries = viewport.getActors();\n\n    if (!actorEntries) {\n      return;\n    }\n\n    // find the first image actor of instance type vtkVolume\n    return actorEntries.find(\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n    )?.uid;\n  }\n\n  /**\n   * Get the image that is displayed for the targetId in the cachedStats\n   * which can be\n   * * imageId:<imageId>\n   * * volumeId:<volumeId>\n   * * videoId:<basePathForVideo>/frames/<frameSpecifier>\n   *\n   * @param targetId - annotation targetId stored in the cached stats\n   * @param renderingEngine - The rendering engine\n   * @returns The image data for the target.\n   */\n  protected getTargetIdImage(\n    targetId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\n    if (targetId.startsWith('imageId:')) {\n      const imageId = targetId.split('imageId:')[1];\n      const imageURI = utilities.imageIdToURI(imageId);\n      let viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      viewports = viewports.filter((viewport) => {\n        return viewport.getCurrentImageId() === imageId;\n      });\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('volumeId:')) {\n      const volumeId = utilities.getVolumeId(targetId);\n      const viewports = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('videoId:')) {\n      // Video id can be multi-valued for the frame information\n      const imageURI = utilities.imageIdToURI(targetId);\n      const viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else {\n      throw new Error(\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\n      );\n    }\n  }\n\n  /**\n   * Get the target Id for the viewport which will be used to store the cached\n   * statistics scoped to that target in the annotations.\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\n   * the targetId will be grabbed from the volumeId if particularly specified\n   * in the tool configuration, or if not, the first actorUID in the viewport.\n   *\n   * @param viewport - viewport to get the targetId for\n   * @returns targetId\n   */\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\n    const targetId = viewport.getReferenceId?.();\n    if (targetId) {\n      return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n  }\n}\n\n// Note: this is a workaround since terser plugin does not support static blocks\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\n\nimport {\n  cache,\n  getEnabledElementByIds,\n  StackViewport,\n  Types,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport type {\n  LabelmapConfig,\n  LabelmapRenderingConfig,\n  LabelmapSegmentationData,\n} from '../../../types/LabelmapTypes';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\nimport { polySeg } from '../../../stateManagement/segmentation';\n\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\n\nfunction getRepresentationRenderingConfig() {\n  const cfun = vtkColorTransferFunction.newInstance();\n  const ofun = vtkPiecewiseFunction.newInstance();\n  ofun.addPoint(0, 0);\n  return {\n    ofun,\n    cfun,\n  };\n}\n\nlet polySegConversionInProgress = false;\n\n/**\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\n * Initializes the global and viewport specific state for the segmentation in the\n * SegmentationStateManager.\n * @param toolGroup - the tool group that contains the viewports\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeLabelmapFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * Checks if a segmentation data have the same frameOfReference as the series\n * displayed in a given viewport\n * @param viewport\n * @param referencedVolumeId volume id of the segmentation reference series\n * @returns\n */\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\n  // if the referencedVolumeId is not defined, we acted as before to not break\n  // applications as referencedVolumeId is inserted in this change\n  // Can modify that in the future commits\n  if (!referencedVolumeId) {\n    return true;\n  }\n  const defaultActor = viewport.getDefaultActor();\n  if (!defaultActor) {\n    return false;\n  }\n  const { uid: defaultActorUID } = defaultActor;\n  const volume = cache.getVolume(defaultActorUID);\n\n  if (volume) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (\n      referencedVolume &&\n      volume.metadata.FrameOfReferenceUID ===\n        referencedVolume.metadata.FrameOfReferenceUID\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * It takes the enabled element, the segmentation Id, and the configuration, and\n * it sets the segmentation for the enabled element as a labelmap\n * @param enabledElement - The cornerstone enabled element\n * @param segmentationId - The id of the segmentation to be rendered.\n * @param configuration - The configuration object for the labelmap.\n */\nasync function render(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n    config: renderingConfig,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    console.warn('No segmentation found for segmentationId: ', segmentationId);\n    return;\n  }\n\n  let labelmapData = segmentation.representationData[Representations.Labelmap];\n\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\n\n  if (\n    !labelmapData &&\n    polySeg.canComputeRequestedRepresentation(segmentationRepresentationUID) &&\n    !polySegConversionInProgress\n  ) {\n    // meaning the requested segmentation representationUID does not have\n    // labelmap data, BUT we might be able to request a conversion from\n    // another representation to labelmap\n    // we need to check if we can request polySEG to convert the other\n    // underlying representations to Surface\n    polySegConversionInProgress = true;\n\n    labelmapData = await polySeg.computeAndAddLabelmapRepresentation(\n      segmentationId,\n      {\n        segmentationRepresentationUID,\n        viewport,\n      }\n    );\n\n    if (!labelmapData) {\n      throw new Error(\n        `No labelmap data found for segmentationId ${segmentationId}.`\n      );\n    }\n\n    polySegConversionInProgress = false;\n  }\n\n  if (!labelmapData) {\n    return;\n  }\n\n  if (isVolumeSegmentation(labelmapData, viewport)) {\n    if (viewport instanceof StackViewport) {\n      return;\n    }\n\n    const { volumeId: labelmapUID } = labelmapData;\n\n    const labelmap = cache.getVolume(labelmapUID);\n\n    if (!labelmap) {\n      throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n    }\n\n    if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  } else {\n    if (viewport instanceof VolumeViewport) {\n      return;\n    }\n\n    // stack segmentation\n    const imageId = viewport.getCurrentImageId();\n    const { imageIdReferenceMap } = labelmapData;\n\n    // if the stack labelmap is not built for the current imageId that is\n    // rendered at the viewport then return\n    if (!imageIdReferenceMap.has(imageId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  }\n\n  if (!actorEntry) {\n    return;\n  }\n\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\n\n  const renderInactiveSegmentations =\n    toolGroupConfig.renderInactiveSegmentations;\n\n  _setLabelmapColorAndOpacity(\n    viewport.id,\n    actorEntry,\n    cfun,\n    ofun,\n    colorLUTIndex,\n    toolGroupConfig.representations[Representations.Labelmap],\n    representation,\n    active,\n    renderInactiveSegmentations,\n    segmentsHidden\n  );\n}\n\nfunction _setLabelmapColorAndOpacity(\n  viewportId: string,\n  actorEntry: Types.ActorEntry,\n  cfun: vtkColorTransferFunction,\n  ofun: vtkPiecewiseFunction,\n  colorLUTIndex: number,\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  isActiveLabelmap: boolean,\n  renderInactiveSegmentations: boolean,\n  segmentsHidden: Set<number>\n): void {\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\n    segmentationRepresentation;\n\n  const segmentationRepresentationLabelmapConfig =\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\n\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\n  // the default color table uses RGB.\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  const numColors = Math.min(256, colorLUT.length);\n  const { uid: actorUID } = actorEntry;\n\n  // Note: right now outlineWidth and renderOutline are not configurable\n  // at the segment level, so we don't need to check for segment specific\n  // configuration in the loop, Todo: make them configurable at the segment level\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\n    toolGroupLabelmapConfig,\n    segmentationRepresentationLabelmapConfig,\n    isActiveLabelmap\n  );\n\n  // Todo: the below loop probably can be optimized so that we don't hit it\n  // unless a config has changed. Right now we get into the following loop\n  // even for brush drawing which does not makes sense\n  for (let i = 0; i < numColors; i++) {\n    const segmentIndex = i;\n    const segmentColor = colorLUT[segmentIndex];\n\n    const segmentSpecificLabelmapConfig =\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\n      _getLabelmapConfig(\n        toolGroupLabelmapConfig,\n        segmentationRepresentationLabelmapConfig,\n        isActiveLabelmap,\n        segmentSpecificLabelmapConfig\n      );\n\n    const { forceOpacityUpdate, forceColorUpdate } =\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        segmentColor,\n        outlineWidth,\n        segmentsHidden,\n      });\n\n    if (forceColorUpdate) {\n      cfun.addRGBPoint(\n        segmentIndex,\n        segmentColor[0] / MAX_NUMBER_COLORS,\n        segmentColor[1] / MAX_NUMBER_COLORS,\n        segmentColor[2] / MAX_NUMBER_COLORS\n      );\n    }\n\n    if (forceOpacityUpdate) {\n      if (renderFill) {\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\n          ? 0\n          : (segmentColor[3] / 255) * fillAlpha;\n\n        ofun.removePoint(segmentIndex);\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n      } else {\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n      }\n    }\n  }\n\n  const actor = actorEntry.actor as Types.VolumeActor;\n\n  actor.getProperty().setRGBTransferFunction(0, cfun);\n\n  ofun.setClamping(false);\n\n  actor.getProperty().setScalarOpacity(0, ofun);\n  actor.getProperty().setInterpolationTypeToNearest();\n  actor.getProperty().setUseLabelOutline(renderOutline);\n\n  // @ts-ignore - fix type in vtk\n  actor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n\n  const { activeSegmentIndex } = SegmentationState.getSegmentation(\n    segmentationRepresentation.segmentationId\n  );\n\n  // create an array that contains all the segment indices and for the active\n  // segment index, use the activeSegmentOutlineWidthDelta, otherwise use the\n  // outlineWidth\n  // Pre-allocate the array with the required size to avoid dynamic resizing.\n  const outlineWidths = new Array(numColors - 1);\n\n  for (let i = 1; i < numColors; i++) {\n    // Start from 1 to skip the background segment index.\n    const isHidden = segmentsHidden.has(i);\n\n    if (isHidden) {\n      outlineWidths[i - 1] = 0;\n      continue;\n    }\n\n    outlineWidths[i - 1] =\n      i === activeSegmentIndex\n        ? outlineWidth + toolGroupLabelmapConfig.activeSegmentOutlineWidthDelta\n        : outlineWidth;\n  }\n\n  actor.getProperty().setLabelOutlineThickness(outlineWidths);\n\n  // Set visibility based on whether actor visibility is specifically asked\n  // to be turned on/off (on by default) AND whether is is in active but\n  // we are rendering inactive labelmap\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\n  actor.setVisibility(visible);\n}\n\nfunction _getLabelmapConfig(\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\n  isActiveLabelmap: boolean,\n  segmentsLabelmapConfig?: LabelmapConfig\n) {\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n\n  const configToUse = {\n    ...toolGroupLabelmapConfig,\n    ...segmentationRepresentationLabelmapConfig,\n    ...segmentLabelmapConfig,\n  };\n\n  const fillAlpha = isActiveLabelmap\n    ? configToUse.fillAlpha\n    : configToUse.fillAlphaInactive;\n  const outlineWidth = isActiveLabelmap\n    ? configToUse.outlineWidthActive\n    : configToUse.outlineWidthInactive;\n\n  const renderFill = isActiveLabelmap\n    ? configToUse.renderFill\n    : configToUse.renderFillInactive;\n\n  const renderOutline = configToUse.renderOutline;\n\n  const outlineOpacity = isActiveLabelmap\n    ? configToUse.outlineOpacity\n    : configToUse.outlineOpacityInactive;\n\n  return {\n    fillAlpha,\n    outlineWidth,\n    renderFill,\n    renderOutline,\n    outlineOpacity,\n  };\n}\n\nfunction _needsTransferFunctionUpdate(\n  viewportId: string,\n  actorUID: string,\n  segmentIndex: number,\n  {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    segmentColor,\n    outlineWidth,\n    segmentsHidden,\n  }: {\n    fillAlpha: number;\n    renderFill: boolean;\n    renderOutline: boolean;\n    outlineWidth: number;\n    segmentColor: number[];\n    segmentsHidden: Set<number>;\n  }\n) {\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n  const oldConfig = labelMapConfigCache.get(cacheUID);\n\n  if (!oldConfig) {\n    labelMapConfigCache.set(cacheUID, {\n      fillAlpha,\n      renderFill,\n      renderOutline,\n      outlineWidth,\n      segmentColor: segmentColor.slice(), // Create a copy\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\n    });\n\n    return {\n      forceOpacityUpdate: true,\n      forceColorUpdate: true,\n    };\n  }\n\n  const {\n    fillAlpha: oldFillAlpha,\n    renderFill: oldRenderFill,\n    renderOutline: oldRenderOutline,\n    outlineWidth: oldOutlineWidth,\n    segmentColor: oldSegmentColor,\n    segmentsHidden: oldSegmentsHidden,\n  } = oldConfig;\n\n  const forceColorUpdate =\n    oldSegmentColor[0] !== segmentColor[0] ||\n    oldSegmentColor[1] !== segmentColor[1] ||\n    oldSegmentColor[2] !== segmentColor[2];\n\n  const forceOpacityUpdate =\n    oldSegmentColor[3] !== segmentColor[3] ||\n    oldFillAlpha !== fillAlpha ||\n    oldRenderFill !== renderFill ||\n    oldRenderOutline !== renderOutline ||\n    oldOutlineWidth !== outlineWidth ||\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n\n  // update the cache\n  labelMapConfigCache.set(cacheUID, {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    outlineWidth,\n    segmentColor: segmentColor.slice(), // Create a copy\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\n  });\n\n  return {\n    forceOpacityUpdate,\n    forceColorUpdate,\n  };\n}\n\nfunction _removeLabelmapFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeLabelmapFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nasync function _addLabelmapToViewport(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  labelmapData: LabelmapSegmentationData,\n  segmentationRepresentationUID\n): Promise<void> {\n  await addLabelmapToElement(\n    viewport.element,\n    labelmapData,\n    segmentationRepresentationUID\n  );\n}\n\nexport default {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n\nexport {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass PanTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\n\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { BaseTool } from './base';\n\n/**\n * Tool that rotates the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass TrackballRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  cleanUp: () => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        rotateIncrementDegrees: 2,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actorEntry = viewport.getDefaultActor();\n    const actor = actorEntry.actor as Types.VolumeActor;\n    const mapper = actor.getMapper();\n    const originalSampleDistance = mapper.getSampleDistance();\n\n    mapper.setSampleDistance(originalSampleDistance * 2);\n\n    if (this.cleanUp !== null) {\n      // Clean up previous event listener\n      document.removeEventListener('mouseup', this.cleanUp);\n    }\n\n    this.cleanUp = () => {\n      mapper.setSampleDistance(originalSampleDistance);\n      viewport.render();\n    };\n\n    document.addEventListener('mouseup', this.cleanUp, { once: true });\n    return true;\n  };\n\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\n    const vtkCamera = viewport.getVtkActiveCamera();\n    const viewUp = vtkCamera.getViewUp();\n    const focalPoint = vtkCamera.getFocalPoint();\n    const position = vtkCamera.getPosition();\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, centerWorld);\n    mat4.rotate(transform, transform, angle, axis);\n    mat4.translate(transform, transform, [\n      -centerWorld[0],\n      -centerWorld[1],\n      -centerWorld[2],\n    ]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, axis);\n    vec3.transformMat4(newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n  };\n\n  // pseudocode inspired from\n  // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\n    const { element, currentPoints, lastPoints } = evt.detail;\n    const currentPointsCanvas = currentPoints.canvas;\n    const lastPointsCanvas = lastPoints.canvas;\n    const { rotateIncrementDegrees } = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const normalizedPosition = [\n      currentPointsCanvas[0] / width,\n      currentPointsCanvas[1] / height,\n    ];\n\n    const normalizedPreviousPosition = [\n      lastPointsCanvas[0] / width,\n      lastPointsCanvas[1] / height,\n    ];\n\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\n    const centerWorld = viewport.canvasToWorld(center);\n    const normalizedCenter = [0.5, 0.5];\n\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition[0], 0, 0];\n    const oe = [normalizedPosition[0], 0, 0];\n\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n\n    const nop: Types.Point3 = [op[0], 0, lop];\n    vtkMath.normalize(nop);\n    const noe: Types.Point3 = [oe[0], 0, loe];\n    vtkMath.normalize(noe);\n\n    const dot = vtkMath.dot(nop, noe);\n    if (Math.abs(dot) > 0.0001) {\n      const angleX =\n        -2 *\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n        rotateIncrementDegrees;\n\n      const upVec = camera.viewUp;\n      const atV = camera.viewPlaneNormal;\n      const rightV: Types.Point3 = [0, 0, 0];\n      const forwardV: Types.Point3 = [0, 0, 0];\n\n      vtkMath.cross(upVec, atV, rightV);\n      vtkMath.normalize(rightV);\n\n      vtkMath.cross(atV, rightV, forwardV);\n      vtkMath.normalize(forwardV);\n      vtkMath.normalize(upVec);\n\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n\n      const angleY =\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n        rotateIncrementDegrees;\n\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\n\n      viewport.render();\n    }\n  }\n}\n\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import { BaseTool } from './base';\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  cache,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\nimport { EventTypes } from '../types';\n\n// Todo: should move to configuration\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\n\n/**\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image.\n *\n */\nclass WindowLevelTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this.mouseDragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    let volumeId,\n      lower,\n      upper,\n      modality,\n      newRange,\n      viewportsContainingVolumeUID;\n    let isPreScaled = false;\n\n    const properties = viewport.getProperties();\n    if (viewport instanceof VolumeViewport) {\n      const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n      volumeId = utilities.getVolumeId(targetId);\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n      ({ lower, upper } = properties.voiRange);\n      const volume = cache.getVolume(volumeId);\n      if (!volume) {\n        throw new Error('Volume not found ' + volumeId);\n      }\n      modality = volume.metadata.Modality;\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n    } else if (properties.voiRange) {\n      modality = (viewport as any).modality;\n      ({ lower, upper } = properties.voiRange);\n      const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n      isPreScaled =\n        preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n\n    // If modality is PT an the viewport is pre-scaled (SUV),\n    // treat it special to not include the canvas delta in\n    // the x direction. For other modalities, use the canvas delta in both\n    // directions, and if the viewport is a volumeViewport, the multiplier\n    // is calculate using the volume min and max.\n    if (modality === PT && isPreScaled) {\n      newRange = this.getPTScaledNewRange({\n        deltaPointsCanvas: deltaPoints.canvas,\n        lower,\n        upper,\n        clientHeight: element.clientHeight,\n        isPreScaled,\n        viewport,\n        volumeId,\n      });\n    } else {\n      newRange = this.getNewRange({\n        viewport,\n        deltaPointsCanvas: deltaPoints.canvas,\n        volumeId,\n        lower,\n        upper,\n      });\n    }\n\n    // If the range is not valid. Do nothing\n    if (newRange.lower >= newRange.upper) {\n      return;\n    }\n\n    viewport.setProperties({\n      voiRange: newRange,\n    });\n\n    viewport.render();\n\n    if (viewport instanceof VolumeViewport) {\n      viewportsContainingVolumeUID.forEach((vp) => {\n        if (viewport !== vp) {\n          vp.render();\n        }\n      });\n      return;\n    }\n  }\n\n  getPTScaledNewRange({\n    deltaPointsCanvas,\n    lower,\n    upper,\n    clientHeight,\n    viewport,\n    volumeId,\n    isPreScaled,\n  }) {\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (isPreScaled) {\n      multiplier = 5 / clientHeight;\n    } else {\n      multiplier =\n        this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n        DEFAULT_MULTIPLIER;\n    }\n\n    const deltaY = deltaPointsCanvas[1];\n    const wcDelta = deltaY * multiplier;\n\n    upper -= wcDelta;\n    upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n\n    return { lower, upper };\n  }\n\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n    const multiplier =\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n      DEFAULT_MULTIPLIER;\n\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\n\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n      lower,\n      upper\n    );\n\n    windowWidth += wwDelta;\n    windowCenter += wcDelta;\n\n    windowWidth = Math.max(windowWidth, 1);\n\n    // Convert back to range\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n  }\n\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\n    let imageDynamicRange;\n\n    if (volumeId) {\n      const imageVolume = cache.getVolume(volumeId);\n      const { dimensions } = imageVolume;\n      const scalarData = imageVolume.getScalarData();\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\n        scalarData,\n        dimensions\n      );\n      const BitsStored = imageVolume?.metadata?.BitsStored;\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n      // Burned in Pixels often use pixel values above the BitsStored.\n      // This results in a multiplier which is way higher than what you would\n      // want in practice. Thus we take the min between the metadata dynamic\n      // range and actual middel slice dynamic range.\n      imageDynamicRange = Math.min(\n        calculatedDynamicRange,\n        metadataDynamicRange\n      );\n    } else {\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n    }\n\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n\n    return ratio > 1 ? Math.round(ratio) : ratio;\n  }\n\n  _getImageDynamicRangeFromViewport(viewport) {\n    const { imageData } = viewport.getImageData();\n    const dimensions = imageData.getDimensions();\n\n    if (imageData.getRange) {\n      const imageDataRange = imageData.getRange();\n      return imageDataRange[1] - imageDataRange[0];\n    }\n    let scalarData;\n    // if getScalarData is a method on imageData\n    if (imageData.getScalarData) {\n      scalarData = imageData.getScalarData();\n    } else {\n      scalarData = imageData.getPointData().getScalars();\n    }\n\n    if (dimensions[2] !== 1) {\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n    }\n\n    let range;\n    if (scalarData.getRange) {\n      range = scalarData.getRange();\n    } else {\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\n      range = [min, max];\n    }\n\n    return range[1] - range[0];\n  }\n\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\n\n    const frameLength = dimensions[0] * dimensions[1];\n    let bytesPerVoxel;\n    let TypedArrayConstructor;\n\n    if (scalarData instanceof Float32Array) {\n      bytesPerVoxel = 4;\n      TypedArrayConstructor = Float32Array;\n    } else if (scalarData instanceof Uint8Array) {\n      bytesPerVoxel = 1;\n      TypedArrayConstructor = Uint8Array;\n    } else if (scalarData instanceof Uint16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Uint16Array;\n    } else if (scalarData instanceof Int16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Int16Array;\n    }\n\n    const buffer = scalarData.buffer;\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n\n    const { max, min } = this._getMinMax(frame, frameLength);\n\n    return max - min;\n  };\n\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\n    let min = Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < frameLength; i++) {\n      const voxel = frame[i];\n\n      if (voxel < min) {\n        min = voxel;\n      }\n\n      if (voxel > max) {\n        max = voxel;\n      }\n    }\n    return { max, min };\n  }\n}\n\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { getEnabledElementByIds, VolumeViewport } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The StackScrollTool is a tool that allows the user to scroll through a\n * stack of images by pressing the mouse click and dragging\n */\nclass StackScrollTool extends BaseTool {\n  static toolName;\n  deltaY: number;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.deltaY = 1;\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n\n    const targetId = this.getTargetId(viewport);\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\n\n    const deltaPointY = deltaPoints.canvas[1];\n    let volumeId;\n    if (viewport instanceof VolumeViewport) {\n      volumeId = targetId.split(/volumeId:|\\?/)[1];\n    }\n\n    const pixelsPerImage = this._getPixelPerImage(viewport);\n    const deltaY = deltaPointY + this.deltaY;\n\n    if (!pixelsPerImage) {\n      return;\n    }\n\n    if (Math.abs(deltaY) >= pixelsPerImage) {\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n\n      scroll(viewport, {\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n        volumeId,\n        debounceLoading: debounceIfNotLoaded,\n        loop: loop,\n      });\n\n      this.deltaY = deltaY % pixelsPerImage;\n    } else {\n      this.deltaY = deltaY;\n    }\n  }\n\n  _getPixelPerImage(viewport) {\n    const { element } = viewport;\n    const numberOfSlices = viewport.getNumberOfSlices();\n\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n  }\n}\n\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Types,\n} from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The PlanarRotateTool is a tool that allows the user to rotate\n * the image by pressing the mouse click and dragging\n */\nclass PlanarRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\n    const { element, currentPoints, startPoints } = evt.detail;\n    const currentPointWorld = currentPoints.world;\n    const startPointWorld = startPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\n\n    let angle = angleBetweenLines(\n      [startPointWorld, centerWorld],\n      [centerWorld, currentPointWorld]\n    );\n\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n    const cross = vec3.cross(vec3.create(), v1, v2);\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\n      angle = -angle;\n    }\n\n    if (Number.isNaN(angle)) {\n      return;\n    }\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const rotAngle = (angle * Math.PI) / 180;\n      const rotMat = mat4.identity(new Float32Array(16));\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\n    } else {\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\n      viewport.setProperties({ rotation: rotation + angle });\n    }\n\n    viewport.render();\n  }\n}\n\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { MouseWheelEventType } from '../types/EventTypes';\nimport scroll from '../utilities/scroll';\n\n/**\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\n * stack of images using the mouse wheel\n */\nclass StackScrollMouseWheelTool extends BaseTool {\n  static toolName;\n\n  _configuration: any;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n        scrollSlabs: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType): void {\n    const { wheel, element } = evt.detail;\n    const { direction } = wheel;\n    const { invert } = this.configuration;\n    const { viewport } = getEnabledElement(element);\n    const delta = direction * (invert ? -1 : 1);\n\n    const targetId = this.getTargetId(viewport);\n    const volumeId = utilities.getVolumeId(targetId);\n\n    scroll(viewport, {\n      delta,\n      debounceLoading: this.configuration.debounceIfNotLoaded,\n      loop: this.configuration.loop,\n      volumeId,\n      scrollSlabs: this.configuration.scrollSlabs,\n    });\n  }\n}\n\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\n *\n */\nclass ZoomTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  initialMousePosWorld: Types.Point3;\n  dirVec: Types.Point3;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // whether zoom to the center of the image OR zoom to the mouse position\n        zoomToCenter: false,\n        minZoomScale: 0.1,\n        maxZoomScale: 30,\n        pinchToZoom: true,\n        pan: true,\n        invert: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.initialMousePosWorld = [0, 0, 0];\n    this.dirVec = [0, 0, 0];\n    if (this.configuration.pinchToZoom) {\n      this.touchDragCallback = this._pinchCallback.bind(this);\n    } else {\n      this.touchDragCallback = this._dragCallback.bind(this);\n    }\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint } = camera;\n\n    this.initialMousePosWorld = worldPos;\n\n    // The direction vector from the clicked location to the focal point\n    // which would act as the vector to translate the image (if zoomToCenter is false)\n    let dirVec = vec3.fromValues(\n      focalPoint[0] - worldPos[0],\n      focalPoint[1] - worldPos[1],\n      focalPoint[2] - worldPos[2]\n    );\n\n    dirVec = vec3.normalize(vec3.create(), dirVec);\n\n    this.dirVec = dirVec as Types.Point3;\n\n    // we should not return true here, returning true in the preMouseDownCallback\n    // means that the event is handled by the tool and no other methods\n    // can claim the event, which will result in a bug where having Zoom on primary\n    // and clicking on an annotation will not manipulate the annotation, but will\n    // instead zoom the image (which is not what we want), so we return false here\n    return false;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (!this.configuration.pinchToZoom) {\n      return this.preMouseDownCallback(evt);\n    }\n  };\n\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\n      .currentPointsList;\n\n    if (pointsList.length > 1) {\n      const { element, currentPoints } = evt.detail;\n      const enabledElement = getEnabledElement(element);\n      const { viewport } = enabledElement;\n      const camera = viewport.getCamera();\n      const worldPos = currentPoints.world;\n      const { focalPoint } = camera;\n      this.initialMousePosWorld = worldPos;\n      // The direction vector from the clicked location to the focal point\n      // which would act as the vector to translate the image (if zoomToCenter is false)\n      let dirVec = vec3.fromValues(\n        focalPoint[0] - worldPos[0],\n        focalPoint[1] - worldPos[1],\n        focalPoint[2] - worldPos[2]\n      );\n      dirVec = vec3.normalize(vec3.create(), dirVec);\n\n      this.dirVec = dirVec as Types.Point3;\n      if (camera.parallelProjection) {\n        this._dragParallelProjection(evt, viewport, camera, true);\n      } else {\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\n      }\n      viewport.render();\n    }\n\n    if (this.configuration.pan) {\n      this._panCallback(evt);\n    }\n  }\n\n  // Takes ICornerstoneEvent, Mouse or Touch\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n\n    if (camera.parallelProjection) {\n      this._dragParallelProjection(evt, viewport, camera);\n    } else {\n      this._dragPerspectiveProjection(evt, viewport, camera);\n    }\n\n    viewport.render();\n  }\n\n  _dragParallelProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { parallelScale, focalPoint, position } = camera;\n\n    const zoomScale = 5 / size[1];\n    const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n\n    const parallelScaleToSet = (1.0 - k) * parallelScale;\n\n    let focalPointToSet = focalPoint;\n    let positionToSet = position;\n\n    // if we're not zooming to the center, we need to adjust the focal point\n    // and position to set the focal point and position to the value that\n    // would simulate the zoom to the mouse position\n    if (!this.configuration.zoomToCenter) {\n      // Distance of the initial mouse position (world) to the focal point\n      // which is always the center of the canvas.\n      const distanceToCanvasCenter = vec3.distance(\n        focalPoint,\n        this.initialMousePosWorld\n      );\n\n      positionToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        position,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n\n      focalPointToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        focalPoint,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n    }\n\n    // If it is a regular GPU accelerated viewport, then parallel scale\n    // has a physical meaning and we can use that to determine the threshold\n    // Added spacing preset in case there is no imageData on viewport\n    const imageData = viewport.getImageData();\n    let spacing = [1, 1, 1];\n    if (imageData) {\n      spacing = imageData.spacing;\n    }\n\n    const { minZoomScale, maxZoomScale } = this.configuration;\n\n    const t = element.clientHeight * spacing[1] * 0.5;\n    const scale = t / parallelScaleToSet;\n\n    let cappedParallelScale = parallelScaleToSet;\n    let thresholdExceeded = false;\n\n    if (imageData) {\n      if (scale < minZoomScale) {\n        cappedParallelScale = t / minZoomScale;\n        thresholdExceeded = true;\n      } else if (scale >= maxZoomScale) {\n        cappedParallelScale = t / maxZoomScale;\n        thresholdExceeded = true;\n      }\n    }\n\n    viewport.setCamera({\n      parallelScale: cappedParallelScale,\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n      position: thresholdExceeded ? position : positionToSet,\n    });\n  };\n\n  _dragPerspectiveProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { position, focalPoint, viewPlaneNormal } = camera;\n\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n    const zoomScale = Math.sqrt(distance) / size[1];\n\n    const directionOfProjection = [\n      -viewPlaneNormal[0],\n      -viewPlaneNormal[1],\n      -viewPlaneNormal[2],\n    ];\n\n    const k = this.configuration.invert\n      ? deltaY / zoomScale\n      : deltaY * zoomScale;\n\n    let tmp = k * directionOfProjection[0];\n    position[0] += tmp;\n    focalPoint[0] += tmp;\n\n    tmp = k * directionOfProjection[1];\n    position[1] += tmp;\n    focalPoint[1] += tmp;\n\n    tmp = k * directionOfProjection[2];\n    position[2] += tmp;\n    focalPoint[2] += tmp;\n\n    viewport.setCamera({ position, focalPoint });\n  };\n\n  _panCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { mat4, vec3 } from 'gl-matrix';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { MouseWheelEventType } from '../types/EventTypes';\n\nconst DIRECTIONS = {\n  X: [1, 0, 0],\n  Y: [0, 1, 0],\n  Z: [0, 0, 1],\n  CUSTOM: [],\n};\n\n/**\n * Tool that rotates the camera on mouse wheel.\n * It rotates the camera around the focal point, and around a defined axis. Default\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\n *\n */\nclass VolumeRotateMouseWheelTool extends BaseTool {\n  static toolName;\n  _configuration: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        direction: DIRECTIONS.Z,\n        rotateIncrementDegrees: 30,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType) {\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\n    const { element, wheel } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { direction, rotateIncrementDegrees } = this.configuration;\n\n    const camera = viewport.getCamera();\n    const { viewUp, position, focalPoint } = camera;\n\n    const { direction: deltaY } = wheel;\n\n    const [cx, cy, cz] = focalPoint;\n    const [ax, ay, az] = direction;\n\n    //Calculate angle in radian as glmatrix rotate is in radian\n    const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n\n    // position[3] = 1.0\n    // focalPoint[3] = 1.0\n    // viewUp[3] = 0.0\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n\n    viewport.render();\n  }\n}\n\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { type Types, utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\n\n/**\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\n * tool configuration) will be scrolled (jumped) to the location of the point with\n * the highest intensity value in the MIP.\n */\nclass MIPJumpToClickTool extends BaseTool {\n  static toolName;\n\n  _bounds: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        targetViewportIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Handles the click event, and move the camera's focal point the brightest\n   * point that is in the line of sight of camera. This function 1) search for the\n   * brightest point in the line of sight, 2) move the camera to that point,\n   * this triggers a cameraModified event which then 4) moves all other synced\n   * viewports and their crosshairs.\n   *\n   * @param evt - click event\n   */\n  mouseClickCallback(evt): void {\n    const { element, currentPoints } = evt.detail;\n\n    // 1. Getting the enabled element\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    // 2. Getting the target volume that is clicked on\n    const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n\n    if (!targetId.startsWith('volumeId')) {\n      throw new Error(\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\n      );\n    }\n\n    const volumeId = utilities.getVolumeId(targetId);\n\n    // 3. Criteria function to search for the point (maximum intensity)\n    let maxIntensity = -Infinity;\n    const maxFn = (intensity, point) => {\n      if (intensity > maxIntensity) {\n        maxIntensity = intensity;\n        return point;\n      }\n    };\n\n    // 4. Search for the brightest point location in the line of sight\n    const brightestPoint = getPointInLineOfSightWithCriteria(\n      viewport as Types.IVolumeViewport,\n      currentPoints.world,\n      volumeId,\n      maxFn\n    );\n\n    if (!brightestPoint || !brightestPoint.length) {\n      return;\n    }\n\n    const { targetViewportIds, toolGroupId } = this.configuration;\n    // TODO - consider making this a utility\n    const viewports = renderingEngine.getViewports().filter((vp) => {\n      if (targetViewportIds?.indexOf(vp.id) >= 0) {\n        return true;\n      }\n      const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n      if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n        return true;\n      }\n      return false;\n    });\n\n    // 6. Update all the targetedViewports to jump\n    viewports.forEach((viewport) => {\n      // Todo: current limitation is that we cannot jump in viewports\n      // that don't belong to the renderingEngine of the source clicked viewport\n      if (viewport instanceof VolumeViewport) {\n        jumpToWorld(viewport, brightestPoint);\n      } else {\n        console.warn(\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\n        );\n      }\n    });\n  }\n}\n\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\n\nimport { AnnotationTool } from './base';\n\nimport {\n  getEnabledElementByIds,\n  getEnabledElement,\n  utilities as csUtils,\n  Enums,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../store/ToolGroupManager';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\n\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\n\nimport * as lineSegment from '../utilities/math/line';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../types';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { RENDERING_DEFAULTS } = CONSTANTS;\n\n// TODO: nested config is weird\ninterface ToolConfiguration {\n  configuration?: {\n    getReferenceLineColor?: (viewportId: string) => string;\n    getReferenceLineControllable?: (viewportId: string) => boolean;\n    getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n    getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n    referenceLinesCenterGapRadius?: number;\n    shadow?: boolean;\n    autopan?: {\n      enabled: boolean;\n      panSize: number;\n    };\n    mobile?: {\n      enabled: boolean;\n      opacity: number;\n      handleRadius: number;\n    };\n  };\n}\n\ninterface CrosshairsAnnotation extends Annotation {\n  data: {\n    handles: {\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\n      toolCenter: Types.Point3;\n    };\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\n    viewportId: string;\n  };\n}\n\nfunction defaultReferenceLineColor() {\n  return 'rgb(0, 200, 0)';\n}\n\nfunction defaultReferenceLineControllable() {\n  return true;\n}\n\nfunction defaultReferenceLineDraggableRotatable() {\n  return true;\n}\n\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n  return true;\n}\n\nconst OPERATION = {\n  DRAG: 1,\n  ROTATE: 2,\n  SLAB: 3,\n};\n\nconst EPSILON = 1e-3;\n\n/**\n * CrosshairsTool is a tool that provides reference lines between different viewports\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\n * Crosshairs have grababble handles that can be used to rotate and translate the\n * reference lines. They can also be used to set the slab thickness of the viewports\n * by modifying the slab thickness handles.\n *\n */\nclass CrosshairsTool extends AnnotationTool {\n  static toolName;\n\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\n  _getReferenceLineColor?: (viewportId: string) => string;\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n  editData: {\n    annotation: any;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse'],\n      configuration: {\n        shadow: true,\n        // renders a colored circle on top right of the viewports whose color\n        // matches the color of the reference line\n        viewportIndicators: true,\n        // Auto pan is a configuration which will update pan\n        // other viewports in the toolGroup if the center of the crosshairs\n        // is outside of the viewport. This might be useful for the case\n        // when the user is scrolling through an image (usually in the zoomed view)\n        // and the crosshairs will eventually get outside of the viewport for\n        // the other viewports.\n        autoPan: {\n          enabled: false,\n          panSize: 10,\n        },\n        // radius of the area around the intersection of the planes, in which\n        // the reference lines will not be rendered. This is only used when\n        // having 3 viewports in the toolGroup.\n        referenceLinesCenterGapRadius: 20,\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\n        // will be applied to all actors of the viewport\n        filterActorUIDsToSetSlabThickness: [],\n        // blend mode for slabThickness modifications\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        mobile: {\n          enabled: false,\n          opacity: 0.8,\n          handleRadius: 9,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._getReferenceLineColor =\n      toolProps.configuration?.getReferenceLineColor ||\n      defaultReferenceLineColor;\n    this._getReferenceLineControllable =\n      toolProps.configuration?.getReferenceLineControllable ||\n      defaultReferenceLineControllable;\n    this._getReferenceLineDraggableRotatable =\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\n      defaultReferenceLineDraggableRotatable;\n    this._getReferenceLineSlabThicknessControlsOn =\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n      defaultReferenceLineSlabThicknessControlsOn;\n  }\n\n  /**\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\n   * to the annotationManager. If any annotation is found in the annotationManager, it\n   * overwrites it.\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\n   * @returns viewPlaneNormal and center of viewport canvas in world space\n   */\n  initializeViewport = ({\n    renderingEngineId,\n    viewportId,\n  }: Types.IViewportId): {\n    normal: Types.Point3;\n    point: Types.Point3;\n  } => {\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    const { FrameOfReferenceUID, viewport } = enabledElement;\n    const { element } = viewport;\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n\n    // Check if there is already annotation for this viewport\n    let annotations = this._getAnnotations(enabledElement);\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (annotations.length) {\n      // If found, it will override it by removing the annotation and adding it later\n      removeAnnotation(annotations[0].annotationUID);\n    }\n\n    const annotation = {\n      highlighted: false,\n      metadata: {\n        cameraPosition: <Types.Point3>[...position],\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\n        FrameOfReferenceUID,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          rotationPoints: [], // rotation handles, used for rotation interactions\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\n          toolCenter: this.toolCenter,\n        },\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\n        viewportId,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    return {\n      normal: viewPlaneNormal,\n      point: viewport.canvasToWorld([\n        viewport.canvas.clientWidth / 2,\n        viewport.canvas.clientHeight / 2,\n      ]),\n    };\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  onSetToolActive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    // Upon new setVolumes on viewports we need to update the crosshairs\n    // reference points in the new space, so we subscribe to the event\n    // and update the reference points accordingly.\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolPassive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolEnabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolDisabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n\n    // Crosshairs annotations in the state\n    // has no value when the tool is disabled\n    // since viewports can change (zoom, pan, scroll)\n    // between disabled and enabled/active states.\n    // so we just remove the annotations from the state\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const annotations = this._getAnnotations(enabledElement);\n\n      if (annotations?.length) {\n        annotations.forEach((annotation) => {\n          removeAnnotation(annotation.annotationUID);\n        });\n      }\n    });\n  }\n\n  resetCrosshairs = () => {\n    const viewportsInfo = this._getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { viewport } = enabledElement;\n      const { element } = viewport;\n      let annotations = this._getAnnotations(enabledElement);\n      annotations = this.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n      if (annotations.length) {\n        removeAnnotation(annotations[0].annotationUID);\n      }\n    });\n\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  /**\n   * When activated, it initializes the crosshairs. It begins by computing\n   * the intersection of viewports associated with the crosshairs instance.\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\n   * will be an exact point in space; however, with two viewports, because the\n   * intersection of two planes is a line, it assumes the last view is between the centre\n   * of the two rendering viewports.\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\n   */\n  computeToolCenter = (viewportsInfo): void => {\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\n      console.warn(\n        'For crosshairs to operate, at least two viewports must be given.'\n      );\n      return;\n    }\n\n    // Todo: handle two same view viewport, or more than 3 viewports\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n\n    // Initialize first viewport\n    const { normal: normal1, point: point1 } =\n      this.initializeViewport(firstViewport);\n\n    // Initialize second viewport\n    const { normal: normal2, point: point2 } =\n      this.initializeViewport(secondViewport);\n\n    let normal3 = <Types.Point3>[0, 0, 0];\n    let point3 = vec3.create();\n\n    // If there are three viewports\n    if (thirdViewport) {\n      ({ normal: normal3, point: point3 } =\n        this.initializeViewport(thirdViewport));\n    } else {\n      // If there are only two views (viewport) associated with the crosshairs:\n      // In this situation, we don't have a third information to find the\n      // exact intersection, and we \"assume\" the third view is looking at\n      // a location in between the first and second view centers\n      vec3.add(point3, point1, point2);\n      vec3.scale(point3, point3, 0.5);\n      vec3.cross(normal3, normal1, normal2);\n    }\n\n    // Planes of each viewport\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n\n    // Calculating the intersection of 3 planes\n    // prettier-ignore\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\n\n    // assuming all viewports are in the same rendering engine\n    const { renderingEngine } = getEnabledElementByIds(\n      viewportsInfo[0].viewportId,\n      viewportsInfo[0].renderingEngineId\n    );\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\n   *\n   * @param evt - The mouse event\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\n   * @returns Crosshairs annotation\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CrosshairsAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { currentPoints } = eventDetail;\n    const jumpWorld = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this._jump(enabledElement, jumpWorld);\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      annotations\n    );\n\n    // viewport Annotation\n    const { data } = filteredAnnotations[0];\n\n    const { rotationPoints } = data.handles;\n    const viewportIdArray = [];\n    // put all the draggable reference lines in the viewportIdArray\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n      viewportIdArray.push(otherViewport.id);\n      // rotation handles are two per viewport\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n    // set translation operation\n    data.handles.activeOperation = OPERATION.DRAG;\n\n    evt.preventDefault();\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n    return filteredAnnotations[0];\n  };\n\n  cancel = () => {\n    console.log('Not implemented yet');\n  };\n\n  /**\n   * It checks if the mouse click is near crosshairs handles, if yes\n   * it returns the handle location. If the mouse click is not near any\n   * of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let point = this._getRotationHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n\n    point = this._getSlabThicknessHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n\n    // NOTE: handle index or coordinates are not used when dragging.\n    // This because the handle points are actually generated in the renderTool and they are a derivative\n    // from the camera variables of the viewports and of the slab thickness variable.\n    // Remember that the translation and rotation operations operate on the camera\n    // variables and not really on the handles. Similar for the slab thickness.\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * It returns if the canvas point is near the provided crosshairs annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CrosshairsAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  onCameraModified = (evt) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport that the camera modified is originating from\n    const viewportAnnotation =\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\n\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    // -- Update the camera of other linked viewports containing the same volumeId that\n    //    have the same camera in case of translation\n    // -- Update the crosshair center in world coordinates in annotation.\n    // This is necessary because other tools can modify the position of the slices,\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\n    const currentCamera = viewport.getCamera();\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.position,\n      oldCameraPosition,\n      deltaCameraPosition\n    );\n\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.focalPoint,\n      oldCameraFocalPoint,\n      deltaCameraFocalPoint\n    );\n\n    // updated cached \"previous\" camera position and focal point\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n    viewportAnnotation.metadata.cameraFocalPoint = [\n      ...currentCamera.focalPoint,\n    ];\n\n    const viewportControllable = this._getReferenceLineControllable(\n      viewport.id\n    );\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\n      viewport.id\n    );\n    if (\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n      viewportControllable &&\n      viewportDraggableRotatable\n    ) {\n      // Is camera Modified a TRANSLATION or ROTATION?\n      let isRotation = false;\n\n      // This is guaranteed to be the same diff for both position and focal point\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\n      // crosshairs handles it will be different.\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\n        deltaCameraPosition,\n        deltaCameraFocalPoint,\n        1e-3\n      );\n\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\n      if (!cameraModifiedSameForPosAndFocalPoint) {\n        isRotation = true;\n      }\n\n      const cameraModifiedInPlane =\n        Math.abs(\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\n        ) < 1e-2;\n\n      // TRANSLATION\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\n      // NOTE2: rotation handles are updates in renderTool\n      if (!isRotation && !cameraModifiedInPlane) {\n        this.toolCenter[0] += deltaCameraPosition[0];\n        this.toolCenter[1] += deltaCameraPosition[1];\n        this.toolCenter[2] += deltaCameraPosition[2];\n      }\n    }\n\n    // AutoPan modification\n    if (this.configuration.autoPan?.enabled) {\n      const toolGroup = getToolGroupForViewport(\n        viewport.id,\n        renderingEngine.id\n      );\n\n      const otherViewportIds = toolGroup\n        .getViewportIds()\n        .filter((id) => id !== viewport.id);\n\n      otherViewportIds.forEach((viewportId) => {\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n      });\n    }\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredToolAnnotations: Annotations\n  ): boolean => {\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let imageNeedsUpdate = false;\n\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\n\n      if (isAnnotationLocked(annotation)) {\n        continue;\n      }\n\n      const { data, highlighted } = annotation;\n      if (!data.handles) {\n        continue;\n      }\n\n      const previousActiveOperation = data.handles.activeOperation;\n      const previousActiveViewportIds =\n        data.activeViewportIds && data.activeViewportIds.length > 0\n          ? [...data.activeViewportIds]\n          : [];\n\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\n      data.activeViewportIds = [];\n      data.handles.activeOperation = null;\n\n      const handleNearImagePoint = this.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        6\n      );\n\n      let near = false;\n      if (handleNearImagePoint) {\n        near = true;\n      } else {\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\n      }\n\n      const nearToolAndNotMarkedActive = near && !highlighted;\n      const notNearToolAndMarkedActive = !near && highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !highlighted;\n        imageNeedsUpdate = true;\n      } else if (\n        data.handles.activeOperation !== previousActiveOperation ||\n        !this._areViewportIdArraysEqual(\n          data.activeViewportIds,\n          previousActiveViewportIds\n        )\n      ) {\n        imageNeedsUpdate = true;\n      }\n    }\n\n    return imageNeedsUpdate;\n  };\n\n  filterInteractableAnnotationsForElement = (element, annotations) => {\n    if (!annotations || !annotations.length) {\n      return [];\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n\n    const viewportUIDSpecificCrosshairs = annotations.filter(\n      (annotation) => annotation.data.viewportId === viewportId\n    );\n\n    return viewportUIDSpecificCrosshairs;\n  };\n\n  /**\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n    const annotations = this._getAnnotations(enabledElement);\n    const camera = viewport.getCamera();\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!annotations?.length || !viewportAnnotation?.data) {\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\n      return renderStatus;\n    }\n\n    const annotationUID = viewportAnnotation.annotationUID;\n\n    // Get cameras/canvases for each of these.\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\n    // -- Convert these world positions to this canvas.\n    // -- Extend/confine this line to fit in this canvas.\n    // -- Render this line.\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n\n    const data = viewportAnnotation.data;\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    const otherViewportAnnotations =\n      this._filterAnnotationsByUniqueViewportOrientations(\n        enabledElement,\n        annotations\n      );\n\n    const referenceLines = [];\n\n    // get canvas information for points and lines (canvas box, canvas horizontal distances)\n    const canvasBox = [0, 0, clientWidth, clientHeight];\n\n    otherViewportAnnotations.forEach((annotation) => {\n      const { data } = annotation;\n\n      data.handles.toolCenter = this.toolCenter;\n\n      const otherViewport = renderingEngine.getViewport(\n        data.viewportId\n      ) as Types.IVolumeViewport;\n\n      const otherCamera = otherViewport.getCamera();\n\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const otherViewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      const otherViewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      // get coordinates for the reference line\n      const { clientWidth, clientHeight } = otherViewport.canvas;\n      const otherCanvasDiagonalLength = Math.sqrt(\n        clientWidth * clientWidth + clientHeight * clientHeight\n      );\n      const otherCanvasCenter: Types.Point2 = [\n        clientWidth * 0.5,\n        clientHeight * 0.5,\n      ];\n      const otherViewportCenterWorld =\n        otherViewport.canvasToWorld(otherCanvasCenter);\n\n      const direction: Types.Point3 = [0, 0, 0];\n      vtkMath.cross(\n        camera.viewPlaneNormal,\n        otherCamera.viewPlaneNormal,\n        direction\n      );\n      vtkMath.normalize(direction);\n      vtkMath.multiplyScalar(\n        <Types.Point3>direction,\n        otherCanvasDiagonalLength\n      );\n\n      const pointWorld0: Types.Point3 = [0, 0, 0];\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n\n      const pointWorld1: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\n        otherViewportCenterWorld\n      );\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        pointCanvas0,\n        otherViewportCenterCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      // Graphic:\n      // Mid -> SlabThickness handle\n      // Short -> Rotation handle\n      //                           Long\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                           Long\n      const canvasVectorFromCenterLong = vec2.create();\n\n      vec2.scale(\n        canvasVectorFromCenterLong,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 100\n      );\n      const canvasVectorFromCenterMid = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterMid,\n        canvasUnitVectorFromCenter,\n        // to maximize the visibility of the controls, they need to be\n        // placed at most at half the length of the shortest side of the canvas.\n        // Chosen 0.4 to have some margin to the edge.\n        canvasMinDimensionLength * 0.4\n      );\n      const canvasVectorFromCenterShort = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterShort,\n        canvasUnitVectorFromCenter,\n        // Chosen 0.2 because is half of 0.4.\n        canvasMinDimensionLength * 0.2\n      );\n      const canvasVectorFromCenterStart = vec2.create();\n      const centerGap = this.configuration.referenceLinesCenterGapRadius;\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        // Don't put a gap if the the third view is missing\n        otherViewportAnnotations.length === 2 ? centerGap : 0\n      );\n\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\n      const refLinePointOne = vec2.create();\n      const refLinePointTwo = vec2.create();\n      const refLinePointThree = vec2.create();\n      const refLinePointFour = vec2.create();\n\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n      vec2.subtract(\n        refLinePointThree,\n        refLinesCenter,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        refLinePointFour,\n        refLinesCenter,\n        canvasVectorFromCenterLong\n      );\n\n      // Clipping lines to be only included in a box (canvas), we don't want\n      // the lines goes beyond canvas\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n\n      // Computing rotation handle positions\n      const rotHandleOne = vec2.create();\n      vec2.subtract(\n        rotHandleOne,\n        crosshairCenterCanvas,\n        canvasVectorFromCenterMid\n      );\n\n      const rotHandleTwo = vec2.create();\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n\n      // Computing SlabThickness (st below) position\n\n      // SlabThickness center in canvas\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      // SlabThickness center in world\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\n      }\n\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n      vtkMath.normalize(worldUnitVectorFromCenter);\n\n      const { viewPlaneNormal } = camera;\n      // @ts-ignore // Todo: fix after vtk pr merged\n      const { matrix } = vtkMatrixBuilder\n        .buildFromDegree()\n        // @ts-ignore fix after vtk pr merged\n        .rotate(90, viewPlaneNormal);\n\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vec3.transformMat4(\n        worldUnitOrthoVectorFromCenter,\n        worldUnitVectorFromCenter,\n        matrix\n      );\n\n      const slabThicknessValue = otherViewport.getSlabThickness();\n      const worldOrthoVectorFromCenter: Types.Point3 = [\n        ...worldUnitOrthoVectorFromCenter,\n      ];\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\n      vtkMath.add(\n        stHandlesCenterWorld,\n        worldOrthoVectorFromCenter,\n        worldVerticalRefPoint\n      );\n\n      // convert vertical world distances in canvas coordinates\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\n        worldVerticalRefPoint\n      );\n\n      // points for slab thickness lines\n      const canvasOrthoVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasOrthoVectorFromCenter,\n        stHandlesCenterCanvas,\n        canvasVerticalRefPoint\n      );\n\n      const stLinePointOne = vec2.create();\n      vec2.subtract(\n        stLinePointOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n\n      const stLinePointTwo = vec2.create();\n      vec2.add(\n        stLinePointTwo,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n\n      const stLinePointThree = vec2.create();\n      vec2.add(\n        stLinePointThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointThree,\n        stLinePointThree,\n        canvasOrthoVectorFromCenter\n      );\n\n      const stLinePointFour = vec2.create();\n      vec2.subtract(\n        stLinePointFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointFour,\n        stLinePointFour,\n        canvasOrthoVectorFromCenter\n      );\n\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n\n      // points for slab thickness handles\n      const stHandleOne = vec2.create();\n      const stHandleTwo = vec2.create();\n      const stHandleThree = vec2.create();\n      const stHandleFour = vec2.create();\n\n      vec2.subtract(\n        stHandleOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n      vec2.subtract(\n        stHandleThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n      vec2.add(\n        stHandleFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n\n      referenceLines.push([\n        otherViewport,\n        refLinePointOne,\n        refLinePointTwo,\n        refLinePointThree,\n        refLinePointFour,\n        stLinePointOne,\n        stLinePointTwo,\n        stLinePointThree,\n        stLinePointFour,\n        rotHandleOne,\n        rotHandleTwo,\n        stHandleOne,\n        stHandleTwo,\n        stHandleThree,\n        stHandleFour,\n      ]);\n    });\n\n    const newRtpoints = [];\n    const newStpoints = [];\n    const viewportColor = this._getReferenceLineColor(viewport.id);\n    const color =\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n    referenceLines.forEach((line, lineIndex) => {\n      // get color for the reference line\n      const otherViewport = line[0];\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const selectedViewportId = data.activeViewportIds.find(\n        (id) => id === otherViewport.id\n      );\n\n      let color =\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n      let lineWidth = 1;\n\n      const lineActive =\n        data.handles.activeOperation !== null &&\n        data.handles.activeOperation === OPERATION.DRAG &&\n        selectedViewportId;\n\n      if (lineActive) {\n        lineWidth = 2.5;\n      }\n\n      let lineUID = `${lineIndex}`;\n      if (viewportControllable && viewportDraggableRotatable) {\n        lineUID = `${lineIndex}One`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[1],\n          line[2],\n          {\n            color,\n            lineWidth,\n          }\n        );\n\n        lineUID = `${lineIndex}Two`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[3],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      } else {\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[2],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      if (viewportControllable) {\n        color =\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n        const rotHandlesActive =\n          data.handles.activeOperation === OPERATION.ROTATE;\n        const rotationHandles = [line[9], line[10]];\n\n        const rotHandleWorldOne = [\n          viewport.canvasToWorld(line[9]),\n          otherViewport,\n          line[1],\n          line[2],\n        ];\n        const rotHandleWorldTwo = [\n          viewport.canvasToWorld(line[10]),\n          otherViewport,\n          line[3],\n          line[4],\n        ];\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n\n        const slabThicknessHandlesActive =\n          data.handles.activeOperation === OPERATION.SLAB;\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n\n        const slabThicknessHandleWorldOne = [\n          viewport.canvasToWorld(line[11]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldTwo = [\n          viewport.canvasToWorld(line[12]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldThree = [\n          viewport.canvasToWorld(line[13]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        const slabThicknessHandleWorldFour = [\n          viewport.canvasToWorld(line[14]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        newStpoints.push(\n          slabThicknessHandleWorldOne,\n          slabThicknessHandleWorldTwo,\n          slabThicknessHandleWorldThree,\n          slabThicknessHandleWorldFour\n        );\n\n        if (\n          (lineActive || this.configuration.mobile?.enabled) &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw all handles inactive (rotation and slab thickness)\n          let handleUID = `${lineIndex}One`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n          handleUID = `${lineIndex}Two`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (\n          lineActive &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw rotation handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n        } else if (\n          selectedViewportId &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportSlabThicknessControlsOn\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw slab thickness handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\n          const handleUID = `${lineIndex}`;\n          // draw all rotation handles as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'circle',\n            }\n          );\n        } else if (\n          slabThicknessHandlesActive &&\n          selectedViewportId &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw only the slab thickness handles for the active viewport as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'rect',\n            }\n          );\n        }\n        const slabThicknessValue = otherViewport.getSlabThickness();\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n          // draw slab thickness reference lines\n          lineUID = `${lineIndex}STOne`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[5],\n            line[6],\n            {\n              color,\n              width: 1,\n              lineDash: [2, 3],\n            }\n          );\n\n          lineUID = `${lineIndex}STTwo`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[7],\n            line[8],\n            {\n              color,\n              width: line,\n              lineDash: [2, 3],\n            }\n          );\n        }\n      }\n    });\n\n    renderStatus = true;\n\n    // Save new handles points in annotation\n    data.handles.rotationPoints = newRtpoints;\n    data.handles.slabThicknessPoints = newStpoints;\n\n    if (this.configuration.viewportIndicators) {\n      // render a circle to pin point the viewport color\n      // TODO: This should not be part of the tool, and definitely not part of the renderAnnotation loop\n      const referenceColorCoordinates = [\n        clientWidth * 0.95,\n        clientHeight * 0.05,\n      ] as Types.Point2;\n      const circleRadius = canvasDiagonalLength * 0.01;\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        referenceColorCoordinates,\n        circleRadius,\n        { color, fill: color }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\n    const { viewport } = enabledElement;\n    const annotations =\n      getAnnotations(this.getToolName(), viewport.element) || [];\n    const viewportIds = this._getViewportsInfo().map(\n      ({ viewportId }) => viewportId\n    );\n\n    // filter the annotations to only keep that are for this toolGroup\n    const toolGroupAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      return viewportIds.includes(data.viewportId);\n    });\n\n    return toolGroupAnnotations;\n  };\n\n  _onNewVolume = (e: any) => {\n    const viewportsInfo = this._getViewportsInfo();\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _subscribeToViewportNewVolumeSet(viewports) {\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _autoPanViewportIfNecessary(\n    viewportId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): void {\n    // 1. Check if the toolCenter is outside the viewport\n    // 2. If it is outside, pan the viewport to fit in the toolCenter\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    const { clientWidth, clientHeight } = viewport.canvas;\n\n    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    // pan the viewport to fit the toolCenter in the direction\n    // that is out of bounds\n    const pan = this.configuration.autoPan.panSize;\n\n    const visiblePointCanvas = <Types.Point2>[\n      toolCenterCanvas[0],\n      toolCenterCanvas[1],\n    ];\n\n    if (toolCenterCanvas[0] < 0) {\n      visiblePointCanvas[0] = pan;\n    } else if (toolCenterCanvas[0] > clientWidth) {\n      visiblePointCanvas[0] = clientWidth - pan;\n    }\n\n    if (toolCenterCanvas[1] < 0) {\n      visiblePointCanvas[1] = pan;\n    } else if (toolCenterCanvas[1] > clientHeight) {\n      visiblePointCanvas[1] = clientHeight - pan;\n    }\n\n    if (\n      visiblePointCanvas[0] === toolCenterCanvas[0] &&\n      visiblePointCanvas[1] === toolCenterCanvas[1]\n    ) {\n      return;\n    }\n\n    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n\n    const deltaPointsWorld = [\n      visiblePointWorld[0] - this.toolCenter[0],\n      visiblePointWorld[1] - this.toolCenter[1],\n      visiblePointWorld[2] - this.toolCenter[2],\n    ];\n\n    const camera = viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    viewport.render();\n  }\n\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n      return false;\n    }\n\n    viewportIdArrayOne.forEach((id) => {\n      let itemFound = false;\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n        if (id === viewportIdArrayTwo[i]) {\n          itemFound = true;\n          break;\n        }\n      }\n      if (itemFound === false) {\n        return false;\n      }\n    });\n\n    return true;\n  };\n\n  // It filters the viewports with crosshairs and only return viewports\n  // that have different camera.\n  _getAnnotationsForViewportsWithDifferentCameras = (\n    enabledElement,\n    annotations\n  ) => {\n    const { viewportId, renderingEngine, viewport } = enabledElement;\n\n    const otherViewportAnnotations = annotations.filter(\n      (annotation) => annotation.data.viewportId !== viewportId\n    );\n\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, position } = camera;\n\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { viewportId } = annotation.data;\n        const targetViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfTarget = targetViewport.getCamera();\n\n        return !(\n          csUtils.isEqual(\n            cameraOfTarget.viewPlaneNormal,\n            viewPlaneNormal,\n            1e-2\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\n        );\n      }\n    );\n\n    return viewportsWithDifferentCameras;\n  };\n\n  _filterViewportWithSameOrientation = (\n    enabledElement,\n    referenceAnnotation,\n    annotations\n  ) => {\n    const { renderingEngine } = enabledElement;\n    const { data } = referenceAnnotation;\n    const viewport = renderingEngine.getViewport(data.viewportId);\n\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n\n      return otherViewportControllable === true;\n    });\n\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherViewportsAnnotationsWithSameCameraDirection =\n      linkedViewportAnnotations.filter((annotation) => {\n        const { viewportId } = annotation.data;\n        const otherViewport = renderingEngine.getViewport(viewportId);\n        const otherCamera = otherViewport.getCamera();\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n        vtkMath.normalize(otherViewPlaneNormal);\n\n        return (\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\n        );\n      });\n\n    return otherViewportsAnnotationsWithSameCameraDirection;\n  };\n\n  _filterAnnotationsByUniqueViewportOrientations = (\n    enabledElement,\n    annotations\n  ) => {\n    const { renderingEngine, viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable === true\n        );\n      }\n    );\n\n    const otherViewportsAnnotationsWithUniqueCameras = [];\n    // Iterate first on other viewport from the same scene linked\n    for (\n      let i = 0;\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable !== true\n        );\n      }\n    );\n\n    // Iterate second on other viewport from the same scene non linked\n    for (\n      let i = 0;\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    // Iterate on all the viewport\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n      const annotation = otherViewportAnnotations[i];\n      if (\n        otherViewportsAnnotationsWithUniqueCameras.some(\n          (element) => element === annotation\n        )\n      ) {\n        continue;\n      }\n\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    return otherViewportsAnnotationsWithUniqueCameras;\n  };\n\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n    const actors = viewport.getActors();\n    const otherViewportActors = otherViewport.getActors();\n\n    let sameScene = true;\n\n    actors.forEach((actor) => {\n      if (\n        actors.length !== otherViewportActors.length ||\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\n      ) {\n        sameScene = false;\n      }\n    });\n\n    return sameScene;\n  };\n\n  _jump = (enabledElement, jumpWorld) => {\n    state.isInteractingWithTool = true;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const annotations = this._getAnnotations(enabledElement);\n\n    const delta: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n\n    // TRANSLATION\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n\n        const sameScene = this._checkIfViewportsRenderingSameScene(\n          viewport,\n          otherViewport\n        );\n\n        return (\n          this._getReferenceLineControllable(otherViewport.id) &&\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n          sameScene\n        );\n      }\n    );\n\n    if (viewportsAnnotationsToUpdate.length === 0) {\n      state.isInteractingWithTool = false;\n      return false;\n    }\n\n    this._applyDeltaShiftToSelectedViewportCameras(\n      renderingEngine,\n      viewportsAnnotationsToUpdate,\n      delta\n    );\n\n    state.isInteractingWithTool = false;\n\n    return true;\n  };\n\n  _activateModify = (element) => {\n    // mobile sometimes has lingering interaction even when touchEnd triggers\n    // this check allows for multiple handles to be active which doesn't affect\n    // tool usage.\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this.editData.annotation.data.handles.activeOperation = null;\n    this.editData.annotation.data.activeViewportIds = [];\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const delta = eventDetail.deltaPoints.world;\n\n    if (\n      Math.abs(delta[0]) < 1e-3 &&\n      Math.abs(delta[1]) < 1e-3 &&\n      Math.abs(delta[2]) < 1e-3\n    ) {\n      return;\n    }\n\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const annotations = this._getAnnotations(\n      enabledElement\n    ) as CrosshairsAnnotation[];\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    const { handles } = viewportAnnotation.data;\n    const { currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n\n    if (handles.activeOperation === OPERATION.DRAG) {\n      // TRANSLATION\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      this._applyDeltaShiftToSelectedViewportCameras(\n        renderingEngine,\n        viewportsAnnotationsToUpdate,\n        delta\n      );\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\n      // ROTATION\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true\n          );\n        }\n      );\n\n      const dir1 = vec2.create();\n      const dir2 = vec2.create();\n\n      const center: Types.Point3 = [\n        this.toolCenter[0],\n        this.toolCenter[1],\n        this.toolCenter[2],\n      ];\n\n      const centerCanvas = viewport.worldToCanvas(center);\n\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\n      const originalPointCanvas = vec2.create();\n      vec2.sub(\n        originalPointCanvas,\n        finalPointCanvas,\n        eventDetail.deltaPoints.canvas\n      );\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\n\n      let angle = vec2.angle(dir1, dir2);\n\n      if (\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\n      ) {\n        angle *= -1;\n      }\n\n      // Rounding the angle to allow rotated handles to be undone\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\n      // there's no assurance that the counter-clockwise rotation occurs at\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\n      angle = Math.round(angle * 100) / 100;\n\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\n      // @ts-ignore : vtkjs incorrect typing\n      const { matrix } = vtkMatrixBuilder\n        .buildFromRadian()\n        .translate(center[0], center[1], center[2])\n        // @ts-ignore\n        .rotate(angle, rotationAxis) //todo: why we are passing\n        .translate(-center[0], -center[1], -center[2]);\n\n      const otherViewportsIds = [];\n      // update camera for the other viewports.\n      // NOTE: The lines then are rendered by the onCameraModified\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\n        const { data } = annotation;\n        data.handles.toolCenter = center;\n\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const camera = otherViewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n\n        viewUp[0] += position[0];\n        viewUp[1] += position[1];\n        viewUp[2] += position[2];\n\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\n        vec3.transformMat4(position, position, matrix);\n        vec3.transformMat4(viewUp, viewUp, matrix);\n\n        viewUp[0] -= position[0];\n        viewUp[1] -= position[1];\n        viewUp[2] -= position[2];\n\n        otherViewport.setCamera({\n          position,\n          viewUp,\n          focalPoint,\n        });\n        otherViewportsIds.push(otherViewport.id);\n      });\n      renderingEngine.renderViewports(otherViewportsIds);\n    } else if (handles.activeOperation === OPERATION.SLAB) {\n      // SLAB THICKNESS\n      // this should be just the active one under the mouse,\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const referenceAnnotations = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportSlabThicknessControlsOn =\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportSlabThicknessControlsOn === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      if (referenceAnnotations.length === 0) {\n        return;\n      }\n      const viewportsAnnotationsToUpdate =\n        this._filterViewportWithSameOrientation(\n          enabledElement,\n          referenceAnnotations[0],\n          annotations\n        );\n\n      const viewportsIds = [];\n      viewportsIds.push(viewport.id);\n      viewportsAnnotationsToUpdate.forEach(\n        (annotation: CrosshairsAnnotation) => {\n          const { data } = annotation;\n\n          const otherViewport = renderingEngine.getViewport(\n            data.viewportId\n          ) as Types.IVolumeViewport;\n          const camera = otherViewport.getCamera();\n          const normal = camera.viewPlaneNormal;\n\n          const dotProd = vtkMath.dot(delta, normal);\n          const projectedDelta: Types.Point3 = [...normal];\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n          if (\n            Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3\n          ) {\n            const mod = Math.sqrt(\n              projectedDelta[0] * projectedDelta[0] +\n                projectedDelta[1] * projectedDelta[1] +\n                projectedDelta[2] * projectedDelta[2]\n            );\n\n            const currentPoint = eventDetail.lastPoints.world;\n            const direction: Types.Point3 = [0, 0, 0];\n\n            const currentCenter: Types.Point3 = [\n              this.toolCenter[0],\n              this.toolCenter[1],\n              this.toolCenter[2],\n            ];\n\n            // use this.toolCenter only if viewportDraggableRotatable\n            const viewportDraggableRotatable =\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n              const { rotationPoints } = this.editData.annotation.data.handles;\n              // Todo: what is a point uid?\n              const otherViewportRotationPoints = rotationPoints.filter(\n                (point) => point[1].uid === otherViewport.id\n              );\n              if (otherViewportRotationPoints.length === 2) {\n                const point1 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[0][3]\n                );\n                const point2 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[1][3]\n                );\n                vtkMath.add(point1, point2, currentCenter);\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\n              }\n            }\n\n            vtkMath.subtract(currentPoint, currentCenter, direction);\n            const dotProdDirection = vtkMath.dot(direction, normal);\n            const projectedDirection: Types.Point3 = [...normal];\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n            const normalizedProjectedDirection: Types.Point3 = [\n              projectedDirection[0],\n              projectedDirection[1],\n              projectedDirection[2],\n            ];\n            vec3.normalize(\n              normalizedProjectedDirection,\n              normalizedProjectedDirection\n            );\n            const normalizedProjectedDelta: Types.Point3 = [\n              projectedDelta[0],\n              projectedDelta[1],\n              projectedDelta[2],\n            ];\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n\n            let slabThicknessValue = otherViewport.getSlabThickness();\n            if (\n              csUtils.isOpposite(\n                normalizedProjectedDirection,\n                normalizedProjectedDelta,\n                1e-3\n              )\n            ) {\n              slabThicknessValue -= mod;\n            } else {\n              slabThicknessValue += mod;\n            }\n\n            slabThicknessValue = Math.abs(slabThicknessValue);\n            slabThicknessValue = Math.max(\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\n              slabThicknessValue\n            );\n\n            const near = this._pointNearReferenceLine(\n              viewportAnnotation,\n              canvasCoords,\n              6,\n              otherViewport\n            );\n\n            if (near) {\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n            }\n\n            // We want to set the slabThickness for the viewport's actors but\n            // since the crosshairs tool instance has configuration regarding which\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\n            // slabThickness for, we need to delegate the slabThickness setting\n            // to the crosshairs tool instance of the toolGroup since configurations\n            // exist on the toolInstance and each toolGroup has its own crosshairs\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\n            // the viewport level which makes tool and viewport state convoluted).\n            const toolGroup = getToolGroupForViewport(\n              otherViewport.id,\n              renderingEngine.id\n            );\n            const crosshairsInstance = toolGroup.getToolInstance(\n              this.getToolName()\n            );\n            crosshairsInstance.setSlabThickness(\n              otherViewport,\n              slabThicknessValue\n            );\n\n            viewportsIds.push(otherViewport.id);\n          }\n        }\n      );\n      renderingEngine.renderViewports(viewportsIds);\n    }\n  };\n\n  setSlabThickness(viewport, slabThickness) {\n    let actorUIDs;\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\n    if (\n      filterActorUIDsToSetSlabThickness &&\n      filterActorUIDsToSetSlabThickness.length > 0\n    ) {\n      actorUIDs = filterActorUIDsToSetSlabThickness;\n    }\n\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\n    }\n\n    const immediate = false;\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n    viewport.setSlabThickness(slabThickness, actorUIDs);\n  }\n\n  _isClockWise(a, b, c) {\n    // return true if the rotation is clockwise\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n  }\n\n  _applyDeltaShiftToSelectedViewportCameras(\n    renderingEngine,\n    viewportsAnnotationsToUpdate,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n    });\n  }\n\n  _applyDeltaShiftToViewportCamera(\n    renderingEngine: Types.IRenderingEngine,\n    annotation,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    const { data } = annotation;\n\n    const viewport = renderingEngine.getViewport(data.viewportId);\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n\n    // Project delta over camera normal\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\n    const dotProd = vtkMath.dot(delta, normal);\n    const projectedDelta: Types.Point3 = [...normal];\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n    if (\n      Math.abs(projectedDelta[0]) > 1e-3 ||\n      Math.abs(projectedDelta[1]) > 1e-3 ||\n      Math.abs(projectedDelta[2]) > 1e-3\n    ) {\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\n      const newPosition: Types.Point3 = [0, 0, 0];\n\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n      vtkMath.add(camera.position, projectedDelta, newPosition);\n\n      viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n      });\n      viewport.render();\n    }\n  }\n\n  _pointNearReferenceLine = (\n    annotation,\n    canvasCoords,\n    proximity,\n    lineViewport\n  ) => {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      if (otherViewport.id !== lineViewport.id) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        return true;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    return false;\n  };\n\n  _getRotationHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length; i++) {\n      const point = rotationPoints[i][0];\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportDraggableRotatable) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.ROTATE;\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _getSlabThicknessHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { slabThicknessPoints } = data.handles;\n\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\n      const point = slabThicknessPoints[i][0];\n      const otherViewport = slabThicknessPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n      if (!viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.SLAB;\n\n        data.activeViewportIds = [otherViewport.id];\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const { data } = annotation;\n\n    const { rotationPoints } = data.handles;\n    const { slabThicknessPoints } = data.handles;\n    const viewportIdArray = [];\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id);\n        data.handles.activeOperation = OPERATION.DRAG;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n      const otherViewport = slabThicknessPoints[i][1];\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\n\n      const centerCanvas = vec2.create();\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        stPointLineCanvas1,\n        centerCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.05\n      );\n\n      const stPointLineCanvas1Start = vec2.create();\n      const stPointLineCanvas2Start = vec2.create();\n      vec2.add(\n        stPointLineCanvas1Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        stPointLineCanvas2Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n\n      const lineSegment1 = {\n        start: {\n          x: stPointLineCanvas1Start[0],\n          y: stPointLineCanvas1Start[1],\n        },\n        end: {\n          x: stPointLineCanvas1[0],\n          y: stPointLineCanvas1[1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: stPointLineCanvas2Start[0],\n          y: stPointLineCanvas2Start[1],\n        },\n        end: {\n          x: stPointLineCanvas2[0],\n          y: stPointLineCanvas2[1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\n        data.handles.activeOperation = null; // no operation\n      }\n\n      // slab thickness handles are in couples\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n\n    this.editData = {\n      annotation,\n    };\n\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n  }\n}\n\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\n\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\n\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { IPoints } from '../types';\n\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\n\nclass MagnifyTool extends BaseTool {\n  static toolName;\n  _bounds: any;\n  editData: {\n    referencedImageId: string;\n    viewportIdsToRender: string[];\n    enabledElement: Types.IEnabledElement;\n    renderingEngine: Types.IRenderingEngine;\n    currentPoints: IPoints;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        magnifySize: 10, // parallel scale , higher more zoom\n        magnifyWidth: 250, //px\n        magnifyHeight: 250, //px\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  private _hasBeenRemoved = false;\n\n  _getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    }\n\n    return referencedImageId;\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error('MagnifyTool only works on StackViewports');\n    }\n\n    const referencedImageId = this._getReferencedImageId(viewport);\n\n    if (!referencedImageId) {\n      throw new Error(\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\n      );\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      referencedImageId,\n      viewportIdsToRender,\n      enabledElement,\n      renderingEngine,\n      currentPoints,\n    };\n\n    this._createMagnificationViewport();\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\n    this.preMouseDownCallback(evt);\n  };\n\n  _createMagnificationViewport = () => {\n    const {\n      enabledElement,\n      referencedImageId,\n      viewportIdsToRender,\n      renderingEngine,\n      currentPoints,\n    } = this.editData;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const viewportProperties = viewport.getProperties();\n\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n\n    let magnifyToolElement: HTMLDivElement;\n\n    magnifyToolElement = element.querySelector('.magnifyTool');\n    if (magnifyToolElement === null) {\n      const magnifyElement = document.createElement('div');\n\n      magnifyElement.classList.add('magnifyTool');\n\n      magnifyElement.style.display = 'block';\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n      magnifyElement.style.position = 'absolute';\n\n      magnifyToolElement = magnifyElement;\n\n      const viewportElement = element.querySelector('.viewport-element');\n      viewportElement.appendChild(magnifyElement);\n\n      const viewportInput = {\n        viewportId: MAGNIFY_VIEWPORT_ID,\n        type: Enums.ViewportType.STACK,\n        element: magnifyToolElement as HTMLDivElement,\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n\n    // Todo: use CSS transform instead of setting top and left for better performance\n    magnifyToolElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyToolElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const magnifyViewport = renderingEngine.getViewport(\n      MAGNIFY_VIEWPORT_ID\n    ) as Types.IStackViewport;\n    magnifyViewport.setStack([referencedImageId]).then(() => {\n      if (this._hasBeenRemoved) {\n        return;\n      }\n      // match the original viewport voi range\n      magnifyViewport.setProperties(viewportProperties);\n\n      // Use the original viewport for the base for parallelScale\n      const { parallelScale } = viewport.getCamera();\n\n      const { focalPoint, position, viewPlaneNormal } =\n        magnifyViewport.getCamera();\n\n      const distance = Math.sqrt(\n        Math.pow(focalPoint[0] - position[0], 2) +\n          Math.pow(focalPoint[1] - position[1], 2) +\n          Math.pow(focalPoint[2] - position[2], 2)\n      );\n\n      const updatedFocalPoint = <Types.Point3>[\n        worldPos[0],\n        worldPos[1],\n        worldPos[2],\n      ];\n\n      const updatedPosition = <Types.Point3>[\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n      ];\n\n      magnifyViewport.setCamera({\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n        focalPoint: updatedFocalPoint,\n        position: updatedPosition,\n      });\n      magnifyViewport.render();\n    });\n\n    magnifyToolElement.style.display = 'block';\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n\n    const { deltaPoints, element, currentPoints } = eventDetail;\n    const deltaPointsWorld = deltaPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n\n    const magnifyElement = element.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    if (!magnifyElement) {\n      return;\n    }\n\n    magnifyElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const { focalPoint, position } = magnifyViewport.getCamera();\n\n    const updatedPosition = <Types.Point3>[\n      position[0] + deltaPointsWorld[0],\n      position[1] + deltaPointsWorld[1],\n      position[2] + deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] + deltaPointsWorld[0],\n      focalPoint[1] + deltaPointsWorld[1],\n      focalPoint[2] + deltaPointsWorld[2],\n    ];\n\n    magnifyViewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    magnifyViewport.render();\n  };\n\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n\n    const viewportElement = element.querySelector('.viewport-element');\n\n    const magnifyToolElement = viewportElement.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    viewportElement.removeChild(magnifyToolElement);\n\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n    this._hasBeenRemoved = true;\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n    this._hasBeenRemoved = false;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n}\n\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { AnnotationTool } from './base';\n\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAllAnnotations,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport AdvancedMagnifyViewportManager from './AdvancedMagnifyViewportManager';\nimport type { AutoPanCallbackData } from './AdvancedMagnifyViewport';\n\nenum AdvancedMagnifyToolActions {\n  ShowZoomFactorsList = 'showZoomFactorsList',\n}\n\nclass AdvancedMagnifyTool extends AnnotationTool {\n  static toolName;\n  static Actions = AdvancedMagnifyToolActions;\n\n  magnifyViewportManager: AdvancedMagnifyViewportManager;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        magnifyingGlass: {\n          radius: 125, // px\n          zoomFactor: 3,\n          zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n          autoPan: {\n            enabled: true,\n            padding: 10, // px\n          },\n        },\n        actions: {\n          showZoomFactorsList: {\n            method: 'showZoomFactorsList',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Secondary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AdvancedMagnifyAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const { magnifyingGlass: config } = this.configuration;\n    const { radius, zoomFactor, autoPan } = config;\n\n    const canvasHandlePoints = this._getCanvasHandlePoints(\n      canvasPos,\n      radius\n    ) as [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotationUID = csUtils.uuidv4();\n    const magnifyViewportId = csUtils.uuidv4();\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: AdvancedMagnifyAnnotation = {\n      annotationUID,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        sourceViewportId: viewport.id,\n        magnifyViewportId,\n        zoomFactor,\n        // this means that the last coordinate for the points\n        // is 0 and should not be used for calculations\n        isCanvasAnnotation: true,\n        handles: {\n          points: canvasHandlePoints,\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    this.magnifyViewportManager.createViewport(annotation, {\n      magnifyViewportId,\n      sourceEnabledElement: enabledElement,\n      position: canvasPos,\n      radius,\n      zoomFactor,\n      autoPan: {\n        enabled: autoPan.enabled,\n        padding: autoPan.padding,\n        callback: (data: AutoPanCallbackData) => {\n          const annotationPoints = annotation.data.handles.points;\n          const { canvas: canvasDelta } = data.delta;\n\n          for (let i = 0, len = annotationPoints.length; i < len; i++) {\n            const point = annotationPoints[i];\n            point[0] += canvasDelta[0];\n            point[1] += canvasDelta[1];\n            annotation.invalidated = true;\n          }\n        },\n      },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  onSetToolDisabled = () => {\n    // reset\n    this.magnifyViewportManager.dispose();\n    // remove the annotations from the state for that toolGroup\n    const annotations = getAllAnnotations();\n    annotations.forEach((annotation) => {\n      if (annotation.metadata.toolName === this.getToolName()) {\n        removeAnnotation(annotation.annotationUID);\n      }\n    });\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  public isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AdvancedMagnifyAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points;\n\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const center = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ] as Types.Point2;\n    const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n\n    if (Math.abs(radiusPoint - radius) < proximity * 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element, deltaPoints } = eventDetail;\n    const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { points } = annotation.data.handles;\n\n    points.forEach((point) => {\n      point[0] += canvasDelta[0];\n      point[1] += canvasDelta[1];\n    });\n\n    annotation.invalidated = true;\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const canvasDelta = deltaPoints.canvas;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += canvasDelta[0];\n        point[1] += canvasDelta[1];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points;\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const canvasCenter: Types.Point2 = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ];\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    const newRadius = getCanvasCircleRadius([\n      canvasCenter,\n      currentCanvasPoints,\n    ]);\n    const newCanvasHandlePoints = this._getCanvasHandlePoints(\n      canvasCenter,\n      newRadius\n    );\n\n    points[0] = newCanvasHandlePoints[0];\n    points[1] = newCanvasHandlePoints[1];\n    points[2] = newCanvasHandlePoints[2];\n    points[3] = newCanvasHandlePoints[3];\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = annotations?.filter(\n      (annotation) =>\n        (<AdvancedMagnifyAnnotation>annotation).data.sourceViewportId ===\n        viewport.id\n    );\n\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!filteredAnnotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < filteredAnnotations.length; i++) {\n      const annotation = filteredAnnotations[i] as AdvancedMagnifyAnnotation;\n      const { annotationUID, data } = annotation;\n      const { magnifyViewportId, zoomFactor, handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points;\n      const canvasTop = canvasCoordinates[0];\n      const canvasBottom = canvasCoordinates[2];\n      const canvasLeft = canvasCoordinates[3];\n      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n      const center = [\n        canvasLeft[0] + radius,\n        canvasTop[1] + radius,\n      ] as Types.Point2;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-advancedMagnify`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineWidth: 5,\n        },\n        dataId\n      );\n\n      const magnifyViewport =\n        this.magnifyViewportManager.getViewport(magnifyViewportId);\n\n      magnifyViewport.position = center;\n      magnifyViewport.radius = radius;\n      magnifyViewport.zoomFactor = zoomFactor;\n      magnifyViewport.update();\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Basic dropdown component that allows the user to select a different zoom factor.\n  // configurations.actions may be changed to use a customized dropdown.\n  public showZoomFactorsList(\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ) {\n    const { element, currentPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvas: canvasPoint } = currentPoints;\n    const viewportElement = element.querySelector(':scope .viewport-element');\n    const currentZoomFactor = annotation.data.zoomFactor;\n    const remove = () => dropdown.parentElement.removeChild(dropdown);\n\n    const dropdown = this._getZoomFactorsListDropdown(\n      currentZoomFactor,\n      (newZoomFactor) => {\n        if (newZoomFactor !== undefined) {\n          annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n          annotation.invalidated = true;\n        }\n\n        remove();\n        viewport.render();\n      }\n    );\n\n    Object.assign(dropdown.style, {\n      left: `${canvasPoint[0]}px`,\n      top: `${canvasPoint[1]}px`,\n    });\n\n    viewportElement.appendChild(dropdown);\n    dropdown.focus();\n  }\n\n  private _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n    const { zoomFactorList } = this.configuration.magnifyingGlass;\n    const dropdown = document.createElement('select');\n\n    dropdown.size = 5;\n    Object.assign(dropdown.style, {\n      width: '50px',\n      position: 'absolute',\n    });\n\n    ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n      dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n    });\n\n    dropdown.addEventListener('change', (evt) => {\n      evt.stopPropagation();\n      onChangeCallback(dropdown.value);\n    });\n\n    dropdown.addEventListener('keydown', (evt) => {\n      const shouldCancel =\n        (evt.keyCode ?? evt.which === 27) ||\n        evt.key?.toLowerCase() === 'escape';\n\n      if (shouldCancel) {\n        evt.stopPropagation();\n        onChangeCallback();\n      }\n    });\n\n    zoomFactorList.forEach((zoomFactor) => {\n      const option = document.createElement('option');\n\n      option.label = zoomFactor;\n      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n      option.value = zoomFactor;\n      option.defaultSelected = zoomFactor === currentZoomFactor;\n\n      dropdown.add(option);\n    });\n\n    return dropdown;\n  }\n\n  private _getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n    return [\n      [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0], // top\n      [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0], // right\n      [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0], // bottom\n      [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0], // left\n    ];\n  };\n}\n\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\n\nexport { AdvancedMagnifyTool as default };\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngines,\n  CONSTANTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { type Types, getEnabledElementByViewportId } from '@cornerstonejs/core';\n\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\n/**\n * @public\n */\nclass ReferenceLines extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    sourceViewportId: string;\n    annotation: ReferenceLineAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceViewportId: '',\n        showFullDimension: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // this._throttledCalculateCachedStats = throttle(\n    //   this._calculateCachedStats,\n    //   100,\n    //   { trailing: true }\n    // );\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    // Todo: handle this case where it is too soon to get the rendering engine\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    const sourceViewport = renderingEngine.getViewport(\n      this.configuration.sourceViewportId\n    ) as Types.IVolumeViewport;\n\n    if (!sourceViewport?.getImageData()) {\n      return;\n    }\n\n    const { element } = sourceViewport;\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n\n    const sourceViewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\n\n    let annotation = this.editData.annotation;\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n\n    if (!annotation) {\n      const newAnnotation: ReferenceLineAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: sourceViewportCanvasCornersInWorld,\n          },\n        },\n      };\n\n      addAnnotation(newAnnotation, element);\n      annotation = newAnnotation;\n    } else {\n      this.editData.annotation.data.handles.points =\n        sourceViewportCanvasCornersInWorld;\n    }\n\n    this.editData = {\n      sourceViewportId: sourceViewport.id,\n      renderingEngine,\n      annotation,\n    };\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewports\n        .filter((viewport) => viewport.id !== sourceViewport.id)\n        .map((viewport) => viewport.id)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolConfiguration = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the reference lines\n    // we really don't care which viewport triggered the\n    // camera modification, since we want to update all of them\n    // with respect to the targetViewport\n    this._init();\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport: targetViewport } = enabledElement;\n    const { annotation, sourceViewportId } = this.editData;\n\n    let renderStatus = false;\n\n    // we need to grab the viewport again since there might have been\n    // a change in the viewport state since the last time we cached it\n    const { viewport: sourceViewport } =\n      getEnabledElementByViewportId(sourceViewportId) || {};\n\n    if (!sourceViewport) {\n      return renderStatus;\n    }\n\n    if (sourceViewport.id === targetViewport.id) {\n      // If the source viewport is the same as the current viewport, we don't need to render\n      return renderStatus;\n    }\n\n    if (!annotation || !annotation?.data?.handles?.points) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    let pointSetToUse = pointSet1;\n\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const newNormal = vec3.cross(\n      vec3.create(),\n      topBottomVec,\n      topRightVec\n    ) as Types.Point3;\n\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\n      return renderStatus;\n    }\n\n    // check if it is perpendicular to the viewPlaneNormal which means\n    // the line does not intersect the viewPlaneNormal\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n      // 'use pointSet2';\n      pointSetToUse = pointSet2;\n    }\n\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[0],\n      pointSetToUse[1],\n      targetViewportPlane\n    );\n\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[2],\n      pointSetToUse[3],\n      targetViewportPlane\n    );\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n      targetViewport.worldToCanvas(world)\n    );\n\n    if (this.configuration.showFullDimension) {\n      canvasCoordinates = this.handleFullDimension(\n        targetViewport,\n        lineStartWorld,\n        viewPlaneNormal,\n        viewUp,\n        lineEndWorld,\n        canvasCoordinates\n      );\n    }\n\n    if (canvasCoordinates.length < 2) {\n      return renderStatus;\n    }\n\n    const dataId = `${annotationUID}-line`;\n    const lineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      lineUID,\n      canvasCoordinates[0],\n      canvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      dataId\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private handleFullDimension(\n    targetViewport: Types.IStackViewport | Types.IVolumeViewport,\n    lineStartWorld: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3,\n    lineEndWorld: Types.Point3,\n    canvasCoordinates: Types.Point2[]\n  ) {\n    const renderingEngine = targetViewport.getRenderingEngine();\n    const targetId = this.getTargetId(targetViewport);\n    const targetImage = this.getTargetIdImage(targetId, renderingEngine);\n\n    const referencedImageId = this.getReferencedImageId(\n      targetViewport,\n      lineStartWorld,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    if (referencedImageId && targetImage) {\n      try {\n        const { imageData, dimensions } = targetImage;\n\n        // Calculate bound image coordinates\n        const [\n          topLeftImageCoord,\n          topRightImageCoord,\n          bottomRightImageCoord,\n          bottomLeftImageCoord,\n        ] = [\n          imageData.indexToWorld([0, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([dimensions[0] - 1, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n          ]) as Types.Point3,\n          imageData.indexToWorld([0, dimensions[1] - 1, 0]) as Types.Point3,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate line start and end image coordinates\n        const [lineStartImageCoord, lineEndImageCoord] = [\n          lineStartWorld,\n          lineEndWorld,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate intersection points between line and image bounds\n        canvasCoordinates = [\n          [topLeftImageCoord, topRightImageCoord],\n          [topRightImageCoord, bottomRightImageCoord],\n          [bottomLeftImageCoord, bottomRightImageCoord],\n          [topLeftImageCoord, bottomLeftImageCoord],\n        ]\n          .map(([start, end]) =>\n            this.intersectInfiniteLines(\n              start,\n              end,\n              lineStartImageCoord,\n              lineEndImageCoord\n            )\n          )\n          .filter((point) => point && this.isInBound(point, dimensions))\n          .map((point) => {\n            const world = csUtils.imageToWorldCoords(\n              referencedImageId,\n              point as Types.Point2\n            );\n            return targetViewport.worldToCanvas(world);\n          });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n    return canvasCoordinates;\n  }\n\n  // get the intersection point between two infinite lines, not line segments\n  intersectInfiniteLines(\n    line1Start: Types.Point2,\n    line1End: Types.Point2,\n    line2Start: Types.Point2,\n    line2End: Types.Point2\n  ) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n\n    // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n\n    // Compute a2, b2, c2\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n\n    if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n      return;\n    }\n\n    const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n\n    return [x, y];\n  }\n\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  isInBound(point: number[], dimensions: Types.Point3): boolean {\n    return (\n      point[0] >= 0 &&\n      point[0] <= dimensions[0] &&\n      point[1] >= 0 &&\n      point[1] <= dimensions[1]\n    );\n  }\n}\n\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport {\n  metaData,\n  CONSTANTS,\n  getRenderingEngine,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\n\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\nexport interface OverlayGridAnnotation extends Annotation {\n  data: {\n    viewportData: Map<string, object>;\n    pointSets: Array<object>;\n  };\n}\n\n/**\n * @public\n */\nclass OverlayGridTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceImageIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolActive = (): void => {\n    this._init();\n  };\n\n  _init = (): void => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n    if (!sourceImageIds?.length) {\n      console.warn(\n        'OverlayGridTool: No sourceImageIds provided in configuration'\n      );\n      return;\n    }\n\n    const imagePlaneModule = metaData.get(\n      'imagePlaneModule',\n      sourceImageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n      console.warn(\n        'OverlayGridTool: No imagePlaneModule found for sourceImageIds'\n      );\n      return;\n    }\n\n    const { frameOfReferenceUID } = imagePlaneModule;\n\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn('OverlayGridTool: No viewports found');\n      return;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const pointSets = sourceImageIds.map((id) => {\n        // check if pointSets for the imageId was calculated. If not calculate and store\n        return this.calculateImageIdPointSets(id);\n      });\n\n      const newAnnotation: OverlayGridAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          viewportData: new Map(),\n          pointSets,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * Calculates the point sets based on the image corners relative to an imageId\n   * @param imageId - The imageId to calculate the point sets for\n   * @returns\n   */\n  calculateImageIdPointSets = (imageId: string) => {\n    const {\n      imagePositionPatient,\n      rows,\n      columns,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n    } = metaData.get('imagePlaneModule', imageId);\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = <Types.Point3>[...imagePositionPatient];\n    const topRight = <Types.Point3>[...imagePositionPatient];\n    const bottomLeft = <Types.Point3>[...imagePositionPatient];\n    const bottomRight = <Types.Point3>[...imagePositionPatient];\n\n    vec3.scaleAndAdd(\n      topRight,\n      imagePositionPatient,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n    vec3.scaleAndAdd(\n      bottomLeft,\n      imagePositionPatient,\n      rowCosines,\n      rows * rowPixelSpacing\n    );\n\n    vec3.scaleAndAdd(\n      bottomRight,\n      bottomLeft,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    return { pointSet1, pointSet2 };\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n\n    let renderStatus = false;\n    if (!sourceImageIds?.length) {\n      return renderStatus;\n    }\n\n    const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n    const targetImageIds = targetViewport.getImageIds();\n    if (targetImageIds.length < 2) {\n      return renderStatus;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n    const imageIdNormal = <Types.Point3>(\n      this.getImageIdNormal(sourceImageIds[0])\n    );\n\n    if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    const pointSets = annotation.data.pointSets;\n    const viewportData = annotation.data.viewportData;\n    for (let i = 0; i < sourceImageIds.length; i++) {\n      // check if pointSets for the imageId was calculated. If not calculate and store\n      const { pointSet1, pointSet2 } = pointSets[i];\n\n      const targetData =\n        viewportData.get(targetViewport.id) ||\n        this.initializeViewportData(viewportData, targetViewport.id);\n\n      // check if pointSetToUse was calculated. If not calculate and store\n      if (!targetData.pointSetsToUse[i]) {\n        let pointSetToUse = pointSet1;\n\n        let topBottomVec = vec3.subtract(\n          vec3.create(),\n          pointSet1[0],\n          pointSet1[1]\n        );\n        topBottomVec = vec3.normalize(\n          vec3.create(),\n          topBottomVec\n        ) as Types.Point3;\n\n        // check if it is perpendicular to the viewPlaneNormal which means\n        // the line does not intersect the viewPlaneNormal\n        if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n          // 'use pointSet2';\n          pointSetToUse = pointSet2;\n        }\n\n        targetData.pointSetsToUse[i] = pointSetToUse;\n\n        targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[0],\n          pointSetToUse[1],\n          targetViewportPlane\n        );\n\n        targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[2],\n          pointSetToUse[3],\n          targetViewportPlane\n        );\n      }\n\n      const lineStartWorld = targetData.lineStartsWorld[i];\n      const lineEndWorld = targetData.lineEndsWorld[i];\n\n      styleSpecifier.annotationUID = annotationUID;\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n        targetViewport.worldToCanvas(world)\n      );\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = `${i}`;\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n    }\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  private initializeViewportData = (viewportData, id) => {\n    viewportData.set(id, {\n      pointSetsToUse: [],\n      lineStartsWorld: [],\n      lineEndsWorld: [],\n    });\n\n    return viewportData.get(id);\n  };\n\n  private isPerpendicular = (\n    vec1: Types.Point3,\n    vec2: Types.Point3\n  ): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  private getImageIdNormal(imageId: string): vec3 {\n    const { imageOrientationPatient } = metaData.get(\n      'imagePlaneModule',\n      imageId\n    );\n    const rowCosineVec = vec3.fromValues(\n      imageOrientationPatient[0],\n      imageOrientationPatient[1],\n      imageOrientationPatient[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      imageOrientationPatient[3],\n      imageOrientationPatient[4],\n      imageOrientationPatient[5]\n    );\n    return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n  }\n}\n\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { Annotation } from '../types';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\n\nexport interface SegmentationIntersectionAnnotation extends Annotation {\n  data: {\n    actorsWorldPointsMap: Map<string, Map<string, object>>;\n  };\n}\n\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        opacity: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Initialize the annotation data and calculates surface intersections\n   * @returns\n   */\n  _init = (): void => {\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn(this.getToolName() + 'Tool: No viewports found');\n      return;\n    }\n\n    const firstViewport = getRenderingEngine(\n      viewportsInfo[0].renderingEngineId\n    )?.getViewport(viewportsInfo[0].viewportId);\n\n    if (!firstViewport) {\n      return;\n    }\n    const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const actorsWorldPointsMap = new Map();\n      calculateSurfaceSegmentationIntersections(\n        actorsWorldPointsMap,\n        viewportsInfo\n      );\n      const newAnnotation: SegmentationIntersectionAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          actorsWorldPointsMap,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    this._init();\n  };\n\n  /**\n   * Renders the surface intersections\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    let renderStatus = false;\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n    const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n\n    actorEntries.forEach((actorEntry) => {\n      if (!actorEntry?.clippingFilter) {\n        return;\n      }\n      const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n      if (!actorWorldPointMap) {\n        return;\n      }\n      if (!actorWorldPointMap.get(cacheId)) {\n        return;\n      }\n      let polyLineIdx = 1;\n      const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n      for (let i = 0; i < worldPointsSet.length; i++) {\n        const worldPoints = worldPointsSet[i];\n        const canvasPoints = worldPoints.map((point) =>\n          viewport.worldToCanvas(point)\n        );\n\n        const options = {\n          color: color,\n          fillColor: color,\n          fillOpacity: this.configuration.opacity,\n          closePath: true,\n          lineWidth: 2,\n        };\n\n        const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n        drawPath(\n          svgDrawingHelper,\n          annotationUID,\n          polyLineUID,\n          canvasPoints,\n          options\n        );\n        polyLineIdx++;\n      }\n    });\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a list of viewports\n * @param actorWorldPointsMap\n * @param viewportsInfo\n */\nfunction calculateSurfaceSegmentationIntersections(\n  actorsWorldPointsMap,\n  viewportsInfo\n) {\n  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n    const viewport =\n      getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n  });\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a viewport\n * generating a set of polyline points for each actor\n * @param actorWorldPointsMap\n * @param viewport\n */\nfunction calculateSurfaceSegmentationIntersectionsForViewport(\n  actorsWorldPointsMap,\n  viewport\n) {\n  const actorEntries = viewport.getActors();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = getCacheId(viewport);\n\n  actorEntries.forEach((actorEntry) => {\n    if (!actorEntry?.clippingFilter) {\n      return;\n    }\n\n    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n    if (!actorWorldPointsMap) {\n      actorWorldPointsMap = new Map();\n      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n    }\n    if (!actorWorldPointsMap.get(cacheId)) {\n      const polyData = actorEntry.clippingFilter.getOutputData();\n      const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n      if (!worldPointsSet) {\n        return;\n      }\n\n      // worldPointsSet = removeExtraPoints(viewport, worldPointsSet);\n      const colorArray = actorEntry.actor.getProperty().getColor();\n      const color = colorToString(colorArray);\n      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n    }\n  });\n}\n\nfunction getCacheId(viewport) {\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\n\n/**\n * Transform a color array into a string\n * @param colorArray\n * @returns\n */\nfunction colorToString(colorArray): string {\n  function colorComponentToString(component) {\n    let componentString = Math.floor(component * 255).toString(16);\n    if (componentString.length === 1) {\n      componentString = '0' + componentString;\n    }\n    return componentString;\n  }\n  return (\n    '#' +\n    colorComponentToString(colorArray[0]) +\n    colorComponentToString(colorArray[1]) +\n    colorComponentToString(colorArray[2])\n  );\n}\n\n/**\n * Remove duplicate and unnecessary points\n * @param worldPoints\n * @param canvasPoints\n * @returns\n */\nfunction removeExtraPoints(viewport, worldPointsSet) {\n  return worldPointsSet.map((worldPoints) => {\n    const canvasPoints = worldPoints.map((point) => {\n      const canvasPoint = viewport.worldToCanvas(point);\n      return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n    });\n\n    let lastPoint;\n    const newWorldPoints = [];\n    let newCanvasPoints = [];\n    // removing duplicate points\n    for (let i = 0; i < worldPoints.length; i++) {\n      if (lastPoint) {\n        if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n          newWorldPoints.push(worldPoints[i]);\n          newCanvasPoints.push(canvasPoints[i]);\n        }\n      }\n      lastPoint = canvasPoints[i];\n    }\n\n    // checking if a middle point is near the start\n    const firstPoint = newCanvasPoints[0];\n    for (\n      let j = Math.min(30, newCanvasPoints.length);\n      j < newCanvasPoints.length;\n      j++\n    ) {\n      if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n        newCanvasPoints = newCanvasPoints.slice(0, j);\n        return newWorldPoints.slice(0, j);\n      }\n    }\n    return newWorldPoints;\n  });\n}\n\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  Annotations,\n} from '../types';\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n *\n * Configuration:\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\n *\n * Only uses Active and Disabled state\n */\nclass ReferenceCursors extends AnnotationDisplayTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing = false;\n  isHandleOutsideImage = false;\n  _elementWithCursor: null | HTMLDivElement = null;\n  _currentCursorWorldPosition: null | Types.Point3 = null;\n  _currentCanvasPosition: null | Types.Point2 = null;\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\n  _disableCursorEnabled = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        displayThreshold: 5,\n        positionSync: true,\n        disableCursor: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this._disableCursorEnabled = this.configuration.disableCursor;\n  }\n\n  /**\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const { detail } = evt;\n    const { element, currentPoints } = detail;\n\n    //save current positions and current element the curser is hovering over\n    this._currentCursorWorldPosition = currentPoints.world;\n    this._currentCanvasPosition = currentPoints.canvas;\n    this._elementWithCursor = element;\n\n    const annotation = this.getActiveAnnotation(element);\n    if (annotation === null) {\n      this.createInitialAnnotation(currentPoints.world, element);\n      return false;\n    }\n    this.updateAnnotationPosition(element, annotation);\n    return false;\n  };\n\n  onSetToolActive(): void {\n    this._disableCursorEnabled = this.configuration.disableCursor;\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    enabledElements.forEach((element) => {\n      if (element) {\n        hideElementCursor(element.viewport.element);\n      }\n    });\n  }\n  onSetToolDisabled(): void {\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n    enabledElements.forEach((element) => {\n      if (element) {\n        resetElementCursor(element.viewport.element);\n      }\n    });\n  }\n\n  createInitialAnnotation = (\n    worldPos: Types.Point3,\n    element: HTMLDivElement\n  ): void => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      throw new Error('No enabled element found');\n    }\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    if (!viewPlaneNormal || !viewUp) {\n      throw new Error('Camera not found');\n    }\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [[...worldPos]] as [Types.Point3],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n      },\n    };\n\n    const annotations = getAnnotations(this.getToolName(), element);\n\n    if (annotations.length > 0) {\n      return null;\n    }\n    const annotationId = addAnnotation(annotation, element);\n\n    if (annotationId === null) {\n      return;\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\n    const annotations = getAnnotations(this.getToolName(), element);\n    if (!annotations.length) {\n      return null;\n    }\n    const targetAnnotation = annotations[0];\n    return targetAnnotation;\n  }\n\n  /**\n   * updates the position of the annotation to match the currently set world position\n   */\n  updateAnnotationPosition(\n    element: HTMLDivElement,\n    annotation: Annotation\n  ): void {\n    const worldPos = this._currentCursorWorldPosition;\n    if (!worldPos) {\n      return;\n    }\n    if (!annotation.data?.handles?.points) {\n      return;\n    }\n    annotation.data.handles.points = [[...worldPos]];\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      return;\n    }\n    const { renderingEngine } = enabledElement;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  //checks if we need to update the annotation position due to camera changes\n  onCameraModified = (evt: any): void => {\n    const eventDetail = evt.detail;\n    const { element, previousCamera, camera } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const viewport = enabledElement.viewport as\n      | Types.IVolumeViewport\n      | Types.IStackViewport;\n\n    //only react to changes for element with cursor, otherwise would cause infinite loop\n    if (element !== this._elementWithCursor) {\n      return;\n    }\n    //check if camera moved along its normal\n    const oldFocalPoint = previousCamera.focalPoint;\n    const cameraNormal = camera.viewPlaneNormal;\n    const newFocalPoint = camera.focalPoint;\n\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n    //check if focal point changed\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n      return;\n    }\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n    //dot product is 0 -> perpendicular\n    if (Math.abs(dotProduct) < 1e-2) {\n      return;\n    }\n\n    //need to update the position of the annotation since camera changed\n    if (!this._currentCanvasPosition) {\n      return;\n    }\n\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n    this._currentCursorWorldPosition = newWorldPos;\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n  };\n\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations {\n    //calculate distance of current viewport to annotation\n    if (!(annotations instanceof Array) || annotations.length === 0) {\n      return [];\n    }\n    const annotation = annotations[0];\n    const viewport = getEnabledElement(element)?.viewport;\n    if (!viewport) {\n      return [];\n    }\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, focalPoint } = camera;\n    if (!viewPlaneNormal || !focalPoint) {\n      return [];\n    }\n    const points = annotation.data?.handles?.points;\n    if (!(points instanceof Array) || points.length !== 1) {\n      return [];\n    }\n    const worldPos = points[0];\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\n  }\n\n  /**\n   * Draws the cursor representation on the enabledElement\n   * Checks if a stack change has happened and updates annotation in that case\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\n\n    //update stack position if position sync is enabled\n    if (this.configuration.positionSync && !isElementWithCursor) {\n      this.updateViewportImage(viewport);\n    }\n\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as Annotations;\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ReferenceCursor;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points } = handles;\n\n      if (!annotationUID) {\n        return renderStatus;\n      }\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidthBase = parseFloat(\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\n      );\n\n      const lineWidth =\n        typeof lineWidthBase === 'number' && isElementWithCursor\n          ? lineWidthBase\n          : lineWidthBase;\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (points[0].some((e) => isNaN(e))) {\n        return renderStatus;\n      }\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2];\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      const crosshairUIDs = {\n        upper: 'upper',\n        right: 'right',\n        lower: 'lower',\n        left: 'left',\n      };\n      const [x, y] = canvasCoordinates[0];\n      const centerSpace = isElementWithCursor ? 20 : 7;\n      const lineLength = isElementWithCursor ? 5 : 7;\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.upper,\n        [x, y - (centerSpace / 2 + lineLength)],\n        [x, y - centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.lower,\n        [x, y + (centerSpace / 2 + lineLength)],\n        [x, y + centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.right,\n        [x + (centerSpace / 2 + lineLength), y],\n        [x + centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.left,\n        [x - (centerSpace / 2 + lineLength), y],\n        [x - centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  updateViewportImage(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const currentMousePosition = this._currentCursorWorldPosition;\n\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\n        currentMousePosition,\n        viewport\n      );\n\n      if (closestIndex === null) {\n        return;\n      }\n      if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n        viewport.setImageIdIndex(closestIndex);\n      }\n    } else if (viewport instanceof VolumeViewport) {\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n      if (!focalPoint || !viewPlaneNormal) {\n        return;\n      }\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n      const currentDistance = utilities.planar.planeDistanceToPoint(\n        plane,\n        currentMousePosition,\n        true\n      );\n\n      if (Math.abs(currentDistance) < 0.5) {\n        return;\n      }\n      const normalizedViewPlane = vec3.normalize(\n        vec3.create(),\n        vec3.fromValues(...viewPlaneNormal)\n      );\n      const scaledPlaneNormal = vec3.scale(\n        vec3.create(),\n        normalizedViewPlane,\n        currentDistance\n      );\n      const newFocalPoint = vec3.add(\n        vec3.create(),\n        vec3.fromValues(...focalPoint),\n        scaledPlaneNormal\n      ) as Types.Point3;\n      //TODO: make check if new focal point is within bounds of volume\n      const isInBounds = true;\n      if (isInBounds) {\n        viewport.setCamera({ focalPoint: newFocalPoint });\n        const renderingEngine = viewport.getRenderingEngine();\n        if (renderingEngine) {\n          renderingEngine.renderViewport(viewport.id);\n        }\n      }\n    }\n  }\n}\n\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElementByIds,\n  getRenderingEngines,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport {\n  drawLine as drawLineSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../drawingSvg';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\n\n/**\n * @public\n * @class ScaleOverlayTool\n * @memberof Tools\n *\n * @classdesc Tool for displaying a scale overlay on the image.\n * @extends Tools.Base.BaseTool\n */\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    viewport: any;\n    annotation: ScaleOverlayAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        viewportId: '',\n        scaleLocation: 'bottom',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    // get viewports with tool enabled\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportIds) {\n      return;\n    }\n\n    // get enabled elements\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    let { viewport } = enabledElements[0];\n    const { FrameOfReferenceUID } = enabledElements[0];\n\n    // onCameraModified, configuration.viewportId is set to the active\n    // viewport Id, here we are setting the viewport variable to the\n    // viewport with the matching Id\n    if (this.configuration.viewportId) {\n      enabledElements.forEach((element) => {\n        if (element.viewport.id == this.configuration.viewportId) {\n          viewport = element.viewport;\n        }\n      });\n    }\n\n    if (!viewport) {\n      return;\n    }\n\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n    const viewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(viewport);\n\n    let annotation = this.editData.annotation;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    // if annotations have been created, get the annotation for the\n    // current viewport Id\n    if (annotations.length) {\n      annotation = annotations.filter(\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n      )[0] as ScaleOverlayAnnotation;\n    }\n\n    // viewportsWithAnnotations stores which viewports have an annotation,\n    // if the viewport does not have an annotation, create a new one\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\n      const newAnnotation: ScaleOverlayAnnotation = {\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: viewportCanvasCornersInWorld,\n          },\n          viewportId: viewport.id,\n        },\n      };\n\n      viewportsWithAnnotations.push(viewport.id);\n\n      addAnnotation(newAnnotation, viewport.element);\n      annotation = newAnnotation;\n    } else if (\n      this.editData.annotation &&\n      this.editData.annotation.data.viewportId == viewport.id\n    ) {\n      this.editData.annotation.data.handles.points =\n        viewportCanvasCornersInWorld;\n      this.editData.annotation.data.viewportId = viewport.id;\n    }\n\n    this.editData = {\n      viewport,\n      renderingEngine,\n      annotation,\n    };\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the viewport\n    // that the camera was modified on\n    this.configuration.viewportId = evt.detail.viewportId;\n    this._init();\n  };\n\n  /**\n   * Used to draw the scale annotation in each request animation\n   * frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   * @returns\n   */\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ) {\n    if (!this.editData.viewport) {\n      return;\n    }\n    const location = this.configuration.scaleLocation;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n    const annotation = annotations.filter(\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n    )[0];\n    const canvas = enabledElement.viewport.canvas;\n\n    const renderStatus = false;\n\n    if (!viewport) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const canvasSize = {\n      width: canvas.width,\n      height: canvas.height,\n    };\n\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\n    const hscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    const vscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    // Computes which scale size to use, ex: 100mm, 50mm\n    const scaleSize = this.computeScaleSize(\n      worldWidthViewport,\n      worldHeightViewport,\n      location\n    );\n\n    // Applies the scale with the predetermined size to the image in\n    // world coordinates, then converts them to canvas coordinates\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\n      scaleSize,\n      location,\n      pointSet1\n    ).map((world) => viewport.worldToCanvas(world));\n\n    // Uses the bounds and canvas size to center the scale\n    // based on the location\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\n      canvasSize,\n      canvasCoordinates,\n      vscaleBounds,\n      hscaleBounds,\n      location\n    );\n\n    // Computes the end scale ticks coordinates\n    const scaleTicks = this.computeEndScaleTicks(\n      scaleCanvasCoordinates,\n      location\n    );\n\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const scaleId = `${annotationUID}-scaleline`;\n    const scaleLineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      scaleLineUID,\n      scaleCanvasCoordinates[0],\n      scaleCanvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      scaleId\n    );\n    const leftTickId = `${annotationUID}-left`;\n    const leftTickUID = '2';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      leftTickUID,\n      scaleTicks.endTick1[0] as Types.Point2,\n      scaleTicks.endTick1[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      leftTickId\n    );\n    const rightTickId = `${annotationUID}-right`;\n    const rightTickUID = '3';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rightTickUID,\n      scaleTicks.endTick2[0] as Types.Point2,\n      scaleTicks.endTick2[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      rightTickId\n    );\n\n    const locationTextOffest = {\n      bottom: [-10, -42],\n      top: [-12, -35],\n      left: [-40, -20],\n      right: [-50, -20],\n    };\n\n    const textCanvasCoordinates = [\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n    ];\n    const textBoxLines = this._getTextLines(scaleSize);\n\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\n      scaleSize,\n      location,\n      annotationUID,\n      scaleTicks.endTick1,\n      scaleTicks.endTick2\n    );\n\n    // draws inner ticks for scale\n    for (let i = 0; i < tickUIDs.length; i++) {\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        tickUIDs[i],\n        tickCoordinates[i][0],\n        tickCoordinates[i][1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        tickIds[i]\n      );\n    }\n\n    const textUID = 'text0';\n    drawTextBoxSvg(\n      svgDrawingHelper,\n      annotationUID,\n      textUID,\n      textBoxLines,\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n      {\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        lineDash: '2,3',\n        lineWidth: '1',\n        shadow: true,\n        color: color,\n      }\n    );\n\n    return renderStatus;\n  }\n\n  _getTextLines(scaleSize: number): string[] | undefined {\n    let scaleSizeDisplayValue;\n    let scaleSizeUnits;\n    if (scaleSize >= 50) {\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\n      scaleSizeUnits = ' cm';\n    } else {\n      scaleSizeDisplayValue = scaleSize; //convert to cm\n      scaleSizeUnits = ' mm';\n    }\n\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n\n    return textLines;\n  }\n\n  /**\n   *\n   * @param worldWidthViewport\n   * @returns currentScaleSize\n   */\n  computeScaleSize = (\n    worldWidthViewport: number,\n    worldHeightViewport: number,\n    location: any\n  ) => {\n    const scaleSizes = [\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n    ];\n    let currentScaleSize;\n    if (location == 'top' || location == 'bottom') {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldWidthViewport * 0.6 &&\n          scaleSize > worldWidthViewport * 0.2\n      );\n    } else {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldHeightViewport * 0.6 &&\n          scaleSize > worldHeightViewport * 0.2\n      );\n    }\n\n    return currentScaleSize[0];\n  };\n\n  /**\n   *  calculates scale ticks for ends of the scale\n   * @param canvasCoordinates\n   * @returns leftTick, rightTick\n   */\n  computeEndScaleTicks = (canvasCoordinates, location) => {\n    const locationTickOffset = {\n      bottom: [\n        [0, -10],\n        [0, -10],\n      ],\n      top: [\n        [0, 10],\n        [0, 10],\n      ],\n      left: [\n        [0, 0],\n        [10, 0],\n      ],\n      right: [\n        [0, 0],\n        [-10, 0],\n      ],\n    };\n\n    const endTick1 = [\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n    const endTick2 = [\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n\n    return {\n      endTick1: endTick1,\n      endTick2: endTick2,\n    };\n  };\n\n  computeInnerScaleTicks = (\n    scaleSize: number,\n    location: string,\n    annotationUID: string,\n    leftTick: any[][],\n    rightTick: any[][]\n  ) => {\n    let canvasScaleSize;\n    if (location == 'bottom' || location == 'top') {\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n    } else if (location == 'left' || location == 'right') {\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n    }\n    const tickIds = [];\n    const tickUIDs = [];\n    const tickCoordinates = [];\n    let numberSmallTicks = scaleSize;\n\n    if (scaleSize >= 50) {\n      numberSmallTicks = scaleSize / 10;\n    }\n\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\n\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\n      const locationOffset = {\n        bottom: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), 5],\n        ],\n        top: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), -5],\n        ],\n        left: [\n          [0, tickSpacing * (i + 1)],\n          [-5, tickSpacing * (i + 1)],\n        ],\n        right: [\n          [0, tickSpacing * (i + 1)],\n          [5, tickSpacing * (i + 1)],\n        ],\n      };\n      tickIds.push(`${annotationUID}-tick${i}`);\n      tickUIDs.push(`tick${i}`);\n      if ((i + 1) % 5 == 0) {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][0][0],\n            leftTick[1][1] + locationOffset[location][0][1],\n          ],\n        ]);\n      } else {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][1][0],\n            leftTick[1][1] + locationOffset[location][1][1],\n          ],\n        ]);\n      }\n    }\n\n    return { tickIds, tickUIDs, tickCoordinates };\n  };\n\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n    let worldCoordinates;\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const midpointLocation = {\n      bottom: [pointSet[1], pointSet[2]],\n      top: [pointSet[0], pointSet[3]],\n      right: [pointSet[2], pointSet[3]],\n      left: [pointSet[0], pointSet[1]],\n    };\n\n    const midpoint = vec3\n      .add(\n        vec3.create(),\n        midpointLocation[location][0],\n        midpointLocation[location][0]\n      )\n      .map((i) => i / 2) as Types.Point3;\n\n    const offset =\n      scaleSize /\n      2 /\n      Math.sqrt(\n        Math.pow(topBottomVec[0], 2) +\n          Math.pow(topBottomVec[1], 2) +\n          Math.pow(topBottomVec[2], 2)\n      );\n\n    if (location == 'top' || location == 'bottom') {\n      worldCoordinates = [\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    } else if (location == 'left' || location == 'right') {\n      worldCoordinates = [\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    }\n\n    return worldCoordinates;\n  };\n\n  /**\n   * Computes the centered canvas coordinates for scale\n   * @param canvasSize\n   * @param canvasCoordinates\n   * @param vscaleBounds\n   * @returns scaleCanvasCoordinates\n   */\n  computeCanvasScaleCoordinates = (\n    canvasSize,\n    canvasCoordinates,\n    vscaleBounds,\n    hscaleBounds,\n    location\n  ) => {\n    let scaleCanvasCoordinates;\n    if (location == 'top' || location == 'bottom') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\n      scaleCanvasCoordinates = [\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n      ];\n    } else if (location == 'left' || location == 'right') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\n      scaleCanvasCoordinates = [\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n      ];\n    }\n\n    return scaleCanvasCoordinates;\n  };\n\n  /**\n   * Computes the max bound for scales on the image\n   * @param  {{width: number, height: number}} canvasSize\n   * @param  {number} horizontalReduction\n   * @param  {number} verticalReduction\n   * @returns {Object.<string, { x:number, y:number }>}\n   */\n  computeScaleBounds = (\n    canvasSize,\n    horizontalReduction,\n    verticalReduction,\n    location\n  ) => {\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n    const locationBounds = {\n      bottom: [-vReduction, -hReduction],\n      top: [vReduction, hReduction],\n      left: [vReduction, hReduction],\n      right: [-vReduction, -hReduction],\n    };\n    const canvasBounds = {\n      bottom: [canvasSize.height, canvasSize.width],\n      top: [0, canvasSize.width],\n      left: [canvasSize.height, 0],\n      right: [canvasSize.height, canvasSize.width],\n    };\n\n    return {\n      height: canvasBounds[location][0] + locationBounds[location][0],\n      width: canvasBounds[location][1] + locationBounds[location][1],\n    };\n  };\n}\n\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * LengthTool let you draw annotations that measures the length of two drawing\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(LengthTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(LengthTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(LengthTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass LengthTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const {\n      viewPlaneNormal,\n      viewUp,\n      position: cameraPosition,\n    } = viewport.getCamera();\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        ...viewport.getViewReference({ points: [worldPos] }),\n        toolName: this.getToolName(),\n        referencedImageId,\n        viewUp,\n        cameraPosition,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      // Need to update to sync with annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const handles = [index1, index2];\n      const { scale, units } = getCalibratedLengthUnitsAndScale(image, handles);\n\n      const length = this._calculateLength(worldPos1, worldPos2) / scale;\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        length,\n        unit: units,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { length, unit } = cachedVolumeStats;\n\n  // Can be null on load\n  if (length === undefined || length === null || isNaN(length)) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(length)} ${unit}`];\n\n  return textLines;\n}\n\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * ProbeTool let you get the underlying voxel value by putting a probe in that\n * location. It will give index of the location and value of the voxel.\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Probe tool's text box are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\n *\n * ```js\n * cornerstoneTools.addTool(ProbeTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(ProbeTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(ProbeTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n *\n */\n\nclass ProbeTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  // Not necessary for this tool but needs to be defined since it's an abstract\n  // method from the parent class.\n  isPointNearTool(): boolean {\n    return false;\n  }\n\n  toolSelectedCallback() {}\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Probe Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\n   * getHandleNearImagePoint method.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: ProbeAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const point = data.handles.points[0];\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n    const near =\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n    if (near === true) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ProbeAnnotation\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      //handle, // This would be useful for other tools with more than one handle\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    const { viewportId, renderingEngine } = getEnabledElement(element);\n    this.eventDispatchDetail = {\n      viewportId,\n      renderingEngineId: renderingEngine.id,\n    };\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragCallback = (evt) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points[0] = [...worldPos];\n    annotation.invalidated = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the probe annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ProbeAnnotation;\n      const annotationUID = annotation.annotationUID;\n      const data = annotation.data;\n      const point = data.handles.points[0];\n      const canvasCoordinates = viewport.worldToCanvas(point);\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({ annotation, styleSpecifier });\n\n      if (!data.cachedStats) {\n        data.cachedStats = {};\n      }\n\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].value == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          index: null,\n          value: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [canvasCoordinates],\n        { color }\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (textLines) {\n        const textCanvasCoordinates = [\n          canvasCoordinates[0] + 6,\n          canvasCoordinates[1] - 6,\n        ];\n\n        const textUID = '0';\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textUID,\n          textLines,\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n          options\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { renderingEngineId, viewport } = enabledElement;\n    const { element } = viewport;\n\n    const worldPos = data.handles.points[0];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const modality = metadata.Modality;\n      const index = transformWorldToIndex(imageData, worldPos);\n\n      index[0] = Math.round(index[0]);\n      index[1] = Math.round(index[1]);\n      index[2] = Math.round(index[2]);\n\n      const samplesPerPixel =\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const yMultiple = dimensions[0] * samplesPerPixel;\n        const zMultiple = dimensions[0] * dimensions[1] * samplesPerPixel;\n\n        const baseIndex =\n          index[2] * zMultiple +\n          index[1] * yMultiple +\n          index[0] * samplesPerPixel;\n        let value =\n          samplesPerPixel > 2\n            ? [\n                scalarData[baseIndex],\n                scalarData[baseIndex + 1],\n                scalarData[baseIndex + 2],\n              ]\n            : scalarData[baseIndex];\n\n        // Index[2] for stackViewport is always 0, but for visualization\n        // we reset it to be imageId index\n        if (targetId.startsWith('imageId:')) {\n          const imageId = targetId.split('imageId:')[1];\n          const imageURI = csUtils.imageIdToURI(imageId);\n          const viewports = csUtils.getViewportsWithImageURI(\n            imageURI,\n            renderingEngineId\n          );\n\n          const viewport = viewports[0];\n\n          index[2] = viewport.getCurrentImageIdIndex();\n        }\n\n        let modalityUnit;\n\n        if (modality === 'US') {\n          const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n            index,\n          ]);\n\n          const hasEnhancedRegionValues = calibratedResults.values.every(\n            (value) => value !== null\n          );\n\n          value = hasEnhancedRegionValues ? calibratedResults.values : value;\n          modalityUnit = hasEnhancedRegionValues\n            ? calibratedResults.units\n            : 'raw';\n        } else {\n          modalityUnit = getModalityUnit(\n            modality,\n            annotation.metadata.referencedImageId,\n            modalityUnitOptions\n          );\n        }\n\n        cachedStats[targetId] = {\n          index,\n          value,\n          Modality: modality,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          index,\n          Modality: modality,\n        };\n      }\n\n      annotation.invalidated = false;\n\n      // Dispatching annotation modified\n      triggerAnnotationModified(annotation, element);\n    }\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  if (value instanceof Array && modalityUnit instanceof Array) {\n    for (let i = 0; i < value.length; i++) {\n      textLines.push(`${roundNumber(value[i])} ${modalityUnit[i]}`);\n    }\n  } else {\n    textLines.push(`${roundNumber(value)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  PublicToolProps,\n  SVGDrawingHelper,\n  ToolProps,\n} from '../../types';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nclass DragProbeTool extends ProbeTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  postMouseDownCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation: ProbeAnnotation = {\n      invalidated: true,\n      highlighted: true,\n      isVisible: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  postTouchStartCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    return this.postMouseDownCallback(evt);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const annotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      [this.editData.annotation]\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const annotation = this.editData.annotation;\n    const annotationUID = annotation.annotationUID;\n    const data = annotation.data;\n    const point = data.handles.points[0];\n    const canvasCoordinates = viewport.worldToCanvas(point);\n\n    styleSpecifier.annotationUID = annotationUID;\n\n    const { color } = this.getAnnotationStyle({\n      annotation,\n      styleSpecifier,\n    });\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].value == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        index: null,\n        value: null,\n      };\n\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    } else if (annotation.invalidated) {\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    }\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const handleGroupUID = '0';\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      [canvasCoordinates],\n      { color }\n    );\n\n    renderStatus = true;\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (textLines) {\n      const textCanvasCoordinates = [\n        canvasCoordinates[0] + 6,\n        canvasCoordinates[1] - 6,\n      ];\n\n      const textUID = '0';\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textUID,\n        textLines,\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n    }\n\n    return renderStatus;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  ToolProps,\n  PublicToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * RectangleROIAnnotation let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of a Rectangular region of interest.\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(RectangleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(RectangleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(RectangleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass RectangleROITool extends AnnotationTool {\n  static toolName;\n\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): RectangleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: RectangleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]];\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point as Types.Point2\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - Move the text boxes world position\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventDetail;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param viewPlaneNormal - The normal vector of the camera.\n   * @param viewUp - The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const scale = getCalibratedScale(image);\n\n        const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          stdDev: stats.stdDev?.value,\n          max: stats.max?.value,\n          statsArray: stats.array,\n          pointsInShape: pointsInShape,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data, targetId: string): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawEllipseByCoordinates as drawEllipseSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  pointInEllipse,\n  getCanvasEllipseCorners,\n} from '../../utilities/math/ellipse';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * EllipticalROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(EllipticalROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(EllipticalROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass EllipticalROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    centerWorld?: Array<number>;\n    canvasWidth?: number;\n    canvasHeight?: number;\n    originalHandleCanvas?: Array<number>;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the ellipse.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a EllipticalROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): EllipticalROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        initialRotation: viewport.getRotation(),\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      centerWorld: worldPos,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: EllipticalROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\n\n    const minorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n    };\n\n    const majorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n    };\n\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\n      minorEllipse,\n      canvasCoords\n    );\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\n      majorEllipse,\n      canvasCoords\n    );\n\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    let centerCanvas;\n    let centerWorld;\n    let canvasWidth;\n    let canvasHeight;\n    let originalHandleCanvas;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n      const { viewport } = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = viewport;\n\n      handleIndex = points.findIndex((p) => p === handle);\n\n      const pointsCanvas = points.map(worldToCanvas);\n\n      originalHandleCanvas = pointsCanvas[handleIndex];\n\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n\n      centerCanvas = [\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n      ];\n\n      centerWorld = canvasToWorld(centerCanvas);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      canvasWidth,\n      canvasHeight,\n      centerWorld,\n      originalHandleCanvas,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the ellipse,\n    // and they are by definition not in the ellipse on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerWorld } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n\n    // Todo: why bottom is -dY, it should be +dY\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { viewport } = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = viewport;\n\n    const {\n      annotation,\n      canvasWidth,\n      canvasHeight,\n      handleIndex,\n      centerWorld,\n      originalHandleCanvas,\n    } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0 || handleIndex === 1) {\n      // Dragging top or bottom point\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - dYCanvas,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n    } else {\n      // Dragging left or right point\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - dXCanvas,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + dXCanvas,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - newHalfCanvasHeight,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + newHalfCanvasHeight,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the ellipticalROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as EllipticalROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\n\n      const rotation = Math.abs(\n        viewport.getRotation() - (data.initialRotation || 0)\n      );\n      const canvasCorners = <Array<Types.Point2>>(\n        getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\n      );\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-ellipse`;\n      const ellipseUID = '0';\n      drawEllipseSvg(\n        svgDrawingHelper,\n        annotationUID,\n        ellipseUID,\n        canvasCoordinates,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        const minRadius = Math.min(\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\n        );\n        if (minRadius > 3 * centerPointRadius) {\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${ellipseUID}-center`,\n            centerPoint,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { element } = viewport;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasEllipseCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const area =\n          Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n          scale /\n          scale;\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          max: stats.max?.value,\n          stdDev: stats.stdDev?.value,\n          statsArray: stats.array,\n          pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  /**\n   * This is a temporary function to use the old ellipse's canvas-based\n   * calculation for isPointNearTool, we should move the the world-based\n   * calculation to the tool's isPointNearTool function.\n   *\n   * @param ellipse - The ellipse object\n   * @param location - The location to check\n   * @returns True if the point is inside the ellipse\n   */\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\n    const xRadius = ellipse.width / 2;\n    const yRadius = ellipse.height / 2;\n\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\n      return false;\n    }\n\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n    const normalized = [location[0] - center[0], location[1] - center[1]];\n\n    const inEllipse =\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n      1.0;\n\n    return inEllipse;\n  }\n\n  /**\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\n   *\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n   * @returns center point.\n   */\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [\n      (topLeft[0] + bottomRight[0]) / 2,\n      (topLeft[1] + bottomRight[1]) / 2,\n    ] as Types.Point2;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n  getCalibratedAspect,\n} from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * CircleROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(CircleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(CircleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(CircleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass CircleROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the circle.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CircleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CircleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const radius = getCanvasCircleRadius(canvasCoordinates);\n    const radiusPoint = getCanvasCircleRadius([\n      canvasCoordinates[0],\n      canvasCoords,\n    ]);\n\n    if (Math.abs(radiusPoint - radius) < proximity / 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points = [\n      data.handles.points[0], // center stays\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n\n    const { annotation, handleIndex } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0) {\n      // Dragging center, move the circle ROI\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n\n      const canvasCenter = currentCanvasPoints as Types.Point2;\n      const canvasEnd = <Types.Point2>[\n        canvasCoordinates[1][0] + dXCanvas,\n        canvasCoordinates[1][1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasCenter);\n      points[1] = canvasToWorld(canvasEnd);\n    } else {\n      // Dragging end point, center stays\n      points[1] = canvasToWorld(currentCanvasPoints);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n          radius: null,\n          radiusUnit: null,\n          perimeter: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-circle`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { element } = viewport;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(\n          Math.PI *\n            (worldWidth / scale / 2) *\n            (worldHeight / aspect / scale / 2)\n        );\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) =>\n            pointInEllipse(ellipseObj, pointLPS, {\n              fast: true,\n            }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          max: stats.max?.value,\n          stdDev: stats.stdDev?.value,\n          statsArray: stats.array,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          radius: worldWidth / 2 / scale,\n          radiusUnit: getCalibratedLengthUnits(null, image),\n          perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    radius,\n    radiusUnit,\n    area,\n    mean,\n    stdDev,\n    max,\n    isEmptyArea,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (radius) {\n    const radiusLine = isEmptyArea\n      ? `Radius: Oblique not supported`\n      : `Radius: ${roundNumber(radius)} ${radiusUnit}`;\n    textLines.push(radiusLine);\n  }\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n  utilities,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getChildAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport {\n  Events,\n  MouseBindings,\n  KeyboardBindings,\n  ChangeTypes,\n} from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport type {\n  Annotation,\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  AnnotationRenderContext,\n} from '../../types';\nimport {\n  math,\n  throttle,\n  roundNumber,\n  triggerAnnotationRenderForViewportIds,\n  getCalibratedScale,\n  getCalibratedAreaUnits,\n} from '../../utilities';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\n\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport type { SplineROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport type {\n  AnnotationModifiedEventDetail,\n  ContourAnnotationCompletedEventDetail,\n} from '../../types/EventTypes';\nimport { ISpline } from '../../types/ISpline';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\n\nconst DEFAULT_SPLINE_CONFIG = {\n  resolution: 20,\n  controlPointAdditionDistance: 6,\n  controlPointDeletionDistance: 6,\n  showControlPointsConnectors: false,\n  controlPointAdditionEnabled: true,\n  controlPointDeletionEnabled: true,\n};\n\nenum SplineTypesEnum {\n  Cardinal = 'CARDINAL',\n  Linear = 'LINEAR',\n  CatmullRom = 'CATMULLROM',\n  BSpline = 'BSPLINE',\n}\n\nenum SplineToolActions {\n  AddControlPoint = 'addControlPoint',\n  DeleteControlPoint = 'deleteControlPoint',\n}\n\nclass SplineROITool extends ContourSegmentationBaseTool {\n  static toolName;\n  static SplineTypes = SplineTypesEnum;\n  static Actions = SplineToolActions;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: SplineROIAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n    contourHoleProcessingEnabled?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n  fireChangeOnUpdate: {\n    annotationUID: string;\n    changeType: ChangeTypes;\n    contourHoleProcessingEnabled: boolean;\n  } = null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n        spline: {\n          configuration: {\n            [SplineTypesEnum.Cardinal]: {\n              Class: CardinalSpline,\n              scale: 0.5,\n            },\n            [SplineTypesEnum.CatmullRom]: {\n              Class: CatmullRomSpline,\n            },\n            [SplineTypesEnum.Linear]: {\n              Class: LinearSpline,\n            },\n            [SplineTypesEnum.BSpline]: {\n              Class: BSpline,\n              controlPointAdditionEnabled: false,\n              controlPointDeletionEnabled: false,\n              showControlPointsConnectors: true,\n            },\n          },\n          type: SplineTypesEnum.CatmullRom,\n          drawPreviewEnabled: true,\n          lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n        },\n        actions: {\n          [SplineToolActions.AddControlPoint]: {\n            method: 'addControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n          [SplineToolActions.DeleteControlPoint]: {\n            method: 'deleteControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Ctrl,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(evt: EventTypes.InteractionEventType): SplineROIAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const contourHoleProcessingEnabled =\n      getMouseModifierKey(evt.detail.event) ===\n      this.configuration.contourHoleAdditionModifierKey;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const annotation = this.createAnnotation(evt) as SplineROIAnnotation;\n\n    this.isDrawing = true;\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      lastCanvasPoint: canvasPos,\n      contourHoleProcessingEnabled,\n    };\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { instance: spline } = annotation.data.spline;\n\n    return spline.isPointNearCurve(canvasCoords, proximity);\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      contourHoleProcessingEnabled,\n    } = this.editData;\n    const { data } = annotation;\n    annotation.autoGenerated = false;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    // Decide whether there's at least one point is outside image\n    const image = this.getTargetIdImage(\n      this.getTargetId(enabledElement.viewport),\n      enabledElement.renderingEngine\n    );\n    const { imageData, dimensions } = image;\n    this.isHandleOutsideImage = data.handles.points\n      .map((p) => utilities.transformWorldToIndex(imageData, p))\n      .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const changeType = newAnnotation\n      ? ChangeTypes.Completed\n      : ChangeTypes.HandlesUpdated;\n    if (!this.fireChangeOnUpdate) {\n      this.fireChangeOnUpdate = {\n        annotationUID: annotation.annotationUID,\n        changeType,\n        contourHoleProcessingEnabled,\n      };\n    } else {\n      this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n      this.fireChangeOnUpdate.changeType = changeType;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  private _keyDownCallback = (evt: EventTypes.KeyDownEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const key = eventDetail.key ?? '';\n    const { lastControlPointDeletionKeys } = this.configuration.spline;\n    const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n\n    if (!deleteLastPoint) {\n      return;\n    }\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length === SPLINE_MIN_POINTS) {\n      this.cancel(element);\n      return;\n    } else {\n      const controlPointIndex = data.handles.points.length - 1;\n      this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { drawPreviewEnabled } = this.configuration.spline;\n\n    // Does not force a re-render if preview is not enabled\n    if (!drawPreviewEnabled) {\n      return;\n    }\n\n    const { element } = evt.detail;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    if (data.contour.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    let closeContour = data.handles.points.length >= 2 && doubleClick;\n    let addNewPoint = true;\n\n    // Check if user clicked on the first point to close the curve\n    if (data.handles.points.length >= 3) {\n      const { instance: spline } = data.spline;\n      const closestControlPoint = spline.getClosestControlPointWithinDistance(\n        canvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      if (closestControlPoint?.index === 0) {\n        addNewPoint = false;\n        closeContour = true;\n      }\n    }\n\n    if (addNewPoint) {\n      data.handles.points.push(worldPoint);\n    }\n\n    data.contour.closed = data.contour.closed || closeContour;\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (data.contour.closed) {\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      this.moveAnnotation(annotation, worldPosDelta);\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel(element: HTMLDivElement) {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    super.cancelAnnotation(annotation);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    return annotation.annotationUID;\n  }\n\n  /**\n   * Triggers an annotation completed event.\n   */\n  triggerAnnotationCompleted = (\n    annotation: SplineROIAnnotation,\n    contourHoleProcessingEnabled: boolean\n  ): void => {\n    const eventType = Events.ANNOTATION_COMPLETED;\n    const eventDetail: ContourAnnotationCompletedEventDetail = {\n      annotation,\n      changeType: ChangeTypes.Completed,\n      contourHoleProcessingEnabled,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    const eventType = Events.ANNOTATION_MODIFIED;\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n      changeType,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation complete or modified event based on changeType.\n   */\n  triggerChangeEvent = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated,\n    contourHoleProcessingEnabled\n  ): void => {\n    if (changeType === ChangeTypes.Completed) {\n      this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    } else {\n      this.triggerAnnotationModified(annotation, enabledElement, changeType);\n    }\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for SplineContourSegmentationTool\n    return false;\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, targetId, svgDrawingHelper, annotationStyle } =\n      renderContext;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { element } = viewport;\n    const annotation = renderContext.annotation as SplineROIAnnotation;\n    const { annotationUID, data, highlighted } = annotation;\n    const { handles } = data;\n    const { points: controlPoints, activeHandleIndex } = handles;\n    const newAnnotation = this.editData?.newAnnotation;\n\n    const {\n      lineWidth,\n      lineDash,\n      color,\n      locked: annotationLocked,\n    } = annotationStyle;\n\n    const canvasCoordinates = controlPoints.map((p) =>\n      worldToCanvas(p)\n    ) as Types.Point2[];\n\n    const { drawPreviewEnabled } = this.configuration.spline;\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = annotation.data.spline.instance;\n\n    const childAnnotations = getChildAnnotations(annotation);\n    const missingAnnotation = childAnnotations.findIndex((it) => !it);\n    if (missingAnnotation !== -1) {\n      // Child annotations go AWOL for a variety of reasons, so report is specifically here\n      throw new Error(\n        `Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`\n      );\n    }\n    // Update current and all child annotations/splines\n    const splineAnnotationsGroup = [annotation, ...childAnnotations].filter(\n      (annotation) => this._isSplineROIAnnotation(annotation)\n    ) as SplineROIAnnotation[];\n\n    splineAnnotationsGroup.forEach((annotation) => {\n      const spline = this._updateSplineInstance(element, annotation);\n      const splinePolylineCanvas = spline.getPolylinePoints();\n\n      this.updateContourPolyline(\n        annotation,\n        {\n          points: splinePolylineCanvas,\n          closed: data.contour.closed,\n          targetWindingDirection: ContourWindingDirection.Clockwise,\n        },\n        viewport\n      );\n    });\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    // If cachedStats does not exist, or the areaUnit is missing (as part of\n    // import/hydration etc.), force to recalculate the stats from the points\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].areaUnit == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        area: null,\n        areaUnit: null,\n      };\n\n      this._calculateCachedStats(annotation, element);\n    } else if (annotation.invalidated) {\n      this._throttledCalculateCachedStats(annotation, element);\n    }\n\n    let activeHandleCanvasCoords;\n\n    if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n      // Not locked or creating and hovering over handle, so render handle.\n      activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n    }\n\n    if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n      const handleGroupUID = '0';\n\n      // Move this call to the base class (contour seg) in the near future\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates,\n        {\n          color,\n          lineWidth: Math.max(1, lineWidth),\n          handleRadius: '3',\n        }\n      );\n    }\n\n    if (\n      drawPreviewEnabled &&\n      spline.numControlPoints > 1 &&\n      this.editData?.lastCanvasPoint &&\n      !spline.closed\n    ) {\n      const { lastCanvasPoint } = this.editData;\n      const previewPolylinePoints = spline.getPreviewPolylinePoints(\n        lastCanvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'previewSplineChange',\n        previewPolylinePoints,\n        {\n          color: '#9EA0CA',\n          lineDash,\n          lineWidth: 1,\n        }\n      );\n    }\n\n    if (splineConfig.showControlPointsConnectors) {\n      const controlPointsConnectors = [...canvasCoordinates];\n\n      // Connect the last point to the first one when the spline is closed\n      if (spline.closed) {\n        controlPointsConnectors.push(canvasCoordinates[0]);\n      }\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'controlPointsConnectors',\n        controlPointsConnectors,\n        {\n          color: 'rgba(255, 255, 255, 0.5)',\n          lineWidth: 1,\n        }\n      );\n    }\n\n    this._renderStats(\n      annotation,\n      viewport,\n      svgDrawingHelper,\n      annotationStyle.textbox\n    );\n\n    if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n      this.triggerChangeEvent(\n        annotation,\n        enabledElement,\n        this.fireChangeOnUpdate.changeType,\n        this.fireChangeOnUpdate.contourHoleProcessingEnabled\n      );\n      this.fireChangeOnUpdate = null;\n    }\n\n    annotation.invalidated = false;\n    return true;\n  }\n\n  /**\n   * Creates new interpolated handles for the spline control given the\n   * polyline data.  This allows creating the spline from polyline data\n   * directly.\n   */\n  protected createInterpolatedSplineControl(annotation) {\n    if (annotation.data.handles.points?.length) {\n      // The interpolation itself created the handles\n      return;\n    }\n    const { polyline } = annotation.data.contour;\n    if (!polyline || !polyline.length) {\n      return;\n    }\n    annotation.data.handles.points = [];\n    const { points } = annotation.data.handles;\n    const increment = Math.max(10, Math.floor(polyline.length / 20));\n    for (let i = 0; i < polyline.length - increment; i += increment) {\n      points.push(polyline[i]);\n    }\n    points.push(polyline[polyline.length - 1]);\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const contourAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n    const { type: splineType } = this.configuration.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = new splineConfig.Class();\n    const createSpline = () => ({\n      type: splineConfig.type,\n      instance: spline,\n      resolution: splineConfig.resolution,\n    });\n\n    // Add an action to create a new spline data on creating an interpolated\n    // instance.\n    let onInterpolationComplete;\n    if (this.configuration.interpolation?.enabled) {\n      onInterpolationComplete = (annotation) => {\n        annotation.data.spline ||= createSpline();\n        this.createInterpolatedSplineControl(annotation);\n      };\n    }\n\n    return <SplineROIAnnotation>utilities.deepMerge(contourAnnotation, {\n      data: {\n        handles: {\n          points: [[...worldPos]],\n        },\n        spline: createSpline(),\n        cachedStats: {},\n      },\n      onInterpolationComplete,\n    });\n  }\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    svgDrawingHelper,\n    textboxStyle\n  ) => {\n    const data = annotation.data;\n    const targetId = this.getTargetId(viewport);\n\n    if (!data.spline.instance.closed || !textboxStyle.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = 'textBox';\n    const boundingBox = drawLinkedTextBoxSvg(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      textboxStyle\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n\n  addControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const { data } = annotation;\n    const splineType = data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointAdditionDistance;\n\n    if (splineConfig.controlPointAdditionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    const { instance: spline } = data.spline;\n    const canvasPos = evt.detail.currentPoints.canvas;\n    const closestPointInfo = spline.getClosestPoint(canvasPos);\n\n    if (closestPointInfo.distance > maxDist) {\n      return;\n    }\n\n    // Add a point at the `u` position from Parameter Space\n    const { index, point: canvasPoint } = spline.addControlPointAtU(\n      closestPointInfo.uValue\n    );\n\n    data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  private _deleteControlPointByIndex(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    controlPointIndex: number\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { points: controlPoints } = annotation.data.handles;\n\n    // There is no curve with only 2 points\n    if (controlPoints.length === 3) {\n      removeAnnotation(annotation.annotationUID);\n    } else {\n      controlPoints.splice(controlPointIndex, 1);\n    }\n\n    const { renderingEngine } = enabledElement;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    annotation.invalidated = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  deleteControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointDeletionDistance;\n\n    if (splineConfig.controlPointDeletionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const { instance: spline } = annotation.data.spline;\n    const closestControlPoint = spline.getClosestControlPointWithinDistance(\n      canvasPos,\n      maxDist\n    );\n\n    if (!closestControlPoint) {\n      return;\n    }\n\n    this._deleteControlPointByIndex(\n      element,\n      annotation,\n      closestControlPoint.index\n    );\n  };\n\n  _isSplineROIAnnotation(\n    annotation: Annotation\n  ): annotation is SplineROIAnnotation {\n    return !!(<SplineROIAnnotation>annotation).data?.spline;\n  }\n\n  /**\n   * Get a spline config merged with the default settings.\n   * @param type - Spline type (CARDINAL, CATMULLROM, LINEAR or BSPLINE)\n   * @returns Spline configuration\n   */\n  private _getSplineConfig(type: string) {\n    const { configuration: config } = this;\n    const splineConfigs = config.spline.configuration;\n\n    return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n  }\n\n  private _updateSplineInstance(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation\n  ): ISpline {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { data } = annotation;\n    const { type: splineType, instance: spline } = annotation.data.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const worldPoints = data.handles.points;\n    const canvasPoints = worldPoints.map(worldToCanvas);\n    const resolution =\n      splineConfig.resolution !== undefined\n        ? parseInt(splineConfig.resolution)\n        : undefined;\n    const scale =\n      splineConfig.scale !== undefined\n        ? parseFloat(splineConfig.scale)\n        : undefined;\n\n    spline.setControlPoints(canvasPoints);\n    spline.closed = !!data.contour.closed;\n\n    // Update spline resolution in case it has changed\n    if (\n      !spline.fixedResolution &&\n      resolution !== undefined &&\n      spline.resolution !== resolution\n    ) {\n      spline.resolution = resolution;\n      annotation.invalidated = true;\n    }\n\n    // Update Cardinal spline scale in case it has changed\n    if (\n      spline instanceof CardinalSpline &&\n      !spline.fixedScale &&\n      scale !== undefined &&\n      spline.scale !== scale\n    ) {\n      spline.scale = scale;\n      annotation.invalidated = true;\n    }\n\n    return spline;\n  }\n\n  private _calculateCachedStats = (\n    annotation: SplineROIAnnotation,\n    element: HTMLDivElement\n  ) => {\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n    const data = annotation.data;\n\n    if (!data.contour.closed) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { cachedStats } = data;\n    const { polyline: points } = data.contour;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const scale = getCalibratedScale(image);\n      let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        areaUnit: getCalibratedAreaUnits(null, image),\n      };\n    }\n\n    this.triggerAnnotationModified(\n      annotation,\n      enabledElement,\n      ChangeTypes.StatsUpdated\n    );\n\n    return cachedStats;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n\n    textLines.push(areaLine);\n  }\n\n  return textLines;\n}\n\nSplineROITool.toolName = 'SplineROI';\nexport default SplineROITool;\n","import { utilities } from '@cornerstonejs/core';\nimport { PublicToolProps } from '../../types';\nimport SplineROITool from './SplineROITool';\n\nclass SplineContourSegmentationTool extends SplineROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by SplineROITool\n    return true;\n  }\n}\n\nSplineContourSegmentationTool.toolName = 'SplineContourSegmentationTool';\nexport default SplineContourSegmentationTool;\n","import { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  utilities as csUtils,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport type {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { math, triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { LivewireContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport {\n  triggerAnnotationModified,\n  triggerContourAnnotationCompleted,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2; // px\n\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n  public static toolName: string;\n  protected scissors: LivewireScissors;\n  /** The scissors from the right handle, used for editing */\n  protected scissorsRight: LivewireScissors;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: LivewireContourAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n    confirmedPath?: LivewirePath;\n    currentPath?: LivewirePath;\n    /** The next path segment, on the other side of the handle */\n    confirmedPathRight?: LivewirePath;\n    closed?: boolean;\n    worldToSlice?: (point: Types.Point3) => Types.Point2;\n    sliceToWorld?: (point: Types.Point2) => Types.Point3;\n    originalPath?: Types.Point3[];\n    contourHoleProcessingEnabled?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n\n        /**\n         * Configuring this to a value larger than 0 will snap handles to nearby\n         * livewire points, within the given rectangle surrounding the clicked point.\n         * If set to 0, then the exact clicked point will be used instead, which may\n         * not be an edge and can result in jagged outlines.\n         * The unit is image pixels (index).\n         */\n        snapHandleNearby: 2,\n\n        /**\n         * Interpolation is only available for segmentation versions of these\n         * tools.  To use it on the segmentation tools, set enabled to true,\n         * and create two livewire contours in the same segment index, separated\n         * by at least one slice.\n         */\n        interpolation: {\n          enabled: false,\n\n          /**\n           * Set the nearestEdge to snap interpolated handles to an edge within\n           * the given number of pixels.  Setting to 0 disables snap to pixel\n           * for interpolation and the interpolated point will be used directly.\n           * Setting to too large a value may result in many points outside the contour\n           * being chosen.\n           */\n          nearestEdge: 2,\n          /**\n           * Set to true to show the interpolated polyline, which can be useful\n           * when understanding the nearest edge and\n           */\n          showInterpolationPolyline: false,\n        },\n\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n\n        actions: {\n          undo: {\n            method: 'undo',\n            bindings: [\n              {\n                key: 'Escape',\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  protected setupBaseEditData(\n    worldPos,\n    element,\n    annotation,\n    rightPos?,\n    contourHoleProcessingEnabled?\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.isDrawing = true;\n\n    const viewportImageData = viewport.getImageData();\n    const { imageData: vtkImageData } = viewportImageData;\n    let worldToSlice: (point: Types.Point3) => Types.Point2;\n    let sliceToWorld: (point: Types.Point2) => Types.Point3;\n    let { scalarData } = viewportImageData;\n    let width;\n    let height;\n\n    if (!(viewport instanceof VolumeViewport) && scalarData) {\n      width = viewportImageData.dimensions[0];\n      height = viewportImageData.dimensions[1];\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `worldToSlice` in this case returns the same IJK\n      // coordinate from index space.\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        return [ijkPoint[0], ijkPoint[1]];\n      };\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `sliceToWorld` in this case receives the same IJK\n      // coordinate from index space.\n      sliceToWorld = (point: Types.Point2) =>\n        csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n    } else if (viewport instanceof VolumeViewport) {\n      const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n      const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        const slicePoint = vec3.transformMat4(\n          [0, 0, 0],\n          ijkPoint,\n          indexToSliceMatrix\n        );\n\n        return [slicePoint[0], slicePoint[1]];\n      };\n\n      sliceToWorld = (point: Types.Point2) => {\n        const ijkPoint = vec3.transformMat4(\n          [0, 0, 0],\n          [point[0], point[1], 0],\n          sliceToIndexMatrix\n        ) as Types.Point3;\n\n        return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n      };\n\n      scalarData = sliceImageData.scalarData;\n      width = sliceImageData.width;\n      height = sliceImageData.height;\n    } else {\n      throw new Error('Viewport not supported');\n    }\n    scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n    const { voiRange } = viewport.getProperties();\n    const startPos = worldToSlice(worldPos);\n\n    this.scissors = LivewireScissors.createInstanceFromRawPixelData(\n      scalarData as Float32Array,\n      width,\n      height,\n      voiRange\n    );\n    if (rightPos) {\n      this.scissorsRight = LivewireScissors.createInstanceFromRawPixelData(\n        scalarData as Float32Array,\n        width,\n        height,\n        voiRange\n      );\n      this.scissorsRight.startSearch(worldToSlice(rightPos));\n    }\n\n    // Scissors always start at the startPos for both editing handles and\n    // for initial rendering\n    this.scissors.startSearch(startPos);\n\n    const newAnnotation = !rightPos;\n\n    const confirmedPath = new LivewirePath();\n    const currentPath = new LivewirePath();\n    const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n\n    confirmedPath.addPoint(startPos);\n    confirmedPath.addControlPoint(startPos);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      hasMoved: false,\n      lastCanvasPoint,\n      confirmedPath,\n      currentPath,\n      confirmedPathRight: currentPathNext,\n      closed: false,\n      handleIndex:\n        this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n      worldToSlice,\n      sliceToWorld,\n      contourHoleProcessingEnabled,\n    };\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): LivewireContourAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { world: worldPos } = currentPoints;\n    const { renderingEngine } = getEnabledElement(element);\n    const annotation = this.createAnnotation(evt);\n    const contourHoleProcessingEnabled =\n      getMouseModifierKey(evt.detail.event) ===\n      this.configuration.contourHoleAdditionModifierKey;\n\n    this.setupBaseEditData(\n      worldPos,\n      element,\n      annotation,\n      undefined,\n      contourHoleProcessingEnabled\n    );\n    this.addAnnotation(annotation, element);\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      this.editData.viewportIdsToRender\n    );\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LivewireContourAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const proximitySquared = proximity * proximity;\n    const canvasPoints = annotation.data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    let startPoint = canvasPoints[canvasPoints.length - 1];\n\n    for (let i = 0; i < canvasPoints.length; i++) {\n      const endPoint = canvasPoints[i];\n      const distanceToPointSquared = math.lineSegment.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        canvasCoords\n      );\n\n      if (distanceToPointSquared <= proximitySquared) {\n        return true;\n      }\n\n      startPoint = endPoint;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (\n    evt: EventTypes.InteractionEventType,\n    clearAnnotation = false\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      contourHoleProcessingEnabled,\n    } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      (this.isHandleOutsideImage &&\n        this.configuration.preventHandleOutsideImage) ||\n      clearAnnotation\n    ) {\n      removeAnnotation(annotation.annotationUID);\n      this.clearEditData();\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n      return;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    const changeType = newAnnotation\n      ? ChangeTypes.Completed\n      : ChangeTypes.HandlesUpdated;\n\n    this.triggerChangeEvent(\n      annotation,\n      enabledElement,\n      changeType,\n      contourHoleProcessingEnabled\n    );\n    this.clearEditData();\n  };\n\n  protected clearEditData() {\n    this.editData = null;\n    this.scissors = null;\n    this.scissorsRight = null;\n    this.isDrawing = false;\n  }\n\n  /**\n   * Triggers an annotation complete or modified event based on changeType.\n   */\n  triggerChangeEvent = (\n    annotation: LivewireContourAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated,\n    contourHoleProcessingEnabled = false\n  ): void => {\n    if (changeType === ChangeTypes.Completed) {\n      triggerContourAnnotationCompleted(\n        annotation,\n        contourHoleProcessingEnabled\n      );\n    } else {\n      triggerAnnotationModified(\n        annotation,\n        enabledElement.viewport.element,\n        changeType\n      );\n    }\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } =\n      this.editData;\n\n    if (this.editData.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n    let worldPos = worldPosOriginal;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const controlPoints = this.editData.currentPath.getControlPoints();\n    let closePath = controlPoints.length >= 2 && doubleClick;\n\n    // Check if user clicked on the first point to close the curve\n    if (controlPoints.length >= 2) {\n      const closestHandlePoint = {\n        index: -1,\n        distSquared: Infinity,\n      };\n\n      // Check if there is a control point close to the cursor\n      for (let i = 0, len = controlPoints.length; i < len; i++) {\n        const controlPoint = controlPoints[i];\n        const worldControlPoint = sliceToWorld(controlPoint);\n        const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n\n        const distSquared = math.point.distanceToPointSquared(\n          canvasPos,\n          canvasControlPoint\n        );\n\n        if (\n          distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n          distSquared < closestHandlePoint.distSquared\n        ) {\n          closestHandlePoint.distSquared = distSquared;\n          closestHandlePoint.index = i;\n        }\n      }\n\n      if (closestHandlePoint.index === 0) {\n        closePath = true;\n      }\n    }\n\n    const { snapHandleNearby } = this.configuration;\n    // Snap the handles as they get created, but not during edit\n    if (snapHandleNearby && !this.editData.closed) {\n      const currentPath = new LivewirePath();\n      const snapPoint = this.scissors.findMinNearby(\n        worldToSlice(worldPosOriginal),\n        1\n      );\n      const pathPoints = this.scissors.findPathToPoint(snapPoint);\n      currentPath.addPoints(pathPoints);\n      currentPath.prependPath(this.editData.confirmedPath);\n      worldPos = sliceToWorld(snapPoint);\n      this.editData.currentPath = currentPath;\n    }\n\n    this.editData.closed = this.editData.closed || closePath;\n    this.editData.confirmedPath = this.editData.currentPath;\n\n    // Add the current cursor position as a new control point after clicking\n    const lastPoint = this.editData.currentPath.getLastPoint();\n\n    this.editData.confirmedPath.addControlPoint(lastPoint);\n    annotation.data.handles.points.push(sliceToWorld(lastPoint));\n\n    // Start a new search starting at the last control point\n    this.scissors.startSearch(worldToSlice(worldPos));\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (this.editData.closed) {\n      // Update the annotation because `editData` will be set to null\n      this.updateAnnotation(this.editData.confirmedPath);\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { element, currentPoints } = evt.detail;\n    const { world: worldPos, canvas: canvasPos } = currentPoints;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = canvasPos;\n\n    const { width: imgWidth, height: imgHeight } = this.scissors;\n    const { worldToSlice } = this.editData;\n    const slicePoint: Types.Point2 = worldToSlice(worldPos);\n\n    // Check if the point is inside the bounding box\n    if (\n      slicePoint[0] < 0 ||\n      slicePoint[1] < 0 ||\n      slicePoint[0] >= imgWidth ||\n      slicePoint[1] >= imgHeight\n    ) {\n      return;\n    }\n\n    const pathPoints = this.scissors.findPathToPoint(slicePoint);\n    const currentPath = new LivewirePath();\n    currentPath.addPoints(pathPoints);\n\n    // Merge the \"confirmed\" path that goes from the first control point to the\n    // last one with the current path that goes from the last control point to\n    // the cursor point\n    currentPath.prependPath(this.editData.confirmedPath);\n\n    // Store the new path\n    this.editData.currentPath = currentPath;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  public editHandle(\n    worldPos: Types.Point3,\n    element,\n    annotation,\n    handleIndex: number\n  ) {\n    const { data } = annotation;\n    const { points: handlePoints } = data.handles;\n    const { length: numHandles } = handlePoints;\n    const previousHandle =\n      handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n    const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n\n    if (!this.editData?.confirmedPathRight) {\n      this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n      const { polyline } = data.contour;\n      const confirmedPath = new LivewirePath();\n      const confirmedPathRight = new LivewirePath();\n      const { worldToSlice } = this.editData;\n      const previousIndex = findHandlePolylineIndex(\n        annotation,\n        handleIndex - 1\n      );\n      const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n      if (nextIndex === -1 || previousIndex === -1) {\n        throw new Error(\n          `Can't find handle index ${nextIndex === -1 && nextHandle} ${\n            previousIndex === -1 && previousHandle\n          }`\n        );\n      }\n      if (handleIndex === 0) {\n        // For this case, the next/previous indices are swapped, and the\n        // path data gets inserted in between the newly generated data, so\n        // handle this case specially\n        confirmedPathRight.addPoints(\n          polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice)\n        );\n      } else if (nextIndex < previousIndex) {\n        throw new Error(\n          `Expected right index after left index, but were: ${previousIndex} ${nextIndex}`\n        );\n      } else {\n        confirmedPath.addPoints(\n          polyline.slice(0, previousIndex + 1).map(worldToSlice)\n        );\n        confirmedPathRight.addPoints(\n          polyline.slice(nextIndex, polyline.length).map(worldToSlice)\n        );\n      }\n      this.editData.confirmedPath = confirmedPath;\n      this.editData.confirmedPathRight = confirmedPathRight;\n    }\n    const { editData, scissors } = this;\n    const { worldToSlice, sliceToWorld } = editData;\n\n    const { activeHandleIndex } = data.handles;\n    if (activeHandleIndex === null || activeHandleIndex === undefined) {\n      data.handles.activeHandleIndex = handleIndex;\n    } else if (activeHandleIndex !== handleIndex) {\n      throw new Error(\n        `Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`\n      );\n    }\n    const slicePos = worldToSlice(worldPos);\n    if (\n      slicePos[0] < 0 ||\n      slicePos[0] >= scissors.width ||\n      slicePos[1] < 0 ||\n      slicePos[1] >= scissors.height\n    ) {\n      // Find path to point hangs if the position is outside the image data\n      return;\n    }\n    handlePoints[handleIndex] = sliceToWorld(slicePos);\n\n    const pathPointsLeft = scissors.findPathToPoint(slicePos);\n    const pathPointsRight = this.scissorsRight.findPathToPoint(slicePos);\n    const currentPath = new LivewirePath();\n\n    // Merge the \"confirmed\" path that goes from the first control point to the\n    // last one with the current path that goes from the last control point to\n    // the cursor point\n    currentPath.prependPath(editData.confirmedPath);\n    if (handleIndex !== 0) {\n      currentPath.addPoints(pathPointsLeft);\n    }\n    currentPath.addPoints(pathPointsRight.reverse());\n    currentPath.appendPath(editData.confirmedPathRight);\n    if (handleIndex === 0) {\n      currentPath.addPoints(pathPointsLeft);\n    }\n\n    // Store the new path\n    editData.currentPath = currentPath;\n\n    annotation.invalidated = true;\n    editData.hasMoved = true;\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    if (handleIndex === undefined) {\n      // Drag mode - moving object\n      console.warn('No drag implemented for livewire');\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n      this.editHandle(worldPos, element, annotation, handleIndex);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    this.scissors = null;\n    return annotation.annotationUID;\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  public renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean {\n    // Update the annotation that is in editData (being edited)\n    this.updateAnnotation(this.editData?.currentPath);\n\n    return super.renderAnnotation(enabledElement, svgDrawingHelper);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for LivewireContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType) {\n    const contourSegmentationAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n\n    const annotation = <LivewireContourAnnotation>csUtils.deepMerge(\n      contourSegmentationAnnotation,\n      {\n        data: {\n          handles: {\n            points: [[...worldPos]],\n          },\n        },\n      }\n    );\n    return annotation;\n  }\n\n  /**\n   * Clears any in progress edits, mostly used to get rid of accidentally started\n   * contours that happen on clicking not quite the right handle point.\n   * Eventually this is to be replaced with a proper undo, once that framework\n   * is available.\n   */\n  public undo(element, config, evt) {\n    if (!this.editData) {\n      // TODO - proper undo\n      return;\n    }\n    this._endCallback(evt, true);\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(renderContext: {\n    enabledElement: Types.IEnabledElement;\n    targetId: string;\n    annotation: LivewireContourAnnotation;\n    annotationStyle: Record<string, any>;\n    svgDrawingHelper: SVGDrawingHelper;\n  }): boolean {\n    const { annotation, enabledElement, svgDrawingHelper, annotationStyle } =\n      renderContext;\n\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotationUID, data, highlighted } = annotation;\n    const { handles } = data;\n    const newAnnotation = this.editData?.newAnnotation;\n    const { lineWidth, lineDash, color } = annotationStyle;\n\n    // Render the first control point only when the annotation is drawn for the\n    // first time to make it easier to know where the user needs to click to\n    // to close the ROI.\n    if (\n      highlighted ||\n      (newAnnotation &&\n        annotation.annotationUID === this.editData?.annotation?.annotationUID)\n    ) {\n      const handleGroupUID = '0';\n      const canvasHandles = handles.points.map(worldToCanvas);\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasHandles,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    return true;\n  }\n\n  protected updateAnnotation(livewirePath: LivewirePath) {\n    if (!this.editData || !livewirePath) {\n      return;\n    }\n\n    const { annotation, sliceToWorld } = this.editData;\n    let { pointArray: imagePoints } = livewirePath;\n\n    if (imagePoints.length > 1) {\n      imagePoints = [...imagePoints, imagePoints[0]];\n    }\n\n    this.updateContourPolyline(\n      annotation,\n      {\n        points: imagePoints,\n        closed: annotation.data.contour.closed,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n      },\n      {\n        canvasToWorld: sliceToWorld,\n      }\n    );\n  }\n}\n\nLivewireContourTool.toolName = 'LivewireContour';\nexport default LivewireContourTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport type { ContourSegmentationAnnotation } from '../../types';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\n\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n  static toolName;\n\n  /**\n   * Updates the interpolated annotations with the currently displayed image data,\n   * performing hte livewire on the image data as generated.\n   * Note - this function is only called for interpolated livewire SEGMENTATION\n   * objects, and will return immediately otherwise.\n   *\n   * The work for the interpolation is performed in a microtask, enabling this\n   * method to return quickly for faster render speeds, but ensuring that the\n   * annotation data isn't updated before the changes are performed.  The removes\n   * some irritating flickering on navigation.\n   */\n  public updateInterpolatedAnnotation(\n    annotation: ContourSegmentationAnnotation,\n    enabledElement: Types.IEnabledElement\n  ) {\n    // The interpolation sources is used as a flag here - a true livewire\n    // behaviour would be to perform a livewire between the two planes\n    // closest to this plane for each point, and use that handle.  That is\n    // oblique, however, which is not currently supported.\n    if (\n      this.editData ||\n      !annotation.invalidated ||\n      !annotation.data.handles.interpolationSources\n    ) {\n      return;\n    }\n    annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n\n    // See docs above for why this is a microtask\n    queueMicrotask(() => {\n      if (!annotation.data.handles.interpolationSources) {\n        return;\n      }\n      const { points } = annotation.data.handles;\n\n      const { element } = enabledElement.viewport;\n      this.setupBaseEditData(points[0], element, annotation);\n      const { length: count } = points;\n      const { scissors } = this;\n      const { nearestEdge, repeatInterpolation } =\n        this.configuration.interpolation;\n      annotation.data.handles.originalPoints = points;\n      const { worldToSlice, sliceToWorld } = this.editData;\n      const handleSmoothing = [];\n\n      // New path generation - go through the handles and regenerate the polyline\n      if (nearestEdge) {\n        let lastPoint = worldToSlice(points[points.length - 1]);\n        // Nearest edge handling\n        points.forEach((point, hIndex) => {\n          const testPoint = worldToSlice(point);\n          lastPoint = testPoint;\n          handleSmoothing.push(testPoint);\n\n          // Fill the costs buffer and then find the minimum cost\n          // This is a little too aggressive about pulling the line in\n          scissors.startSearch(lastPoint);\n          scissors.findPathToPoint(testPoint);\n          // Fill the costs for a point a bit further along by searching for a\n          // point further along.\n          scissors.findPathToPoint(\n            worldToSlice(points[(hIndex + 3) % points.length])\n          );\n          const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n          if (!csUtils.isEqual(testPoint, minPoint)) {\n            handleSmoothing[hIndex] = minPoint;\n            lastPoint = minPoint;\n            points[hIndex] = sliceToWorld(minPoint);\n          }\n        });\n      }\n\n      // Regenerate the updated data based on the updated handles\n      const acceptedPath = new LivewirePath();\n      for (let i = 0; i < count; i++) {\n        scissors.startSearch(worldToSlice(points[i]));\n        const path = scissors.findPathToPoint(\n          worldToSlice(points[(i + 1) % count])\n        );\n        acceptedPath.addPoints(path);\n      }\n\n      // Now, update the rendering\n      this.updateAnnotation(acceptedPath);\n      this.scissors = null;\n      this.scissorsRight = null;\n      this.editData = null;\n      annotation.data.handles.interpolationSources = null;\n\n      if (repeatInterpolation) {\n        triggerAnnotationModified(\n          annotation,\n          enabledElement.viewport.element,\n          ChangeTypes.InterpolationUpdated\n        );\n      }\n    });\n  }\n\n  /**\n   * Adds the update to the interpolated annotaiton on render an instance,\n   * but otherwise just calls the parent render annotation instance.\n   */\n  protected renderAnnotationInstance(renderContext): boolean {\n    const { enabledElement, svgDrawingHelper } = renderContext;\n    const annotation =\n      renderContext.annotation as ContourSegmentationAnnotation;\n    const { annotationUID } = annotation;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { showInterpolationPolyline } =\n      this.configuration.interpolation || {};\n\n    this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n    const { originalPolyline } = annotation.data.contour;\n\n    const rendered = super.renderAnnotationInstance(renderContext);\n\n    if (\n      showInterpolationPolyline &&\n      originalPolyline &&\n      annotation.autoGenerated\n    ) {\n      const polylineCanvasPoints = originalPolyline.map(\n        worldToCanvas\n      ) as Types.Point2[];\n      polylineCanvasPoints.push(polylineCanvasPoints[0]);\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'interpolationContour-0',\n        polylineCanvasPoints,\n        {\n          color: '#70ffff',\n          lineWidth: 1,\n          fillOpacity: 0,\n        }\n      );\n    }\n\n    return rendered;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by LivewireContourTool\n    return true;\n  }\n}\n\nLivewireContourSegmentationTool.toolName = 'LivewireContourSegmentationTool';\nexport default LivewireContourSegmentationTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawArrow as drawArrowSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ArrowAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass ArrowAnnotateTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        getTextCallback,\n        changeTextCallback,\n        preventHandleOutsideImage: false,\n        arrowFirst: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ArrowAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const { arrowFirst } = this.configuration;\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          arrowFirst,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: ArrowAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    if (newAnnotation) {\n      this.configuration.getTextCallback((text) => {\n        if (!text) {\n          removeAnnotation(annotation.annotationUID);\n          triggerAnnotationRenderForViewportIds(\n            renderingEngine,\n            viewportIdsToRender\n          );\n          this.editData = null;\n          this.isDrawing = false;\n          return;\n        }\n        annotation.data.text = text;\n\n        triggerAnnotationCompleted(annotation);\n\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n      });\n    } else {\n      triggerAnnotationModified(annotation, element);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\n    if (evt.detail.taps == 2) {\n      this.doubleClickCallback(evt);\n    }\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as ArrowAnnotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as ArrowAnnotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n  }\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ArrowAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles, text } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      const arrowUID = '1';\n      if (this.configuration.arrowFirst) {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[1],\n          canvasCoordinates[0],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      } else {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!text) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the point that doesn't have the arrowhead by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        [text],\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { roundNumber } from '../../utilities';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass AngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n    if (!point3) {\n      return false;\n    }\n\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n\n    const line2 = {\n      start: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n      end: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n    };\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 2;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\n      if (canvasCoordinates.length !== 3) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[1],\n        canvasCoordinates[2],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    // Until we have all three anchors bail out\n    if (data.handles.points.length !== 3) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos2, worldPos3]\n      );\n      const { dimensions, imageData } = this.getTargetIdImage(\n        targetId,\n        renderingEngine\n      );\n\n      // Decide if there's at least one handle is outside of image\n      this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n        .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n        .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n      cachedStats[targetId] = {\n        angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  if (isNaN(angle)) {\n    // The verbiage for incomplete angle is set in cachedStats\n    return [`${angle}`];\n  }\n\n  const textLines = [`${roundNumber(angle)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CobbAngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass CobbAngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    isNearFirstLine?: boolean;\n    isNearSecondLine?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        showArcLines: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      25,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): CobbAngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CobbAngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n      viewport,\n      points: data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    interactionType: InteractionTypes,\n    canvasCoords: Types.Point2,\n    proximity = 6\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n      viewport,\n      points: annotation.data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    handle: ToolHandle,\n    interactionType = 'mouse'\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _mouseUpCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n      resetElementCursor(element);\n\n      // adds the first point of the second line\n      this.editData.handleIndex = data.handles.points.length;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * Handles the mouse down for all points that follow the very first mouse down.\n   * The very first mouse down is handled by addAnnotation.\n   * This method ensures that the state of the tool is correct for the drawing of the second line segment.\n   * In particular it ensures that the second segment can be created via a mouse down and drag.\n   */\n  _mouseDownCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const { annotation, handleIndex } = this.editData;\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const worldPos = currentPoints.world;\n    const { data } = annotation;\n\n    if (handleIndex === 1) {\n      // This is the mouse down for the second point of the first segment.\n      // The mouse up takes care of adding the first point of the second segment.\n      data.handles.points[1] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[1][0] !== data.handles.points[0][0] ||\n        data.handles.points[1][1] !== data.handles.points[0][0];\n      return;\n    }\n\n    if (handleIndex === 3) {\n      // This is the mouse down for the second point of the second segment (i.e. the last point)\n      data.handles.points[3] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[3][0] !== data.handles.points[2][0] ||\n        data.handles.points[3][1] !== data.handles.points[2][0];\n\n      this.angleStartedNotYetCompleted = false;\n      return;\n    }\n\n    // This is the first mouse down of the first point of the second line segment.\n    // It is as if we have not moved yet because Cobb Angle has two, disjoint sections, each with its own move.\n    this.editData.hasMoved = false;\n    hideElementCursor(element);\n\n    // Add the last segment points for the subsequent drag/mouse move.\n    data.handles.points[2] = data.handles.points[3] = worldPos;\n    this.editData.handleIndex = data.handles.points.length - 1;\n  };\n\n  _mouseDragCallback = (\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\n  ) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n      isNearFirstLine,\n      isNearSecondLine,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (\n      handleIndex === undefined &&\n      (isNearFirstLine || isNearSecondLine)\n    ) {\n      // select tool mode - moving annotation\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      // separate the logic for moving handles to move them separately\n      if (isNearFirstLine) {\n        const firstLinePoints = [points[0], points[1]];\n        firstLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      } else if (isNearSecondLine) {\n        const secondLinePoints = [points[2], points[3]];\n        secondLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      }\n\n      annotation.invalidated = true;\n    } else {\n      // Drag handle mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length < 4) {\n      // If it is mid-draw\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.angleStartedNotYetCompleted = false;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CobbAngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n          arc1Angle: null,\n          arc2Angle: null,\n          points: {\n            world: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n            canvas: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n          },\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const firstLine = [canvasCoordinates[0], canvasCoordinates[1]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n      const secondLine = [canvasCoordinates[2], canvasCoordinates[3]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n\n      let lineUID = 'line1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        firstLine[0],\n        firstLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add the stats until annotation has 4 anchor points\n      if (canvasCoordinates.length < 4) {\n        return renderStatus;\n      }\n\n      lineUID = 'line2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        secondLine[0],\n        secondLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      lineUID = 'linkLine';\n      const mid1 = midPoint2(firstLine[0], firstLine[1]);\n      const mid2 = midPoint2(secondLine[0], secondLine[1]);\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n        color,\n        lineWidth: '1',\n        lineDash: '1,4',\n      });\n\n      // Calculating the arcs\n\n      const { arc1Start, arc1End, arc2End, arc2Start } =\n        data.cachedStats[targetId].points.canvas;\n      const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n\n      if (this.configuration.showArcLines) {\n        lineUID = 'arc1';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          arc1Start as Types.Point2,\n          arc1End as Types.Point2,\n          {\n            color,\n            lineWidth: '1',\n          }\n        );\n\n        lineUID = 'arc2';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          arc2Start as Types.Point2,\n          arc2End as Types.Point2,\n          {\n            color,\n            lineWidth: '1',\n          }\n        );\n      }\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = 'cobbAngleText';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n\n      if (this.configuration.showArcLines) {\n        const arc1TextBoxUID = 'arcAngle1';\n\n        const arc1TextLine = [\n          `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n        ];\n\n        const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arc1TextBoxUID,\n          arc1TextLine,\n          arch1TextPosCanvas,\n          {\n            ...options,\n            padding: 3,\n          }\n        );\n\n        const arc2TextBoxUID = 'arcAngle2';\n\n        const arc2TextLine = [\n          `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n        ];\n\n        const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arc2TextBoxUID,\n          arc2TextLine,\n          arch2TextPosCanvas,\n          {\n            ...options,\n            padding: 3,\n          }\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n\n    // Until we have all four anchors bail out\n    if (data.handles.points.length !== 4) {\n      return;\n    }\n\n    const seg1: [Types.Point3, Types.Point3] = [null, null];\n    const seg2: [Types.Point3, Types.Point3] = [null, null];\n    let minDist = Number.MAX_VALUE;\n\n    // Order the endpoints of each line segment such that seg1[1] and seg2[0]\n    // are the closest (Euclidean distance-wise) to each other. Thus\n    // the angle formed between the vectors seg1[1]->seg1[0] and seg2[0]->seg[1]\n    // is calculated.\n    // The assumption here is that the Cobb angle line segments are drawn\n    // such that the segments intersect nearest the segment endpoints\n    // that are closest AND those closest endpoints are the tails of the\n    // vectors used to calculate the angle between the vectors/line segments.\n    for (let i = 0; i < 2; i += 1) {\n      for (let j = 2; j < 4; j += 1) {\n        const dist = vec3.distance(\n          data.handles.points[i],\n          data.handles.points[j]\n        );\n        if (dist < minDist) {\n          minDist = dist;\n          seg1[1] = data.handles.points[i];\n          seg1[0] = data.handles.points[(i + 1) % 2];\n          seg2[0] = data.handles.points[j];\n          seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n        }\n      }\n    }\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const canvasPoints = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    const firstLine = [canvasPoints[0], canvasPoints[1]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n    const secondLine = [canvasPoints[2], canvasPoints[3]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const mid1 = midPoint2(firstLine[0], firstLine[1]);\n    const mid2 = midPoint2(secondLine[0], secondLine[1]);\n\n    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } =\n      this.getArcsStartEndPoints({\n        firstLine,\n        secondLine,\n        mid1,\n        mid2,\n      });\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      cachedStats[targetId] = {\n        angle: angleBetweenLines(seg1, seg2),\n        arc1Angle,\n        arc2Angle,\n        points: {\n          canvas: {\n            arc1Start,\n            arc1End,\n            arc2End,\n            arc2Start,\n          },\n          world: {\n            arc1Start: viewport.canvasToWorld(arc1Start),\n            arc1End: viewport.canvasToWorld(arc1End),\n            arc2End: viewport.canvasToWorld(arc2End),\n            arc2Start: viewport.canvasToWorld(arc2Start),\n          },\n        },\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n\n  distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n    const [point1, point2, point3, point4] = points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n    const canvasPoint4 = viewport.worldToCanvas(point4);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n      end: {\n        x: canvasPoint4[0],\n        y: canvasPoint4[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    let isNearFirstLine = false;\n    let isNearSecondLine = false;\n\n    if (distanceToPoint <= proximity) {\n      isNearFirstLine = true;\n    } else if (distanceToPoint2 <= proximity) {\n      isNearSecondLine = true;\n    }\n    return {\n      distanceToPoint,\n      distanceToPoint2,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n  };\n\n  getArcsStartEndPoints = ({\n    firstLine,\n    secondLine,\n    mid1,\n    mid2,\n  }): {\n    arc1Start: Types.Point2;\n    arc1End: Types.Point2;\n    arc2Start: Types.Point2;\n    arc2End: Types.Point2;\n    arc1Angle: number;\n    arc2Angle: number;\n  } => {\n    const linkLine = [mid1, mid2] as [Types.Point2, Types.Point2];\n\n    const arc1Angle = angleBetweenLines(firstLine, linkLine);\n    const arc2Angle = angleBetweenLines(secondLine, linkLine);\n\n    const arc1Side = arc1Angle > 90 ? 1 : 0;\n    const arc2Side = arc2Angle > 90 ? 0 : 1;\n\n    const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n\n    const linkLineLength = Math.sqrt(\n      (linkLine[1][0] - linkLine[0][0]) ** 2 +\n        (linkLine[1][1] - linkLine[0][1]) ** 2\n    );\n    const ratio = 0.1; // 10% of the line length\n\n    const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n    const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n\n    // For arc1Start\n    const directionVectorStartArc1 = [\n      firstLine[arc1Side][0] - midFirstLine[0],\n      firstLine[arc1Side][1] - midFirstLine[1],\n    ];\n    const magnitudeStartArc1 = Math.sqrt(\n      directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2\n    );\n    const normalizedDirectionStartArc1 = [\n      directionVectorStartArc1[0] / magnitudeStartArc1,\n      directionVectorStartArc1[1] / magnitudeStartArc1,\n    ];\n    const arc1Start = [\n      midFirstLine[0] +\n        normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n      midFirstLine[1] +\n        normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Existing logic for arc1End\n    const directionVectorEndArc1 = [\n      midLinkLine[0] - mid1[0],\n      midLinkLine[1] - mid1[1],\n    ];\n    const magnitudeEndArc1 = Math.sqrt(\n      directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2\n    );\n    const normalizedDirectionEndArc1 = [\n      directionVectorEndArc1[0] / magnitudeEndArc1,\n      directionVectorEndArc1[1] / magnitudeEndArc1,\n    ];\n    const arc1End = [\n      mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n      mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2Start\n    const directionVectorStartArc2 = [\n      secondLine[arc2Side][0] - midSecondLine[0],\n      secondLine[arc2Side][1] - midSecondLine[1],\n    ];\n    const magnitudeStartArc2 = Math.sqrt(\n      directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2\n    );\n    const normalizedDirectionStartArc2 = [\n      directionVectorStartArc2[0] / magnitudeStartArc2,\n      directionVectorStartArc2[1] / magnitudeStartArc2,\n    ];\n    const arc2Start = [\n      midSecondLine[0] +\n        normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n      midSecondLine[1] +\n        normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2End\n    const directionVectorEndArc2 = [\n      midLinkLine[0] - mid2[0],\n      midLinkLine[1] - mid2[1],\n    ];\n    const magnitudeEndArc2 = Math.sqrt(\n      directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2\n    );\n    const normalizedDirectionEndArc2 = [\n      directionVectorEndArc2[0] / magnitudeEndArc2,\n      directionVectorEndArc2[1] / magnitudeEndArc2,\n    ];\n    const arc2End = [\n      mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n      mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    return {\n      arc1Start,\n      arc1End,\n      arc2Start,\n      arc2End,\n      arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n      arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  utilities as csUtils,\n  StackViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { UltrasoundDirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  drawHandle as drawHandleSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  InteractionTypes,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * The `UltrasoundDirectionalTool` class is a tool for creating directional ultrasound annotations.\n * It allows users to draw lines and measure distances between two points in the image.\n * It automatically calculates the distance based on the relevant unit of measurement.\n */\nclass UltrasoundDirectionalTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  startedDrawing: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        /**\n         * Determines whether both horizontal and vertical distances should be displayed\n         * in the text lines when generating annotations' measurement information.\n         */\n        displayBothAxesDistances: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Ultrasound Directional Tool and store it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): UltrasoundDirectionalAnnotation => {\n    if (this.startedDrawing) {\n      return;\n    }\n\n    this.startedDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error(\n        'UltrasoundDirectionalTool can only be used on a StackViewport'\n      );\n    }\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: UltrasoundDirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    return false;\n  };\n\n  toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void {\n    return;\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: UltrasoundDirectionalAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    let movingTextBox = false;\n    let handleIndex;\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      handleIndex,\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.startedDrawing && data.handles.points.length === 1) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 1;\n      return;\n    }\n\n    this.startedDrawing = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      this.startedDrawing = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as UltrasoundDirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].xValues == null\n      ) {\n        data.cachedStats[targetId] = {\n          xValues: [0, 0],\n          yValues: [0, 0],\n          isHorizontal: false,\n          units: [''],\n          isUnitless: false,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // draw first point\n      let handleGroupUID = '0';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[0],\n        {\n          color,\n        },\n        0\n      );\n\n      renderStatus = true;\n\n      if (canvasCoordinates.length !== 2) {\n        return renderStatus;\n      }\n\n      handleGroupUID = '1';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[1],\n        {\n          color,\n        },\n        1\n      );\n\n      const isUnitless = data.cachedStats[targetId].isUnitless;\n\n      if (!isUnitless) {\n        const canvasPoint1 = canvasCoordinates[0];\n        const canvasPoint2 = canvasCoordinates[1];\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        const isHorizontal = data.cachedStats[targetId].isHorizontal;\n\n        // then for the third point we need to go from first point towards\n        // the second point (it can be left or right in the horizontal orientation)\n        // or up or down in the vertical orientation, and only add\n        // the delta y to the x or y coordinate of the first point\n        let projectedPointCanvas = [0, 0] as Types.Point2;\n        if (isHorizontal) {\n          projectedPointCanvas = [\n            canvasPoint1[0] + canvasDeltaX,\n            canvasPoint1[1],\n          ];\n        } else {\n          projectedPointCanvas = [\n            canvasPoint1[0],\n            canvasPoint1[1] + canvasDeltaY,\n          ];\n        }\n\n        // create a line from the first point to the third point\n        let dataId = `${annotationUID}-line-1`;\n        let lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n\n        // draw another line from first point to the projected one\n        dataId = `${annotationUID}-line-2`;\n        lineUID = '2';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[1],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            lineDash: [1, 1],\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      } else {\n        // draw straight line between the two points\n        const dataId = `${annotationUID}-line-1`;\n        const lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      }\n\n      // draw another line from first point to the\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(\n        data,\n        targetId,\n        this.configuration\n      );\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    // Until we have all two anchors bail out\n    if (data.handles.points.length !== 2) {\n      return;\n    }\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData } = image;\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[1];\n\n      const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n      const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n\n      const { values: values1, units: units1 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n      const { values: values2, units: units2 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n\n      let xValues, yValues, units, isHorizontal;\n      let isUnitless = false;\n      if (\n        units1[0] !== units2[0] ||\n        units1[1] !== units2[1] ||\n        (units1[0] === 'raw' && units2[0] === 'raw')\n      ) {\n        // if units are not the same, we cannot calculate the diff\n        // so we just report the px distance\n        const value = distanceToPoint(worldPos1, worldPos2);\n\n        xValues = [value, 0];\n        yValues = [value, 0];\n        units = ['px'];\n        isUnitless = true;\n      } else {\n        const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n        const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n        xValues = [values1[0], values2[0]];\n        yValues = [values1[1], values2[1]];\n\n        units = [units1[0], units1[1]];\n      }\n\n      cachedStats[targetId] = {\n        xValues,\n        yValues,\n        isHorizontal,\n        units,\n        isUnitless,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId, configuration): string[] {\n  const cachedStats = data.cachedStats[targetId];\n  const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n\n  if (isUnitless) {\n    return [`${roundNumber(xValues[0])} px`];\n  }\n\n  if (configuration.displayBothAxesDistances) {\n    const dist1 = Math.abs(xValues[1] - xValues[0]);\n    const dist2 = Math.abs(yValues[1] - yValues[0]);\n    return [\n      `${roundNumber(dist1)} ${units[0]}`,\n      `${roundNumber(dist2)} ${units[1]}`,\n    ];\n  }\n\n  if (isHorizontal) {\n    const dist = Math.abs(xValues[1] - xValues[0]);\n    return [`${roundNumber(dist)} ${units[0]}`];\n  } else {\n    const dist = Math.abs(yValues[1] - yValues[0]);\n    return [`${roundNumber(dist)} ${units[1]}`];\n  }\n}\n\nUltrasoundDirectionalTool.toolName = 'UltrasoundDirectionalTool';\nexport default UltrasoundDirectionalTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\n\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { resetElementCursor } from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { Annotation } from '../../types';\n\ntype Point2 = Types.Point2;\n\nclass KeyImageTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        getTextCallback,\n        changeTextCallback,\n        canvasPosition: [10, 10],\n        canvasSize: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = KeyImageTool.createAnnotation({\n      metadata: { ...viewport.getViewReference(), referencedImageId },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.configuration.getTextCallback((text) => {\n      if (!text) {\n        removeAnnotation(annotation.annotationUID);\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n        this.isDrawing = false;\n        return;\n      }\n      annotation.data.text = text;\n\n      triggerAnnotationCompleted(annotation);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n    });\n\n    return annotation;\n  };\n\n  public cancel() {\n    // No op - the annotation can't be in a partial state\n  }\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { canvasPosition, canvasSize } = this.configuration;\n    if (!canvasPosition?.length) {\n      return false;\n    }\n    if (\n      Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n        canvasSize / 2 &&\n      Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n        canvasSize / 2\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    annotation.highlighted = true;\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle\n  ): void {\n    // Nothing special to do here.\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this._deactivateModify(element);\n    resetElementCursor(element);\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as Annotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as Annotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n  }\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { canvasPosition, canvasSize } = this.configuration;\n      if (canvasPosition?.length) {\n        const arrowUID = '1';\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasPosition.map((it) => it + canvasSize) as Point2,\n          canvasPosition as Point2,\n          {\n            color,\n            width: 1,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nKeyImageTool.toolName = 'KeyImage';\n\nexport default KeyImageTool;\n","import { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { ToolGroupManager } from '../store';\nimport {\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\n\nclass AnnotationEraserTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    return this._deleteNearbyAnnotations(evt, 'mouse');\n  };\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    return this._deleteNearbyAnnotations(evt, 'touch');\n  };\n\n  _deleteNearbyAnnotations(\n    evt: EventTypes.InteractionEventType,\n    interactionType: string\n  ): boolean {\n    const { renderingEngineId, viewportId, element, currentPoints } =\n      evt.detail;\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    if (!toolGroup) {\n      return false;\n    }\n\n    const tools = toolGroup._toolInstances;\n    const annotationsToRemove = [];\n\n    for (const toolName in tools) {\n      const toolInstance = tools[toolName];\n\n      if (\n        typeof toolInstance.isPointNearTool !== 'function' ||\n        typeof toolInstance.filterInteractableAnnotationsForElement !==\n          'function'\n      ) {\n        continue;\n      }\n\n      const annotations = getAnnotations(toolName, element);\n\n      if (!annotations) {\n        continue;\n      }\n\n      const interactableAnnotations =\n        toolInstance.filterInteractableAnnotationsForElement(\n          element,\n          annotations\n        );\n\n      for (const annotation of interactableAnnotations) {\n        if (\n          toolInstance.isPointNearTool(\n            element,\n            annotation,\n            currentPoints.canvas,\n            10,\n            interactionType\n          )\n        ) {\n          annotationsToRemove.push(annotation.annotationUID);\n        }\n      }\n    }\n\n    for (const annotationUID of annotationsToRemove) {\n      setAnnotationSelected(annotationUID);\n      removeAnnotation(annotationUID);\n    }\n\n    evt.preventDefault();\n\n    return true;\n  }\n}\n\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\n\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass RectangleScissorsTool extends BaseTool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    //\n    imageIdReferenceMap: Map<string, string>;\n    volumeId: string;\n    referencedVolumeId: string;\n    //\n    annotation: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideRectangle,\n          ERASE_INSIDE: eraseInsideRectangle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData = representationData[\n      SegmentationRepresentations.Labelmap\n    ] as LabelmapSegmentationData;\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    this.editData = {\n      annotation,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle.\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n\n    // Move this handle.\n    points[handleIndex] = [...worldPos];\n\n    let bottomLeftCanvas;\n    let bottomRightCanvas;\n    let topLeftCanvas;\n    let topRightCanvas;\n\n    let bottomLeftWorld;\n    let bottomRightWorld;\n    let topLeftWorld;\n    let topRightWorld;\n\n    switch (handleIndex) {\n      case 0:\n      case 3:\n        // Moving bottomLeft or topRight\n\n        bottomLeftCanvas = worldToCanvas(points[0]);\n        topRightCanvas = worldToCanvas(points[3]);\n\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n        topLeftWorld = canvasToWorld(topLeftCanvas);\n\n        points[1] = bottomRightWorld;\n        points[2] = topLeftWorld;\n\n        break;\n      case 1:\n      case 2:\n        // Moving bottomRight or topLeft\n        bottomRightCanvas = worldToCanvas(points[1]);\n        topLeftCanvas = worldToCanvas(points[2]);\n\n        bottomLeftCanvas = <Types.Point2>[\n          topLeftCanvas[0],\n          bottomRightCanvas[1],\n        ];\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\n\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n        topRightWorld = canvasToWorld(topRightCanvas);\n\n        points[0] = bottomLeftWorld;\n        points[3] = topRightWorld;\n\n        break;\n    }\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const rectangleUID = '0';\n    drawRectSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rectangleUID,\n      canvasCoordinates[0],\n      canvasCoordinates[3],\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n  config as segmentationConfig,\n} from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass CircleScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n    segmentationRepresentationUID?: string;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideCircle,\n          ERASE_INSIDE: eraseInsideCircle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const labelmapData = representationData[type];\n\n    if (!labelmapData) {\n      throw new Error(\n        'No labelmap data found for the active segmentation, create one before using scissors tool'\n      );\n    }\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        isDrawing: true,\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    // Center of circle in canvas Coordinates\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      viewPlaneNormal,\n      viewUp,\n      strategySpecificConfiguration: {},\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n/**\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\n * lead to ui blocking behavior that needs to be fixed.\n */\nclass SphereScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentationRepresentationUID: string;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    toolGroupId: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideSphere,\n          ERASE_INSIDE: eraseInsideSphere,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    this.isDrawing = true;\n\n    // Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        highlighted: true,\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentationRepresentationUID,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      toolGroupId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    } as any;\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the sphereScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = csUtils.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      triggerAnnotationModified(annotation, element);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { pointInShapeCallback } from '../../utilities/';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n        computePointsInsideVolume: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  //This function return all the points inside the ROI for every slices between startSlice and endSlice\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\n    const { data } = annotation;\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const projectionPoint = projectionPoints[i][0];\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[3];\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\n      const worldProjectionPointIndex = transformWorldToIndex(\n        imageData,\n        projectionPoint\n      );\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldProjectionPointIndex[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          null,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, viewport.element);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import {\n  StackViewport,\n  Types,\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n  metaData,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport {\n  addAnnotation,\n  removeAnnotation,\n  getAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { pointInShapeCallback } from '../../utilities';\n\nconst { transformWorldToIndex } = csUtils;\n\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        numSlicesToPropagate: 10,\n        calculatePointsInsideVolume: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    // if (!referencedImageId) {\n    //   throw new Error('This tool does not work on non-acquisition planes');\n    // }\n\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    const newStartIndex = this._getStartSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    // We cannot newStartIndex add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        volumeId,\n        spacingInNormal,\n        enabledElement,\n      },\n      data: {\n        label: '',\n        startSlice: newStartIndex,\n        endSlice: endIndex,\n\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n        },\n        labelmapUID: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(annotation, imageVolume, enabledElement);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const { centerPointRadius } = this.configuration;\n\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      const middleSlice = Math.round((startSlice + endSlice) / 2);\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n\n      let isMiddleSlice = false;\n      if (sliceIndex === middleSlice) {\n        isMiddleSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        isMiddleSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineWidthToUse = lineWidth;\n\n      if (isMiddleSlice) {\n        lineWidthToUse = 3;\n      }\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth: lineWidthToUse,\n        }\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: CircleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n    startIJK[2] = startSlice;\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          //@ts-ignore\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n  }\n\n  _computePointsInsideVolume(annotation, imageVolume, enabledElement) {\n    const { data } = annotation;\n    const { viewport } = enabledElement;\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const centerWorld = projectionPoints[i][0];\n      const canvasCoordinates = projectionPoints[i].map((p) =>\n        viewport.worldToCanvas(p)\n      );\n\n      const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n        getCanvasCircleCorners(canvasCoordinates)\n      );\n\n      const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n      const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n      const worldPos1 = topLeftWorld;\n      const worldPos2 = bottomRightWorld;\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      const worldCenterIndex = transformWorldToIndex(imageData, centerWorld);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldCenterIndex[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldCenterIndex[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = centerWorld as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          //@ts-ignore\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n          null,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  _getStartSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const startPos = vec3.create();\n    vec3.scaleAndAdd(\n      startPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagateFromStart * -spacingInNormal\n    );\n\n    const imageIdIndex = this._getImageIdIndex(\n      imageVolume,\n      startPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    return imageIdIndex;\n  }\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagateFromStart * spacingInNormal\n    );\n\n    const imageIdIndex = this._getImageIdIndex(\n      imageVolume,\n      endPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    return imageIdIndex;\n  }\n\n  _getImageIdIndex(\n    imageVolume: Types.IImageVolume,\n    pos: vec3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, pos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n} from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { FloodFillResult, FloodFillGetter } from '../../types';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\ntype PaintFillToolHelpers = {\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\n  getLabelValue: (x: number, y: number, z: number) => number;\n  floodFillGetter: FloodFillGetter;\n  inPlaneSeedPoint: Types.Point2;\n  fixedDimensionValue: number;\n};\n\n/**\n * Tool for manipulating segmentation data by filling in regions. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will fill a given labelled\n * or empty region with the the activeSegmentIndex label. You can use the\n * SegmentationModule to set the active segmentation and segmentIndex.\n */\nclass PaintFillTool extends BaseTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked: number[] =\n      segmentLocking.getLockedSegments(segmentationId);\n    const { representationData } = getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    let dimensions: Types.Point3;\n    let direction: Types.Mat3;\n    let scalarData: Types.PixelDataTypedArray;\n    let index: Types.Point3;\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n\n      const segmentation = cache.getVolume(volumeId);\n      ({ dimensions, direction } = segmentation);\n      scalarData = segmentation.getScalarData();\n\n      index = transformWorldToIndex(segmentation.imageData, worldPos);\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = enabledElement.viewport.getCurrentImageId();\n      const currentSegmentationImageId =\n        imageIdReferenceMap.get(currentImageId);\n\n      if (!currentSegmentationImageId) {\n        throw new Error(\n          'No active segmentation imageId detected, create one before using scissors tool'\n        );\n      }\n\n      const segmentationImage = cache.getImage(currentSegmentationImageId);\n      scalarData = segmentationImage.getPixelData();\n      const { imageData } = viewport.getImageData();\n      dimensions = imageData.getDimensions();\n      direction = imageData.getDirection();\n      index = transformWorldToIndex(imageData, worldPos);\n    }\n\n    const fixedDimension = this.getFixedDimension(\n      viewPlaneNormal,\n      direction as number[]\n    );\n\n    if (fixedDimension === undefined) {\n      console.warn('Oblique paint fill not yet supported');\n      return;\n    }\n\n    const {\n      floodFillGetter,\n      getLabelValue,\n      getScalarDataPositionFromPlane,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n\n    // Check if within volume\n    if (\n      index[0] < 0 ||\n      index[0] >= dimensions[0] ||\n      index[1] < 0 ||\n      index[1] >= dimensions[1] ||\n      index[2] < 0 ||\n      index[2] >= dimensions[2]\n    ) {\n      // Clicked outside segmentation volume, no good way to fill.\n      return;\n    }\n    //@ts-ignore // todo type\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n\n    if (segmentsLocked.includes(clickedLabelValue)) {\n      // Label is locked, cannot fill.\n      return;\n    }\n\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n\n    const { flooded } = floodFillResult;\n\n    flooded.forEach((index) => {\n      const scalarDataPosition = getScalarDataPositionFromPlane(\n        index[0],\n        index[1]\n      );\n\n      scalarData[scalarDataPosition] = segmentIndex;\n    });\n\n    const framesModified = this.getFramesModified(\n      fixedDimension,\n      fixedDimensionValue,\n      floodFillResult\n    );\n\n    triggerSegmentationDataModified(segmentationId, framesModified);\n\n    return true;\n  };\n\n  private getFramesModified = (\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    floodFillResult: FloodFillResult\n  ): number[] => {\n    const { boundaries } = floodFillResult;\n\n    if (fixedDimension === 2) {\n      return [fixedDimensionValue];\n    }\n\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\n    // so we don't need to find min/max i.\n\n    let minJ = Infinity;\n    let maxJ = -Infinity;\n\n    for (let b = 0; b < boundaries.length; b++) {\n      const j = boundaries[b][1];\n\n      if (j < minJ) {\n        minJ = j;\n      }\n      if (j > maxJ) {\n        maxJ = j;\n      }\n    }\n\n    const framesModified = [];\n\n    for (let frame = minJ; frame <= maxJ; frame++) {\n      framesModified.push(frame);\n    }\n\n    return framesModified;\n  };\n\n  private generateHelpers = (\n    scalarData: Types.PixelDataTypedArray,\n    dimensions: Types.Point3,\n    seedIndex3D: Types.Point3,\n    fixedDimension = 2\n  ): PaintFillToolHelpers => {\n    let fixedDimensionValue: number;\n    let inPlaneSeedPoint: Types.Point2;\n\n    switch (fixedDimension) {\n      case 0:\n        fixedDimensionValue = seedIndex3D[0]; // X\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\n        break;\n      case 1:\n        fixedDimensionValue = seedIndex3D[1]; // Y\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\n        break;\n      case 2:\n        fixedDimensionValue = seedIndex3D[2]; // Z\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n    };\n\n    const getLabelValue = (x: number, y: number, z: number): number => {\n      return scalarData[getScalarDataPosition(x, y, z)];\n    };\n\n    const floodFillGetter = this.generateFloodFillGetter(\n      dimensions,\n      fixedDimension,\n      fixedDimensionValue,\n      getLabelValue\n    );\n\n    const getScalarDataPositionFromPlane =\n      this.generateGetScalarDataPositionFromPlane(\n        getScalarDataPosition,\n        fixedDimension,\n        fixedDimensionValue\n      );\n\n    return {\n      getScalarDataPositionFromPlane,\n      getLabelValue,\n      floodFillGetter,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    };\n  };\n\n  private getFixedDimension(\n    viewPlaneNormal: Types.Point3,\n    direction: number[]\n  ): number | undefined {\n    const xDirection = direction.slice(0, 3);\n    const yDirection = direction.slice(3, 6);\n    const zDirection = direction.slice(6, 9);\n\n    const absoluteOfViewPlaneNormal = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n\n    const absoluteOfXDirection = [\n      Math.abs(xDirection[0]),\n      Math.abs(xDirection[1]),\n      Math.abs(xDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n      return 0;\n    }\n\n    const absoluteOfYDirection = [\n      Math.abs(yDirection[0]),\n      Math.abs(yDirection[1]),\n      Math.abs(yDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n      return 1;\n    }\n\n    const absoluteOfZDirection = [\n      Math.abs(zDirection[0]),\n      Math.abs(zDirection[1]),\n      Math.abs(zDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n      return 2;\n    }\n  }\n\n  // Define a getter for the fill routine to access the working label map.\n  private generateFloodFillGetter = (\n    dimensions: Types.Point3,\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\n  ): FloodFillGetter => {\n    let floodFillGetter;\n\n    // In each helper we first check if out of bounds, as the flood filler\n    // doesn't know about the dimensions of the data structure that sits on top\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\n    // the same position in these getters.\n\n    switch (fixedDimension) {\n      case 0:\n        floodFillGetter = (y, z) => {\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(fixedDimensionValue, y, z);\n        };\n        break;\n\n      case 1:\n        floodFillGetter = (x, z) => {\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(x, fixedDimensionValue, z);\n        };\n        break;\n\n      case 2:\n        floodFillGetter = (x, y) => {\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n            return;\n          }\n\n          return getLabelValue(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return floodFillGetter;\n  };\n\n  private generateGetScalarDataPositionFromPlane = (\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\n    fixedDimension: number,\n    fixedDimensionValue: number\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\n    let getScalarDataPositionFromPlane;\n\n    switch (fixedDimension) {\n      case 0:\n        getScalarDataPositionFromPlane = (y, z) => {\n          return getScalarDataPosition(fixedDimensionValue, y, z);\n        };\n        break;\n      case 1:\n        getScalarDataPositionFromPlane = (x, z) => {\n          return getScalarDataPosition(x, fixedDimensionValue, z);\n        };\n        break;\n      case 2:\n        getScalarDataPositionFromPlane = (x, y) => {\n          return getScalarDataPosition(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return getScalarDataPositionFromPlane;\n  };\n}\n\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\nimport { BaseTool } from './base';\nimport {\n  Enums,\n  getEnabledElementByIds,\n  getRenderingEngines,\n} from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst OverlayMarkerType = {\n  ANNOTATED_CUBE: 1,\n  AXES: 2,\n  CUSTOM: 3,\n};\n\n/**\n * The OrientationMarker is a tool that includes an orientation marker in viewports\n * when activated\n */\nclass OrientationMarkerTool extends BaseTool {\n  static toolName;\n  static CUBE = 1;\n  static AXIS = 2;\n  static VTPFILE = 3;\n  orientationMarkers;\n  polyDataURL;\n  _resizeObservers = new Map();\n\n  static OVERLAY_MARKER_TYPES = OverlayMarkerType;\n\n  configuration_invalidated = true;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {\n        orientationWidget: {\n          enabled: true,\n          viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n          viewportSize: 0.15,\n          minPixelSize: 100,\n          maxPixelSize: 300,\n        },\n        overlayMarkerType:\n          OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n        overlayConfiguration: {\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n            faceProperties: {\n              xPlus: { text: 'R', faceColor: '#ffff00', faceRotation: 90 },\n              xMinus: { text: 'L', faceColor: '#ffff00', faceRotation: 270 },\n              yPlus: {\n                text: 'P',\n                faceColor: '#00ffff',\n                fontColor: 'white',\n                faceRotation: 180,\n              },\n              yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n              zPlus: { text: 'S' },\n              zMinus: { text: 'I' },\n            },\n            defaultStyle: {\n              fontStyle: 'bold',\n              fontFamily: 'Arial',\n              fontColor: 'black',\n              fontSizeScale: (res) => res / 2,\n              faceColor: '#0000ff',\n              edgeThickness: 0.1,\n              edgeColor: 'black',\n              resolution: 400,\n            },\n          },\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n            polyDataURL:\n              'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.orientationMarkers = {};\n    this.configuration_invalidated = true;\n  }\n\n  onSetToolEnabled = (): void => {\n    this.initViewports();\n    this.configuration_invalidated = true;\n    this._subscribeToViewportEvents();\n  };\n\n  onSetToolActive = (): void => {\n    this.initViewports();\n    this.configuration_invalidated = true;\n    this._subscribeToViewportEvents();\n  };\n\n  onSetToolDisabled = (): void => {\n    this.cleanUpData();\n    this._unsubscribeToViewportNewVolumeSet();\n  };\n\n  reset = () => {\n    this.configuration_invalidated = true;\n    this.initViewports();\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  resize = (viewportId) => {\n    const orientationMarker = this.orientationMarkers[viewportId];\n    if (!orientationMarker) {\n      return;\n    }\n\n    const { orientationWidget } = orientationMarker;\n    orientationWidget.updateViewport();\n  };\n\n  _unsubscribeToViewportNewVolumeSet() {\n    const viewportsInfo = this._getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this.reset\n      );\n\n      // // // unsubscribe to element resize events\n      const resizeObserver = this._resizeObservers.get(viewportId);\n      resizeObserver.unobserve(element);\n    });\n  }\n\n  _subscribeToViewportEvents() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this.reset\n      );\n\n      const resizeObserver = new ResizeObserver(() => {\n        // Todo: i wish there was a better way to do this\n        setTimeout(() => {\n          this.reset();\n        }, 100);\n      });\n\n      resizeObserver.observe(element);\n\n      this._resizeObservers.set(viewportId, resizeObserver);\n    });\n  }\n\n  private cleanUpData() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach((viewport) => {\n      const orientationMarker = this.orientationMarkers[viewport.id];\n      if (!orientationMarker) {\n        return;\n      }\n\n      const { actor, orientationWidget } = orientationMarker;\n      orientationWidget?.setEnabled(false);\n      orientationWidget?.delete();\n      actor?.delete();\n\n      const renderWindow = viewport\n        .getRenderingEngine()\n        .offscreenMultiRenderWindow.getRenderWindow();\n      renderWindow.render();\n      viewport.getRenderingEngine().render();\n\n      delete this.orientationMarkers[viewport.id];\n    });\n  }\n\n  private initViewports() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    viewports.forEach((viewport) => {\n      if (!viewport.getWidget(this.getToolName())) {\n        this.addAxisActorInViewport(viewport);\n      }\n    });\n  }\n\n  async addAxisActorInViewport(viewport) {\n    const viewportId = viewport.id;\n    const type = this.configuration.overlayMarkerType;\n\n    const overlayConfiguration = this.configuration.overlayConfiguration[type];\n\n    if (this.orientationMarkers[viewportId]) {\n      const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n      // remove the previous one\n      viewport.getRenderer().removeActor(actor);\n      orientationWidget.setEnabled(false);\n    }\n\n    let actor;\n    if (type === 1) {\n      actor = this.createAnnotationCube(overlayConfiguration);\n    } else if (type === 2) {\n      actor = vtkAxesActor.newInstance();\n    } else if (type === 3) {\n      actor = await this.createCustomActor();\n    }\n\n    const renderer = viewport.getRenderer();\n    const renderWindow = viewport\n      .getRenderingEngine()\n      .offscreenMultiRenderWindow.getRenderWindow();\n\n    const {\n      enabled,\n      viewportCorner,\n      viewportSize,\n      minPixelSize,\n      maxPixelSize,\n    } = this.configuration.orientationWidget;\n\n    const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n      actor,\n      interactor: renderWindow.getInteractor(),\n      parentRenderer: renderer,\n    });\n\n    orientationWidget.setEnabled(enabled);\n    orientationWidget.setViewportCorner(viewportCorner);\n    orientationWidget.setViewportSize(viewportSize);\n    orientationWidget.setMinPixelSize(minPixelSize);\n    orientationWidget.setMaxPixelSize(maxPixelSize);\n\n    orientationWidget.updateMarkerOrientation();\n    this.orientationMarkers[viewportId] = {\n      orientationWidget,\n      actor,\n    };\n    viewport.addWidget(this.getToolName(), orientationWidget);\n    renderWindow.render();\n    viewport.getRenderingEngine().render();\n\n    this.configuration_invalidated = false;\n  }\n\n  private async createCustomActor() {\n    const url =\n      this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n        .polyDataURL;\n\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const vtpReader = vtkXMLPolyDataReader.newInstance();\n    vtpReader.parseAsArrayBuffer(arrayBuffer);\n    vtpReader.update();\n\n    const polyData = vtkPolyData.newInstance();\n    polyData.shallowCopy(vtpReader.getOutputData());\n    polyData.getPointData().setActiveScalars('Color');\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputData(polyData);\n    mapper.setColorModeToDirectScalars();\n\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.rotateZ(180);\n    return actor;\n  }\n\n  private createAnnotationCube(overlayConfiguration: any) {\n    const actor = vtkAnnotatedCubeActor.newInstance();\n    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n    actor.setXPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.xPlus,\n    });\n    actor.setXMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.xMinus,\n    });\n    actor.setYPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.yPlus,\n    });\n    actor.setYMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.yMinus,\n    });\n    actor.setZPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.zPlus,\n    });\n    actor.setZMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.zMinus,\n    });\n    return actor;\n  }\n\n  async createAnnotatedCubeActor() {\n    const axes = vtkAnnotatedCubeActor.newInstance();\n    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n\n    axes.setDefaultStyle(defaultStyle);\n\n    Object.keys(faceProperties).forEach((key) => {\n      const methodName = `set${\n        key.charAt(0).toUpperCase() + key.slice(1)\n      }FaceProperty`;\n      axes[methodName](faceProperties[key]);\n    });\n\n    return axes;\n  }\n}\n\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  ToolGroupSpecificRepresentation,\n} from '../../types';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentationRepresentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport RepresentationTypes from '../../enums/SegmentationRepresentations';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport {\n  getHoveredContourSegmentationAnnotation,\n  getSegmentAtLabelmapBorder,\n  getSegmentAtWorldPoint,\n} from '../../utilities/segmentation';\nimport { state } from '../../store';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\n/**\n * Represents a tool used for segment selection. It is used to select a segment\n * by hovering over it.\n *\n */\nclass SegmentSelectTool extends BaseTool {\n  static toolName;\n  private hoverTimer: ReturnType<typeof setTimeout> | null;\n\n  static SelectMode = {\n    Inside: 'Inside',\n    Border: 'Border',\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        hoverTimeout: 100,\n        mode: SegmentSelectTool.SelectMode.Border,\n        searchRadius: 6, // search for border in a 6px radius\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.hoverTimer = null;\n  }\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (this.hoverTimer) {\n      clearTimeout(this.hoverTimer);\n    }\n\n    this.hoverTimer = setTimeout(() => {\n      this._setActiveSegment(evt);\n      this.hoverTimer = null;\n    }, this.configuration.hoverTimeout);\n\n    return true;\n  };\n\n  onSetToolEnabled = (): void => {\n    this.onSetToolActive();\n  };\n\n  onSetToolActive = (): void => {\n    this.hoverTimer = null;\n  };\n\n  onSetToolDisabled = (): void => {\n    this.hoverTimer = null;\n  };\n\n  _setActiveSegment(evt = {} as EventTypes.InteractionEventType): void {\n    if (state.isInteractingWithTool) {\n      return;\n    }\n\n    const { element, currentPoints } = evt.detail;\n\n    const worldPoint = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const activeSegmentationReps = getActiveSegmentationRepresentation(\n      this.toolGroupId\n    );\n\n    if (!activeSegmentationReps) {\n      return;\n    }\n\n    const supportedTypes = [\n      RepresentationTypes.Labelmap,\n      RepresentationTypes.Contour,\n    ];\n\n    if (supportedTypes.includes(activeSegmentationReps.type)) {\n      this._setActiveSegmentForType(\n        activeSegmentationReps,\n        worldPoint,\n        viewport\n      );\n    } else {\n      console.warn(\n        'SegmentSelectTool does not support the current segmentation type.'\n      );\n    }\n  }\n\n  _setActiveSegmentForType(\n    activeSegmentationReps: ToolGroupSpecificRepresentation,\n    worldPoint: Types.Point3,\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const imageDataInfo = viewport.getImageData();\n\n    if (!imageDataInfo) {\n      return;\n    }\n\n    const { segmentationId, type } = activeSegmentationReps;\n\n    let hoveredSegmentIndex;\n\n    if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n      hoveredSegmentIndex = getSegmentAtWorldPoint(segmentationId, worldPoint, {\n        viewport,\n      });\n    } else {\n      switch (type) {\n        case SegmentationRepresentations.Labelmap:\n          hoveredSegmentIndex = getSegmentAtLabelmapBorder(\n            segmentationId,\n            worldPoint,\n            {\n              viewport,\n              searchRadius: this.configuration.searchRadius,\n            }\n          );\n          break;\n\n        case SegmentationRepresentations.Contour:\n          hoveredSegmentIndex =\n            getHoveredContourSegmentationAnnotation(segmentationId);\n          break;\n      }\n    }\n\n    // No need to select background\n    if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n      return;\n    }\n\n    setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n\n    const renderingEngine = viewport.getRenderingEngine();\n    const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n\n    // update states\n    triggerSegmentationModified(segmentationId);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  }\n}\n\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import {\n  utilities as csUtils,\n  cache,\n  getEnabledElement,\n  StackViewport,\n  eventTarget,\n  Enums,\n} from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\n\nimport type { Types } from '@cornerstonejs/core';\nimport type {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BaseTool } from '../base';\nimport {\n  fillInsideSphere,\n  thresholdInsideSphere,\n} from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport {\n  thresholdInsideCircle,\n  fillInsideCircle,\n} from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport {\n  Events,\n  ToolModes,\n  SegmentationRepresentations,\n  StrategyCallbacks,\n} from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  state as segmentationState,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport {\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * A type for preview data/information, used to setup previews on hover, or\n * maintain the preview information.\n */\nexport type PreviewData = {\n  /**\n   *  The preview data returned from the strategy\n   */\n  preview: unknown;\n  timer?: number;\n  timerStart: number;\n  startPoint: Types.Point2;\n  element: HTMLDivElement;\n  isDrag: boolean;\n};\n\n/**\n * @public\n */\nclass BrushTool extends BaseTool {\n  static toolName;\n  private _editData: {\n    segmentsLocked: number[]; //\n    segmentationRepresentationUID?: string;\n    imageIdReferenceMap?: Map<string, string>;\n    volumeId?: string;\n    referencedVolumeId?: string;\n  } | null;\n  private _hoverData?: {\n    brushCursor: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentationRepresentationUID: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    centerCanvas?: Array<number>;\n  };\n\n  private _previewData?: PreviewData = {\n    preview: null,\n    element: null,\n    timerStart: 0,\n    timer: null,\n    startPoint: [NaN, NaN],\n    isDrag: false,\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n          FILL_INSIDE_SPHERE: fillInsideSphere,\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n          THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n        },\n        strategySpecificConfiguration: {\n          THRESHOLD: {\n            threshold: [-150, -70], // E.g. CT Fat // Only used during threshold strategies.\n          },\n        },\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\n        thresholdVolumeId: null,\n        brushSize: 25,\n        preview: {\n          // Have to enable the preview to use this\n          enabled: false,\n          previewColors: {},\n          // The time before showing a preview\n          previewTimeMs: 250,\n          // The distance to move to show a preview before preview time expired\n          previewMoveDistance: 8,\n          // The distance to drag before being considered a drag rather than click\n          dragMoveDistance: 4,\n          // The time to consider a mouse click a drag when moved less than dragMoveDistance\n          dragTimeMs: 500,\n        },\n        actions: {\n          [StrategyCallbacks.AcceptPreview]: {\n            method: StrategyCallbacks.AcceptPreview,\n            bindings: [\n              {\n                key: 'Enter',\n              },\n            ],\n          },\n          [StrategyCallbacks.RejectPreview]: {\n            method: StrategyCallbacks.RejectPreview,\n            bindings: [\n              {\n                key: 'Escape',\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolPassive = (evt) => {\n    this.disableCursor();\n  };\n\n  onSetToolEnabled = () => {\n    this.disableCursor();\n  };\n\n  onSetToolDisabled = (evt) => {\n    this.disableCursor();\n  };\n\n  private disableCursor() {\n    this._hoverData = undefined;\n    this.rejectPreview();\n  }\n\n  createEditData(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create a segmentation representation before using the brush tool'\n      );\n    }\n\n    const { segmentationId, type, segmentationRepresentationUID } =\n      activeSegmentationRepresentation;\n\n    if (type === SegmentationRepresentations.Contour) {\n      throw new Error('Not implemented yet');\n    }\n\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const { representationData } =\n      segmentationState.getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n      const actors = viewport.getActors();\n\n      const isStackViewport = viewport instanceof StackViewport;\n\n      if (isStackViewport) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n          detail: {\n            type: 'Segmentation',\n            message: 'Cannot perform brush operation on the selected viewport',\n          },\n          cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n      }\n\n      // we used to take the first actor here but we should take the one that is\n      // probably the same size as the segmentation volume\n      const volumes = actors.map((actorEntry) =>\n        cache.getVolume(actorEntry.referenceId)\n      );\n\n      const segmentationVolume = cache.getVolume(volumeId);\n\n      const referencedVolumeIdToThreshold =\n        volumes.find((volume) =>\n          csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions)\n        )?.volumeId || volumes[0]?.volumeId;\n\n      return {\n        volumeId,\n        referencedVolumeId:\n          this.configuration.thresholdVolumeId ?? referencedVolumeIdToThreshold,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = viewport.getCurrentImageId();\n\n      if (!imageIdReferenceMap.get(currentImageId)) {\n        // if there is no stack segmentation slice for the current image\n        // we should not allow the user to perform any operation\n        return;\n      }\n\n      // here we should identify if we can perform sphere manipulation\n      // for these stack of images, if the metadata is not present\n      // to create a volume or if there are inconsistencies between\n      // the image metadata we should not allow the sphere manipulation\n      // and should throw an error or maybe simply just allow circle manipulation\n      // and not sphere manipulation\n      if (this.configuration.activeStrategy.includes('SPHERE')) {\n        throw new Error(\n          'Sphere manipulation is not supported for stacks of image segmentations yet'\n        );\n        // Todo: add sphere (volumetric) manipulation support for stacks of images\n        // we should basically check if the stack constructs a valid volume\n        // meaning all the metadata is present and consistent\n        // then we use a VoxelManager mapping to map a volume like appearance\n        // for the stack data.\n        // csUtils.isValidVolume(referencedImageIds\n      }\n\n      return {\n        imageIdReferenceMap,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    }\n  }\n\n  preMouseDownCallback = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): boolean => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._editData = this.createEditData(element);\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    // This might be a mouse down\n    this._previewData.isDrag = false;\n    this._previewData.timerStart = Date.now();\n\n    const hoverData = this._hoverData || this.createHoverData(element);\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      hoverData.viewportIdsToRender\n    );\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.OnInteractionStart\n    );\n\n    return true;\n  };\n\n  /**\n   * This call will be made when the mouse moves and the tool is active, but\n   * not actually drawing at the moment.\n   * The behavior is:\n   *    1. Update the cursor\n   *    2. Call the active strategy event 'preview' and 'rejectPreview'\n   *       on the mouse cursor position on a periodic basis to create a preview\n   *       when configured to do so.\n   *\n   * The preview will be shown after the mouse has been stationary for 250 ms.\n   * Any preview will be cancelled (immediately) after moving outside the center\n   * distance.\n   * As well, if the mouse moves but stays inside the center area for 250 ms,\n   * then the cancel will happen with a new preview being added.\n   *\n   * See mouse up details for how the preview gets accepted.\n   *\n   * The preview also needs to be cancelled on changing tools.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.updateCursor(evt);\n      if (!this.configuration.preview.enabled) {\n        return;\n      }\n      const { previewTimeMs, previewMoveDistance, dragMoveDistance } =\n        this.configuration.preview;\n      const { currentPoints, element } = evt.detail;\n      const { canvas } = currentPoints;\n\n      const { preview, startPoint, timer, timerStart, isDrag } =\n        this._previewData;\n      const delta = vec2.distance(canvas, startPoint);\n      const time = Date.now() - timerStart;\n      if (\n        delta > previewMoveDistance ||\n        (time > previewTimeMs && delta > dragMoveDistance)\n      ) {\n        if (timer) {\n          window.clearTimeout(timer);\n          this._previewData.timer = null;\n        }\n        if (preview && !isDrag) {\n          this.rejectPreview(element);\n        }\n      }\n      if (!this._previewData.timer) {\n        const timer = window.setTimeout(this.previewCallback, 250);\n        Object.assign(this._previewData, {\n          timerStart: Date.now(),\n          timer,\n          startPoint: canvas,\n          element,\n        });\n      }\n    }\n  };\n\n  previewCallback = () => {\n    if (this._previewData.preview) {\n      return;\n    }\n    this._previewData.timer = null;\n    this._previewData.preview = this.applyActiveStrategyCallback(\n      getEnabledElement(this._previewData.element),\n      this.getOperationData(this._previewData.element),\n      StrategyCallbacks.Preview\n    );\n  };\n\n  private createHoverData(element, centerCanvas?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const viewportIdsToRender = [viewport.id];\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    } = this.getActiveSegmentationData() || {};\n\n    // Center of circle in canvas Coordinates\n    const brushCursor = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {},\n    };\n\n    return {\n      brushCursor,\n      centerCanvas,\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n      viewportIdsToRender,\n    };\n  }\n\n  private getActiveSegmentationData() {\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      console.warn(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n      return;\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    return {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    };\n  }\n\n  /**\n   * Updates the cursor position and whether it is showing or not.\n   * Can be over-ridden to add more cursor details or a preview.\n   */\n  protected updateCursor(evt: EventTypes.InteractionEventType) {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { currentPoints } = eventData;\n    const centerCanvas = currentPoints.canvas;\n    this._hoverData = this.createHoverData(element, centerCanvas);\n\n    this._calculateCursor(element, centerCanvas);\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    triggerAnnotationRenderForViewportUIDs(\n      getEnabledElement(element).renderingEngine,\n      this._hoverData.viewportIdsToRender\n    );\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.updateCursor(evt);\n\n    const { viewportIdsToRender } = this._hoverData;\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    const delta = vec2.distance(\n      currentPoints.canvas,\n      this._previewData.startPoint\n    );\n    const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n    if (\n      !this._previewData.isDrag &&\n      this._previewData.preview &&\n      Date.now() - this._previewData.timerStart < dragTimeMs &&\n      delta < dragMoveDistance\n    ) {\n      // If we are showing a preview, then don't start dragging quite immediately\n      // so that click up can accept the preview.\n      return;\n    }\n\n    this._previewData.preview = this.applyActiveStrategy(\n      enabledElement,\n      this.getOperationData(element)\n    );\n    this._previewData.element = element;\n    // Add a bit of time to the timer start so small accidental movements dont\n    // cause issues on clicking\n    this._previewData.timerStart = Date.now() + dragTimeMs;\n    this._previewData.isDrag = true;\n    this._previewData.startPoint = currentPoints.canvas;\n  };\n\n  protected getOperationData(element?) {\n    const editData = this._editData || this.createEditData(element);\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n    } = this._hoverData || this.createHoverData(element);\n    const { data, metadata = {} } = brushCursor || {};\n    const { viewPlaneNormal, viewUp } = metadata;\n    const operationData = {\n      ...editData,\n      points: data?.handles?.points,\n      segmentIndex,\n      previewColors: this.configuration.preview.enabled\n        ? this.configuration.preview.previewColors\n        : null,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n      // Provide the preview information so that data can be used directly\n      preview: this._previewData?.preview,\n    };\n    return operationData;\n  }\n\n  private _calculateCursor(element, centerCanvas) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n    const camera = viewport.getCamera();\n    const { brushSize } = this.configuration;\n\n    const viewUp = vec3.fromValues(\n      camera.viewUp[0],\n      camera.viewUp[1],\n      camera.viewUp[2]\n    );\n    const viewPlaneNormal = vec3.fromValues(\n      camera.viewPlaneNormal[0],\n      camera.viewPlaneNormal[1],\n      camera.viewPlaneNormal[2]\n    );\n    const viewRight = vec3.create();\n\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n    // in the world coordinate system, the brushSize is the radius of the circle\n    // in mm\n    const centerCursorInWorld: Types.Point3 = canvasToWorld([\n      centerCanvas[0],\n      centerCanvas[1],\n    ]);\n\n    const bottomCursorInWorld = vec3.create();\n    const topCursorInWorld = vec3.create();\n    const leftCursorInWorld = vec3.create();\n    const rightCursorInWorld = vec3.create();\n\n    // Calculate the bottom and top points of the circle in world coordinates\n    for (let i = 0; i <= 2; i++) {\n      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n    }\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { brushCursor } = this._hoverData;\n    const { data } = brushCursor;\n\n    if (data.handles === undefined) {\n      data.handles = {};\n    }\n\n    data.handles.points = [\n      bottomCursorInWorld,\n      topCursorInWorld,\n      leftCursorInWorld,\n      rightCursorInWorld,\n    ];\n\n    const activeStrategy = this.configuration.activeStrategy;\n    const strategy = this.configuration.strategies[activeStrategy];\n\n    // Note: i don't think this is the best way to implement this\n    // but don't think we have a better way to do it for now\n    if (typeof strategy.computeInnerCircleRadius === 'function') {\n      strategy.computeInnerCircleRadius({\n        configuration: this.configuration,\n        viewport,\n      });\n    }\n\n    data.invalidated = false;\n  }\n\n  /**\n   * The end callback call is made when the mouse is released.  This will\n   * perform another active strategy render event to render the final position.\n   * As well, the finish strategy callback will be made during this time.\n   */\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = this.getOperationData(element);\n    // Don't re-fill when the preview is showing and the user clicks again\n    // otherwise the new area of hover may get filled, which is unexpected\n    if (!this._previewData.preview && !this._previewData.isDrag) {\n      this.applyActiveStrategy(enabledElement, operationData);\n    }\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    this.updateCursor(evt);\n\n    this._editData = null;\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      operationData,\n      StrategyCallbacks.OnInteractionEnd\n    );\n\n    if (!this._previewData.isDrag) {\n      this.acceptPreview(element);\n    }\n  };\n\n  /**\n   * Cancels any preview view being shown, resetting any segments being shown.\n   */\n  public rejectPreview(element = this._previewData.element) {\n    if (!element || !this._previewData.preview) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.RejectPreview\n    );\n    this._previewData.preview = null;\n    this._previewData.isDrag = false;\n  }\n\n  /**\n   * Accepts a preview, marking it as the active segment.\n   */\n  public acceptPreview(element = this._previewData.element) {\n    if (!element) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.AcceptPreview\n    );\n    this._previewData.isDrag = false;\n    this._previewData.preview = null;\n  }\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  private _activateDraw = (element: HTMLDivElement): void => {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  private _deactivateDraw = (element: HTMLDivElement): void => {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  public invalidateBrushCursor() {\n    if (this._hoverData === undefined) {\n      return;\n    }\n    const { data } = this._hoverData.brushCursor;\n\n    data.invalidated = true;\n\n    // Todo: figure out if other brush metadata (other than segment color) should get updated\n    // during the brush cursor invalidation\n    const { segmentColor } = this.getActiveSegmentationData() || {};\n    this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n  }\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return;\n    }\n\n    const brushCursor = this._hoverData.brushCursor;\n\n    if (brushCursor.data.invalidated === true) {\n      const { centerCanvas } = this._hoverData;\n      const { element } = viewport;\n\n      // This can be set true when changing the brush size programmatically\n      // whilst the cursor is being rendered.\n      this._calculateCursor(element, centerCanvas);\n    }\n\n    const toolMetadata = brushCursor.metadata;\n    if (!toolMetadata) {\n      return;\n    }\n\n    const annotationUID = toolMetadata.brushCursorUID;\n\n    const data = brushCursor.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    const activeStrategy = this.configuration.activeStrategy;\n    const { dynamicRadiusInCanvas } = this.configuration\n      .strategySpecificConfiguration[activeStrategy] || {\n      dynamicRadiusInCanvas: 0,\n    };\n\n    if (dynamicRadiusInCanvas) {\n      const circleUID1 = '1';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID1,\n        center as Types.Point2,\n        dynamicRadiusInCanvas,\n        {\n          color,\n        }\n      );\n    }\n  }\n}\n\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  LabelmapToolOperationData,\n  LabelmapToolOperationDataStack,\n  LabelmapToolOperationDataVolume,\n} from '../../../../types';\nimport { Types, VolumeViewport } from '@cornerstonejs/core';\n\nfunction isVolumeSegmentation(\n  operationData: LabelmapToolOperationData | LabelmapSegmentationData,\n  viewport?: Types.IViewport\n): operationData is\n  | LabelmapToolOperationDataVolume\n  | LabelmapSegmentationDataVolume {\n  const { imageIdReferenceMap } =\n    operationData as LabelmapToolOperationDataStack;\n  const { volumeId } = operationData as LabelmapToolOperationDataVolume;\n\n  if (volumeId && !imageIdReferenceMap) {\n    return true;\n  }\n\n  if (imageIdReferenceMap && !volumeId) {\n    return false;\n  }\n\n  if (volumeId && imageIdReferenceMap && !viewport) {\n    throw new Error(\n      'isVolumeSegmentation: viewport is required when both volumeId and imageIdReferenceMap are provided'\n    );\n  }\n\n  // we can get the viewport to decide\n  return viewport instanceof VolumeViewport;\n}\n\nexport { isVolumeSegmentation };\n","import type { Types } from '@cornerstonejs/core';\nimport { Annotation } from './AnnotationTypes';\n\n/**\n * Polyline winding direction\n *\n * It is defined as -1 and 1 to make it easier to change its direction multiplying\n * by -1 whenever polyline.reverse() is called instead of using IF/ELSE\n */\nexport enum ContourWindingDirection {\n  CounterClockwise = -1,\n  Unknown = 0,\n  Clockwise = 1,\n}\n\nexport type ContourAnnotationData = {\n  data: {\n    contour: {\n      polyline: Types.Point3[];\n      closed: boolean;\n      windingDirection?: ContourWindingDirection;\n    };\n  };\n  onInterpolationComplete?: () => void;\n};\n\nexport type ContourAnnotation = Annotation & ContourAnnotationData;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  // use for loop for performance\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  }\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Adds a contour segmentation annotation to the specified segmentation.\n * @param annotation - The contour segmentation annotation to add.\n */\nexport function addContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (annotation.parentAnnotationUID) {\n    // Don't add it for parent annotations - this happens during interpolation\n    return;\n  }\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation.representationData.CONTOUR) {\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\n  }\n\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    annotationsUIDsSet = new Set();\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n  }\n\n  annotationUIDsMap.set(\n    segmentIndex,\n    annotationsUIDsSet.add(annotation.annotationUID)\n  );\n}\n","import { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\n/**\n * Check if two contour segmentations are from same segmentId,\n * segmentationRepresentationUID and segmentIndex.\n * @param firstAnnotation - First annotation\n * @param secondAnnotation - Second annotation\n * @returns True if they are from same segmentId, segmentationRepresentationUID\n * and segmentIndex or false otherwise.\n */\nexport default function areSameSegment(\n  firstAnnotation: ContourSegmentationAnnotation,\n  secondAnnotation: ContourSegmentationAnnotation\n) {\n  const { segmentation: firstSegmentation } = firstAnnotation.data;\n  const { segmentation: secondSegmentation } = secondAnnotation.data;\n\n  return (\n    firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n    firstSegmentation.segmentIndex === secondSegmentation.segmentIndex\n  );\n}\n","import { Annotation } from '../../types';\nimport { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\nexport default function isContourSegmentationAnnotation(\n  annotation: Annotation\n): annotation is ContourSegmentationAnnotation {\n  return !!(<ContourSegmentationAnnotation>annotation).data?.segmentation;\n}\n","import { state } from '../../stateManagement/segmentation';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Removes a contour segmentation annotation from the given annotation.\n * If the annotation does not have a segmentation data, this method returns\n * quietly.  This can occur for interpolated segmentations that have not yet\n * been converted to real segmentations or other in-process segmentations.\n * @param annotation - The contour segmentation annotation to remove.\n */\nexport function removeContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = state.getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    return;\n  }\n\n  annotationsUIDsSet.delete(annotation.annotationUID);\n\n  // Delete segmentIndex Set if there is no more annotations\n  if (!annotationsUIDsSet.size) {\n    annotationUIDsMap.delete(segmentIndex);\n  }\n}\n","/**\n * Calculates the perimeter of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param closed - Indicates whether the polyline is closed or not.\n * @returns The perimeter of the polyline.\n */\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\n  let perimeter = 0;\n\n  for (let i = 0; i < polyline.length - 1; i++) {\n    const point1 = polyline[i];\n    const point2 = polyline[i + 1];\n    perimeter += Math.sqrt(\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\n    );\n  }\n\n  if (closed) {\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    perimeter += Math.sqrt(\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\n    );\n  }\n\n  return perimeter;\n}\n\nexport default calculatePerimeter;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds the index in the polyline of the specified handle.  If the handle\n * doesn't match a polyline point, then finds the closest polyline point.\n *\n * Assumes polyline is in the same orientation as the handles.\n *\n * @param annotation - to find the polyline and handles in\n * @param handleIndex - the index of hte handle to look for.\n *     Negative values are treated relative to the end of the handle index.\n * @returns Index in polyline of the closest handle\n *     * 0 for handleIndex 0\n *     * length for `handleIndex===handles length`\n */\nexport default function findHandlePolylineIndex(\n  annotation: ContourAnnotation,\n  handleIndex: number\n): number {\n  const { polyline } = annotation.data.contour;\n  const { points } = annotation.data.handles;\n  const { length } = points;\n  if (handleIndex === length) {\n    return polyline.length;\n  }\n  if (handleIndex < 0) {\n    handleIndex = (handleIndex + length) % length;\n  }\n  if (handleIndex === 0) {\n    return 0;\n  }\n  const handle = points[handleIndex];\n  const index = polyline.findIndex((point) => isEqual(handle, point));\n  if (index !== -1) {\n    return index;\n  }\n  // Need to find nearest\n  let closestDistance = Infinity;\n  return polyline.reduce((closestIndex, point, testIndex) => {\n    const distance = vec3.squaredDistance(point, handle);\n    if (distance < closestDistance) {\n      closestDistance = distance;\n      return testIndex;\n    }\n    return closestIndex;\n  }, -1);\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { ContourAnnotation } from '../../types/ContourAnnotation';\n\n/**\n * Check if two contour segmentation annotations are coplanar.\n *\n * A plane may be represented by a normal and a distance then to know if they\n * are coplanar we need to:\n *   - check if the normals of the two annotations are pointing to the same\n *   direction or to opposite directions (dot product equal to 1 or -1\n *   respectively)\n *   - Get one point from each polyline and project it onto the normal to get\n *   the distance from the origin (0, 0, 0).\n */\nexport default function areCoplanarContours(\n  firstAnnotation: ContourAnnotation,\n  secondAnnotation: ContourAnnotation\n) {\n  const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n  const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n  const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n  const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n\n  if (!parallelPlanes) {\n    return false;\n  }\n\n  const { polyline: firstPolyline } = firstAnnotation.data.contour;\n  const { polyline: secondPolyline } = secondAnnotation.data.contour;\n\n  // Choose one of the normals and calculate the distance of a point from each\n  // polyline along that normal. Both normal cannot be used with absolute dot\n  // product values because one of the view planes may be flipped or one of the\n  // points may be at the same distance but in the opposite direction\n  const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n  const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n\n  return glMatrix.equals(firstDistance, secondDistance);\n}\n","function findNextLink(line, lines, contourPoints) {\n  let index = -1;\n  lines.forEach((cell, i) => {\n    if (index >= 0) {\n      return;\n    }\n\n    if (cell.a == line.b) {\n      index = i;\n    }\n  });\n\n  if (index >= 0) {\n    const nextLine = lines[index];\n    lines.splice(index, 1);\n\n    contourPoints.push(nextLine.b);\n\n    if (contourPoints[0] == nextLine.b) {\n      return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'CLOSED_PLANAR',\n        //type: 'CLOSEDPLANAR_XOR',\n      };\n    }\n\n    return findNextLink(nextLine, lines, contourPoints);\n  }\n\n  return {\n    remainingLines: lines,\n    contourPoints,\n    type: 'OPEN_PLANAR',\n  };\n}\n\n/**\n *\n * @param {*} lines\n */\nexport function findContours(lines) {\n  if (lines.length == 0) {\n    return [];\n  }\n\n  const contourPoints = [];\n\n  const firstCell = lines.shift();\n  contourPoints.push(firstCell.a);\n  contourPoints.push(firstCell.b);\n  const result = findNextLink(firstCell, lines, contourPoints);\n\n  if (result.remainingLines.length == 0) {\n    return [\n      {\n        type: result.type,\n        contourPoints: result.contourPoints,\n      },\n    ];\n  } else {\n    const extraContours = findContours(result.remainingLines);\n    extraContours.push({\n      type: result.type,\n      contourPoints: result.contourPoints,\n    });\n    return extraContours;\n  }\n}\n\nexport function findContoursFromReducedSet(lines) {\n  return findContours(lines);\n}\n\nexport default {\n  findContours,\n  findContoursFromReducedSet,\n};\n","/**\n * Iterate through polyData from vtkjs and merge any points that are the same\n * then update merged point references within lines array\n * @param polyData - vtkPolyData\n * @param bypass - bypass the duplicate point removal\n * @returns the updated polyData\n */\nexport function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n  const points = polyData.getPoints();\n  const lines = polyData.getLines();\n\n  // Todo: This is cloning which is not ideal, we should move to use the PointsArrayManager\n  // that will get merged soon\n  const pointsArray = new Array(points.getNumberOfPoints())\n    .fill(0)\n    .map((_, i) => points.getPoint(i).slice());\n\n  const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n    const cell = lines.getCell(i * 3).slice();\n    return { a: cell[0], b: cell[1] };\n  });\n\n  if (bypass) {\n    return { points: pointsArray, lines: linesArray };\n  }\n\n  const newPoints = [];\n  for (const [i, pt] of pointsArray.entries()) {\n    // Todo: This is an n^2 algorithm - consider using a Map<string,Point3>.\n    // Generates a reasonable amount of garbage, but I think the performance\n    //  of that is better than doing repeated compares across the entire array.\n    const index = newPoints.findIndex(\n      (point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]\n    );\n\n    if (index >= 0) {\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = index;\n        }\n        if (line.b === i) {\n          line.b = index;\n        }\n        return line;\n      });\n    } else {\n      const newIndex = newPoints.length;\n      newPoints.push(pt);\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = newIndex;\n        }\n        if (line.b === i) {\n          line.b = newIndex;\n        }\n        return line;\n      });\n    }\n  }\n\n  const newLines = linesArray.filter((line) => line.a !== line.b);\n\n  return { points: newPoints, lines: newLines };\n}\n\nexport default { getDeduplicatedVTKPolyDataPoints };\n","/**\n * Functions for detecting and dealing with holes within contours.\n * Expected Contour format:\n * {\n *   type,\n *   contourPoints\n * }\n */\n\n/**\n * Checks if point is inside polygon defined by vertices array\n * Code from\n * https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\n * most original version based on:\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n * @param {*} point\n * @param {*} vertices\n * @returns\n */\nconst getIsPointInsidePolygon = (point, vertices) => {\n  // Todo: this is a duplicated logic we should merge it with the other one\n  // which is containsPoint in the utilities\n  const x = point[0];\n  const y = point[1];\n\n  let inside = false;\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n    const xi = vertices[i][0],\n      yi = vertices[i][1];\n    const xj = vertices[j][0],\n      yj = vertices[j][1];\n\n    const intersect =\n      yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Check if inner contour is completely surrounded by outer contour.\n * @param {*} outerContour\n * @param {*} innerContour\n * @returns\n */\nfunction checkEnclosed(outerContour, innerContour, points) {\n  const vertices = [];\n  outerContour.contourPoints.forEach((point) => {\n    vertices.push([points[point][0], points[point][1]]);\n  });\n\n  let pointsNotEnclosed = 0;\n  innerContour.contourPoints.forEach((point) => {\n    const result = getIsPointInsidePolygon(\n      [points[point][0], points[point][1]],\n      vertices\n    );\n    //console.log(result);\n\n    if (!result) {\n      pointsNotEnclosed++;\n    }\n  });\n\n  return pointsNotEnclosed === 0;\n}\n\n/**\n * Check if contours have holes, if so update contour accordingly\n * @param {*} polyData\n * @param {*} bypass\n */\nexport function processContourHoles(contours, points, useXOR = true) {\n  //console.log(points);\n\n  // Add non-closed planars to contour list\n  const retContours = contours.filter(\n    (contour) => contour.type !== 'CLOSED_PLANAR'\n  );\n\n  // Find closed planar contours\n  const closedContours = contours.filter(\n    (contour) => contour.type === 'CLOSED_PLANAR'\n  );\n\n  // Iterate through each contour in list check for contours that have holes\n  const contourWithHoles = [];\n  let contourWithoutHoles = [];\n  closedContours.forEach((contour, index) => {\n    const holes = [];\n\n    // Check if any other contour is a hole surrounded by current contour\n    closedContours.forEach((hContour, hIndex) => {\n      if (index != hIndex) {\n        // Check if inner loop contour is a hole of outer loop contour\n        if (checkEnclosed(contour, hContour, points)) {\n          holes.push(hIndex);\n        }\n      }\n    });\n\n    // Check if holes were found\n    if (holes.length > 0) {\n      // Note current contour and reference of its holes\n      contourWithHoles.push({\n        contour,\n        holes,\n      });\n    } else {\n      // Note contour index without holes\n      contourWithoutHoles.push(index);\n    }\n  });\n\n  if (useXOR) {\n    // XOR method\n    contourWithHoles.forEach((contourHoleSet) => {\n      // Modify contour with hole to type CLOSEDPLANAR_XOR\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n      retContours.push(contourHoleSet.contour);\n\n      contourHoleSet.holes.forEach((holeIndex) => {\n        // Modify hole type to CLOSEDPLANAR_XOR\n        // and add to contour list to be returned\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n        retContours.push(closedContours[holeIndex]);\n\n        // Remove hole from list of contours without holes\n        contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n          return contourIndex !== holeIndex;\n        });\n      });\n    });\n\n    // Add remaining contours to list (neither hole nor have holes)\n    contourWithoutHoles.forEach((contourIndex) => {\n      retContours.push(closedContours[contourIndex]);\n    });\n  } else {\n    // Keyhole method, not implemented\n  }\n\n  return retContours;\n}\n\nexport default { processContourHoles };\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\nconst { Labelmap } = SegmentationRepresentations;\n\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n  const { representationData, segments = [0, 1] } = segmentations;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  // Get segmentation volume\n  const vol = cornerstoneCache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const numSlices = vol.dimensions[2];\n\n  // NOTE: Workaround for marching squares not finding closed contours at\n  // boundary of image volume, clear pixels along x-y border of volume\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n\n  for (let z = 0; z < numSlices; z++) {\n    for (let y = 0; y < vol.dimensions[1]; y++) {\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n      segData[index] = 0;\n      segData[index + vol.dimensions[0] - 1] = 0;\n    }\n  }\n\n  // end workaround\n  //\n  //\n  const ContourSets = [];\n\n  const { FrameOfReferenceUID } = vol.metadata;\n  // Iterate through all segments in current segmentation set\n  const numSegments = segments.length;\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n    const segment = segments[segIndex];\n\n    // Skip empty segments\n    if (!segment) {\n      continue;\n    }\n\n    const sliceContours = [];\n    const scalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      numberOfComponents: 1,\n      size: pixelsPerSlice * numSlices,\n      dataType: 'Uint8Array',\n    });\n    const { containedSegmentIndices } = segment;\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n      // Check if the slice is empty before running marching cube\n      if (\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\n      ) {\n        continue;\n      }\n      const frameStart = sliceIndex * pixelsPerSlice;\n\n      try {\n        // Modify segData for this specific segment directly\n        for (let i = 0; i < pixelsPerSlice; i++) {\n          const value = segData[i + frameStart];\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\n            (scalars as any).setValue(i + frameStart, 1);\n          } else {\n            (scalars as any).setValue(i, 0);\n          }\n        }\n\n        const mSquares = vtkImageMarchingSquares.newInstance({\n          slice: sliceIndex,\n        });\n\n        // filter out the scalar data so that only it has background and\n        // the current segment index\n        const imageDataCopy = vtkImageData.newInstance();\n\n        imageDataCopy.shallowCopy(vol.imageData);\n        imageDataCopy.getPointData().setScalars(scalars);\n\n        // Connect pipeline\n        mSquares.setInputData(imageDataCopy);\n        const cValues = [1];\n        mSquares.setContourValues(cValues);\n        mSquares.setMergePoints(false);\n\n        // Perform marching squares\n        const msOutput = mSquares.getOutputData();\n\n        // Clean up output from marching squares\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n          const contours = findContoursFromReducedSet(reducedSet.lines);\n\n          sliceContours.push({\n            contours,\n            polyData: reducedSet,\n            FrameNumber: sliceIndex + 1,\n            sliceIndex,\n            FrameOfReferenceUID,\n          });\n        }\n      } catch (e) {\n        console.warn(sliceIndex);\n        console.warn(e);\n      }\n    }\n\n    const metadata = {\n      FrameOfReferenceUID,\n    };\n\n    const ContourSet = {\n      label: segment.label,\n      color: segment.color,\n      metadata,\n      sliceContours,\n    };\n\n    ContourSets.push(ContourSet);\n  }\n\n  return ContourSets;\n}\n\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n  const startIdx = sliceIndex * pixelsPerSlice;\n  const endIdx = startIdx + pixelsPerSlice;\n\n  for (let i = startIdx; i < endIdx; i++) {\n    if (segData[i] === segIndex) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { generateContourSetsFromLabelmap };\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\n\nfunction validateAnnotation(annotation) {\n  if (!annotation?.data) {\n    throw new Error('Tool data is empty');\n  }\n\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\n    throw new Error('Tool data is not associated with any imageId');\n  }\n}\n\nclass AnnotationToPointData {\n  static TOOL_NAMES: Record<string, any> = {};\n\n  constructor() {\n    // empty\n  }\n\n  static convert(annotation, index, metadataProvider) {\n    validateAnnotation(annotation);\n\n    const { toolName } = annotation.metadata;\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n\n    if (!toolClass) {\n      throw new Error(\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\n      );\n    }\n\n    // Each toolData should become a list of contours, ContourSequence\n    // contains a list of contours with their pointData, their geometry\n    // type and their length.\n    const ContourSequence = toolClass.getContourSequence(\n      annotation,\n      metadataProvider\n    );\n\n    // Todo: random rgb color for now, options should be passed in\n    const color = [\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n    ];\n\n    return {\n      ReferencedROINumber: index + 1,\n      ROIDisplayColor: color,\n      ContourSequence,\n    };\n  }\n\n  static register(toolClass) {\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n  }\n}\n\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\n\nexport default AnnotationToPointData;\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation, ContourAnnotation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\n\n/**\n * Get child polylines data in world space for contour annotations that represent the holes\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines (holes) in world space\n */\nexport default function getContourHolesDataWorld(\n  annotation: Annotation\n): Types.Point3[][] {\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n\n  return childAnnotationUIDs.map(\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types';\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\n\n/**\n * Get the polylines for the child annotations (holes)\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines\n */\nexport default function getContourHolesDataCanvas(\n  annotation: Annotation,\n  viewport: Types.IViewport\n): Types.Point2[][] {\n  const worldHoleContours = getContourHolesDataWorld(annotation);\n  const canvasHoleContours = [];\n\n  worldHoleContours.forEach((worldHoleContour) => {\n    const numPoints = worldHoleContour.length;\n\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\n\n    // Using FOR loop instead of map() for better performance when processing large arrays\n    for (let i = 0; i < numPoints; i++) {\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n    }\n\n    canvasHoleContours.push(canvasHoleContour);\n  });\n\n  return canvasHoleContours;\n}\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nimport type { AcceptInterpolationSelector } from '../../../types/InterpolationTypes';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\n\n/**\n * Accepts interpolated annotations, marking them as autoGenerated false.\n *\n * @param annotationGroupSelector - viewport or FOR to select annotations on\n * @param selector - nested selection criteria\n */\nexport default function acceptAutogeneratedInterpolations(\n  annotationGroupSelector: AnnotationGroupSelector,\n  selector: AcceptInterpolationSelector\n) {\n  InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport type { ContourAnnotation } from '../../types';\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport {\n  getParentAnnotation,\n  invalidateAnnotation,\n} from '../../stateManagement';\n\n/**\n * Update the contour polyline data\n * @param annotation - Contour annotation\n * @param viewport - Viewport\n * @param polylineData - Polyline data (points, winding direction and closed)\n * @param transforms - Methods to convert points to/from canvas and world spaces\n * @param options - Options\n *   - decimate: allow to set some parameters to decimate the polyline reducing\n *   the amount of points stored which also affects how fast it will draw the\n *   annotation in a viewport, compute the winding direction, append/remove\n *   contours and create holes. A higher `epsilon` value results in a polyline\n *   with less points.\n */\nexport default function updateContourPolyline(\n  annotation: ContourAnnotation,\n  polylineData: {\n    points: Types.Point2[];\n    closed?: boolean;\n    targetWindingDirection?: ContourWindingDirection;\n  },\n  transforms: {\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\n  },\n  options?: {\n    decimate?: {\n      enabled?: boolean;\n      epsilon?: number;\n    };\n  }\n) {\n  const { canvasToWorld } = transforms;\n  const { data } = annotation;\n  const { targetWindingDirection } = polylineData;\n  let { points: polyline } = polylineData;\n\n  // Decimate the polyline to reduce tha amount of points\n  if (options?.decimate?.enabled) {\n    polyline = math.polyline.decimate(\n      polylineData.points,\n      options?.decimate?.epsilon\n    );\n  }\n\n  let { closed } = polylineData;\n  const numPoints = polyline.length;\n  const polylineWorldPoints = new Array(numPoints);\n  const currentWindingDirection = math.polyline.getWindingDirection(polyline);\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\n\n  if (closed === undefined) {\n    let currentClosedState = false;\n\n    // With two points it is just a line and do not make sense to consider it closed\n    if (polyline.length > 3) {\n      const lastToFirstDist = math.point.distanceToPointSquared(\n        polyline[0],\n        polyline[numPoints - 1]\n      );\n\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n    }\n\n    closed = currentClosedState;\n  }\n\n  // It must be in the opposite direction if it is a child annotation (hole)\n  let windingDirection = parentAnnotation\n    ? parentAnnotation.data.contour.windingDirection * -1\n    : targetWindingDirection;\n\n  if (windingDirection === undefined) {\n    windingDirection = currentWindingDirection;\n  } else if (windingDirection !== currentWindingDirection) {\n    polyline.reverse();\n  }\n\n  for (let i = 0; i < numPoints; i++) {\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n  }\n\n  data.contour.polyline = polylineWorldPoints;\n  data.contour.closed = closed;\n  data.contour.windingDirection = windingDirection;\n\n  invalidateAnnotation(annotation);\n}\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { Enums, utilities } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\nconst SUPPORTED_REGION_DATA_TYPES = [\n  1, // Tissue\n];\n\nconst SUPPORTED_LENGTH_VARIANT = [\n  '3,3', // x: cm  &  y:cm\n];\n\nconst SUPPORTED_PROBE_VARIANT = [\n  '4,3', // x: seconds  &  y : cm\n];\n\nconst UNIT_MAPPING = {\n  3: 'cm',\n  4: 'seconds',\n};\n\nconst EPS = 1e-3;\n\n/**\n * Extracts the length units and the type of calibration for those units\n * into the response.  The length units will typically be either mm or px\n * while the calibration type can be any of a number of different calibration types.\n *\n * Volumetric images have no calibration type, so are just the raw mm.\n *\n * TODO: Handle region calibration\n *\n * @param handles - used to detect if the spacing information is different\n *   between various points (eg angled ERMF or US Region).\n *   Currently unused, but needed for correct US Region handling\n * @param image - to extract the calibration from\n *        image.calibration - calibration value to extract units form\n * @returns String containing the units and type of calibration\n */\nconst getCalibratedLengthUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  // Anachronistic - moving to using calibration consistently, but not completed yet\n  const units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return units;\n  }\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return PIXEL_UNITS;\n  }\n  if (calibration.sequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\nconst SQUARE = '\\xb2';\n/**\n *  Extracts the area units, including the squared sign plus calibration type.\n */\nconst getCalibratedAreaUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  const units = (hasPixelSpacing ? 'mm' : PIXEL_UNITS) + SQUARE;\n  if (!calibration || !calibration.type) {\n    return units;\n  }\n  if (calibration.sequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\n/**\n * Gets the scale divisor for converting from internal spacing to\n * image spacing for calibrated images.\n */\nconst getCalibratedScale = (image, handles = []) => {\n  if (image.calibration?.sequenceOfUltrasoundRegions) {\n    // image.spacing / image.us.space\n  } else if (image.calibration?.scale) {\n    return image.calibration.scale;\n  } else {\n    return 1;\n  }\n};\n\n/**\n * Extracts the calibrated length units, area units, and the scale\n * for converting from internal spacing to image spacing.\n *\n * @param handles - to detect if spacing information is different between points\n * @param image - to extract the calibration from\n * @returns Object containing the units, area units, and scale\n */\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n  const [imageIndex1, imageIndex2] = handles;\n  const { calibration, hasPixelSpacing } = image;\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  const areaUnits = units + SQUARE;\n  let scale = 1;\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, areaUnits, scale };\n  }\n\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\n      (region) =>\n        imageIndex1[0] >= region.regionLocationMinX0 &&\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\n        imageIndex1[1] >= region.regionLocationMinY0 &&\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\n        imageIndex2[0] >= region.regionLocationMinX0 &&\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\n        imageIndex2[1] >= region.regionLocationMinY0 &&\n        imageIndex2[1] <= region.regionLocationMaxY1\n    );\n\n    // If we are not in a region at all we should show the underlying calibration\n    // which might be the mm spacing for the image\n    if (!regions?.length) {\n      return { units, areaUnits, scale };\n    }\n\n    // if we are in a region then it is the question of whether we support it\n    // or not. If we do not support it we should show px\n\n    regions = regions.filter(\n      (region) =>\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n        SUPPORTED_LENGTH_VARIANT.includes(\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n        )\n    );\n\n    if (!regions.length) {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n\n    // Todo: expand on this logic\n    const region = regions[0];\n\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\n\n    // if we are in a supported region then we should check if the\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\n    // then we should show px again, but if they are the same then we should\n    // show the units\n    const isSamePhysicalDelta = utilities.isEqual(\n      physicalDeltaX,\n      physicalDeltaY,\n      EPS\n    );\n\n    if (isSamePhysicalDelta) {\n      scale = 1 / (physicalDeltaX * physicalDeltaY * 100);\n      calibrationType = 'US Region';\n      units = 'mm';\n    } else {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n  } else if (calibration.scale) {\n    scale = calibration.scale;\n  }\n\n  // everything except REGION/Uncalibratted\n  const types = [\n    CalibrationTypes.ERMF,\n    CalibrationTypes.USER,\n    CalibrationTypes.ERROR,\n    CalibrationTypes.PROJECTION,\n  ];\n\n  if (types.includes(calibration?.type)) {\n    calibrationType = calibration.type;\n  }\n\n  return {\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\n    scale,\n  };\n};\n\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n  const [imageIndex] = handles;\n  const { calibration } = image;\n  let units = ['raw'];\n  let values = [null];\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, values };\n    // Todo: add support for other scenarios\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    // for Probe tool\n    const supportedRegionsMetadata =\n      calibration.sequenceOfUltrasoundRegions.filter(\n        (region) =>\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n          SUPPORTED_PROBE_VARIANT.includes(\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n          )\n      );\n\n    if (!supportedRegionsMetadata?.length) {\n      return { units, values };\n    }\n\n    const region = supportedRegionsMetadata.find(\n      (region) =>\n        imageIndex[0] >= region.regionLocationMinX0 &&\n        imageIndex[0] <= region.regionLocationMaxX1 &&\n        imageIndex[1] >= region.regionLocationMinY0 &&\n        imageIndex[1] <= region.regionLocationMaxY1\n    );\n\n    if (!region) {\n      return { units, values };\n    }\n\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\n    // are not defined, then we can assume 0 for them\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n    const { physicalDeltaX, physicalDeltaY } = region;\n\n    const yValue =\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n      physicalDeltaY;\n\n    const xValue =\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n      physicalDeltaX;\n\n    calibrationType = 'US Region';\n    values = [xValue, yValue];\n    units = [\n      UNIT_MAPPING[region.physicalUnitsXDirection],\n      UNIT_MAPPING[region.physicalUnitsYDirection],\n    ];\n  }\n\n  return {\n    units,\n    values,\n    calibrationType,\n  };\n};\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport default getCalibratedLengthUnits;\n\nexport {\n  getCalibratedAreaUnits,\n  getCalibratedLengthUnits,\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedScale,\n  getCalibratedAspect,\n  getCalibratedProbeUnitsAndValue,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nfunction getSphereBoundsInfo(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  if (!viewport) {\n    throw new Error(\n      'viewport is required in order to calculate the sphere bounds'\n    );\n  }\n\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\n    _computeBoundsIJKWithCamera(\n      imageData,\n      viewport,\n      circlePoints,\n      centerWorld,\n      radiusWorld\n    );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n    topLeftWorld: topLeftWorld as Types.Point3,\n    bottomRightWorld: bottomRightWorld as Types.Point3,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // In order to correctly come up with the boundsIJK, we need to consider\n  // all the points IJK to get the bounds, since the viewport might have\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\n  // world, are the ones that will define the bounds in IJK\n  const topLeftIJK = transformWorldToIndex(\n    imageData,\n    topLeftWorld as Types.Point3\n  );\n  const bottomRightIJK = transformWorldToIndex(\n    imageData,\n    bottomRightWorld as Types.Point3\n  );\n\n  const pointsIJK = circlePoints.map((p) =>\n    transformWorldToIndex(imageData, p)\n  );\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\n    dimensions\n  );\n\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\n\nexport { getSphereBoundsInfo };\n","import type { Annotation } from '../types';\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\n\n/**\n * Finds a matching viewport in terms of the orientation of the annotation data\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - to find a viewport that it could display in\n * @returns The viewport to display in\n */\nexport default function getViewportForAnnotation(annotation: Annotation) {\n  const viewports = getViewportsForAnnotation(annotation);\n\n  return viewports.length ? viewports[0] : undefined;\n}\n","import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Annotation } from '../types';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds a all matching viewports in terms of the orientation of the annotation data\n * and the frame of reference. This doesn't mean the annotation IS being displayed\n * on these viewports, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - Annotation to find the viewports that it could display in\n * @returns All viewports to display in\n */\nexport default function getViewportsForAnnotation(annotation: Annotation) {\n  const { metadata } = annotation;\n\n  return getEnabledElements()\n    .filter((enabledElement) => {\n      if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\n        const viewport = enabledElement.viewport;\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        return (\n          isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\n          (!metadata.viewUp || isEqual(viewUp, metadata.viewUp))\n        );\n      }\n      return;\n    })\n    .map((enabledElement) => enabledElement.viewport);\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * Triggers annotation rendering for the specified tool group IDs.\n *\n * @param toolGroupIds - An array of tool group IDs.\n */\nexport function triggerAnnotationRenderForToolGroupIds(\n  toolGroupIds: string[]\n): void {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\n      return;\n    }\n\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n      if (!renderingEngine) {\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(viewportId);\n      triggerAnnotationRender(viewport.element);\n    });\n  });\n}\n\nexport default triggerAnnotationRenderForToolGroupIds;\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nfunction getToolStateByViewportId(\n  viewportId: string\n): CINETypes.ToolData | undefined {\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState, getToolStateByViewportId };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  if (!playClipOptions) {\n    playClipOptions = {};\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, {\n      stopDynamicCine: !isDynamicCinePlaying,\n      viewportId: viewport.id,\n    });\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!playClipData.loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, {\n        stopDynamicCine: !isDynamicCinePlaying,\n        viewportId: viewport.id,\n      });\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\n  _stopClip(element, {\n    stopDynamicCine: true,\n    ...options,\n  });\n}\n\nfunction _stopClip(\n  element: HTMLDivElement,\n  options = { stopDynamicCine: true, viewportId: undefined }\n) {\n  const { stopDynamicCine, viewportId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  let toolState;\n  if (!enabledElement) {\n    if (viewportId) {\n      toolState = getToolStateByViewportId(viewportId);\n    } else {\n      return;\n    }\n  } else {\n    const { viewport } = enabledElement;\n    toolState = getToolState(viewport.element);\n  }\n\n  if (toolState) {\n    _stopClipWithData(toolState);\n  }\n\n  if (\n    stopDynamicCine &&\n    enabledElement?.viewport instanceof BaseVolumeViewport\n  ) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","import smoothAnnotation from './smoothAnnotation';\n\nexport default {\n  smoothAnnotation,\n};\n\nexport { smoothAnnotation };\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport { roundNumber } from '../../utilities';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.data.length) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return [dataInTime, ijkCoords];\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n\n  const dimensions = segmentationVolume.dimensions;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([\n        i % dimensions[0],\n        Math.floor((i / dimensions[0]) % dimensions[1]),\n        Math.floor(i / (dimensions[0] * dimensions[1])),\n      ]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return [values, ijkCoords];\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK,\n  }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return [values, ijkCoords];\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points - array of number, each point defined by three consecutive numbers\n * @param idx - index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx): Types.Point3 {\n  const idx3 = idx * 3;\n  if (idx3 < points.length) {\n    return vec3.fromValues(\n      points[idx3],\n      points[idx3 + 1],\n      points[idx3 + 2]\n    ) as Types.Point3;\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n    this.showAndAutoHideTicks();\n  };\n\n  private _viewportColormapModifiedCallback = (\n    evt: Types.EventTypes.ColormapModifiedEvent\n  ) => {\n    const { viewportId, colormap, volumeId  } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.activeColormapName = colormap.name;\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.COLORMAP_MODIFIED,\n      this._viewportColormapModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { utilities } from '@cornerstonejs/core';\n\nimport {\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n} from './getAnnotationNearPoint';\n\n// Lodash/common JS functionality\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\n\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport scroll from './scroll';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\nimport getViewportForAnnotation from './getViewportForAnnotation';\n\n// name spaces\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\n\nconst roundNumber = utilities.roundNumber;\n\n// Events\nimport { triggerEvent } from '@cornerstonejs/core';\n\nexport {\n  math,\n  planar,\n  viewportFilters,\n  drawing,\n  debounce,\n  dynamicVolume,\n  throttle,\n  orientation,\n  isObject,\n  touch,\n  triggerEvent,\n  calibrateImageSpacing,\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n  segmentation,\n  contours,\n  triggerAnnotationRenderForViewportIds,\n  triggerAnnotationRenderForToolGroupIds,\n  triggerAnnotationRender,\n  pointInShapeCallback,\n  getSphereBoundsInfo,\n  getAnnotationNearPoint,\n  getViewportForAnnotation,\n  getAnnotationNearPointOnEnabledElement,\n  jumpToSlice,\n  pointInSurroundingSphereCallback,\n  viewport,\n  cine,\n  clip,\n  boundingBox,\n  rectangleROITool,\n  planarFreehandROITool,\n  stackPrefetch,\n  stackContextPrefetch,\n  scroll,\n  roundNumber,\n  pointToString,\n  polyDataUtils,\n  voi,\n  annotationFrameRange,\n  contourSegmentation,\n};\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import { NamedStatistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  /**\n   * Gets the statistics as both an array of values, as well as the named values.\n   */\n  static getStatistics: () => NamedStatistics;\n}\n\nexport default Calculator;\n","import { NamedStatistics, Statistics } from '../../../types';\nimport Calculator from './Calculator';\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static sum = [0];\n  private static sumSquares = [0];\n  private static squaredDiffSum = [0];\n  private static count = 0;\n\n  /**\n   * This callback is used when we verify if the point is in the annotion drawn so we can get every point\n   * in the shape to calculate the statistics\n   * @param value of the point in the shape of the annotation\n   */\n  static statsCallback = ({ value: newValue }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.squaredDiffSum.push(this.squaredDiffSum[0], this.squaredDiffSum[0]);\n    }\n\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    this.count += 1;\n\n    this.max.forEach(\n      (it, idx) => (this.max[idx] = Math.max(it, newArray[idx]))\n    );\n    this.sum.map((it, idx) => (this.sum[idx] += newArray[idx]));\n    this.sumSquares.map(\n      (it, idx) => (this.sumSquares[idx] += newArray[idx] ** 2)\n    );\n    this.squaredDiffSum.map(\n      (it, idx) =>\n        (this.squaredDiffSum[idx] += Math.pow(\n          newArray[idx] - this.sum[idx] / this.count,\n          2\n        ))\n    );\n  };\n\n  /**\n   * Basic function that calculates statictics for a given array of points.\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * stdDevWithSumSquare : standard deviation of the array using sum²\n   * array : An array of hte above values, in order.\n   */\n\n  static getStatistics = (): NamedStatistics => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.squaredDiffSum.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n      Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    );\n\n    const named: NamedStatistics = {\n      max: {\n        name: 'max',\n        label: 'Max Pixel',\n        value: singleArrayAsNumber(this.max),\n        unit: null,\n      },\n      mean: {\n        name: 'mean',\n        label: 'Mean Pixel',\n        value: singleArrayAsNumber(mean),\n        unit: null,\n      },\n      stdDev: {\n        name: 'stdDev',\n        label: 'Standard Deviation',\n        value: singleArrayAsNumber(stdDev),\n        unit: null,\n      },\n      stdDevWithSumSquare: {\n        name: 'stdDevWithSumSquare',\n        value: singleArrayAsNumber(stdDevWithSumSquare),\n        unit: null,\n      },\n      count: {\n        name: 'count',\n        label: 'Pixel Count',\n        value: this.count,\n        unit: null,\n      },\n      array: [],\n    };\n    named.array.push(\n      named.max,\n      named.mean,\n      named.stdDev,\n      named.stdDevWithSumSquare,\n      named.count\n    );\n\n    this.max = [-Infinity];\n    this.sum = [0];\n    this.sumSquares = [0];\n    this.squaredDiffSum = [0];\n    this.count = 0;\n\n    return named;\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import type { Types } from '@cornerstonejs/core';\ninterface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n  /**\n   * If you call the pointInEllipse.precalculateInverts first, then you\n   * can call precalculated directly instead of having the extra time for\n   * the if conditions.\n   */\n  precalculated?: (pointLPS: Types.Point3) => boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  if (!inverts.precalculated) {\n    precalculatePointInEllipse(ellipse, inverts);\n  }\n  return inverts.precalculated(pointLPS);\n}\n\n/**\n * This will perform some precalculations to make things faster.\n * Ideally, use the 'precalculated' function inside inverts to call the\n * test function.  This minimizes re-reading of variables and only needs the\n * LPS passed each time.\n * That is:\n *\n * ```\n *    const inverts = precalculatePointInEllipse(ellipse);\n *    if( inverts.precalculated(pointLPS) ) ...\n * ```\n */\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\n  const { xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n  const { center } = ellipse;\n  const [centerL, centerP, centerS] = center;\n\n  inverts.precalculated = (pointLPS) => {\n    // Calculate the sum of normalized squared distances\n    const dx = pointLPS[0] - centerL;\n    let inside = dx * dx * invXRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dy = pointLPS[1] - centerP;\n    inside += dy * dy * invYRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dz = pointLPS[2] - centerS;\n    inside += dz * dz * invZRadiusSq;\n\n    // Check if the point is inside the ellipse\n    return inside <= 1;\n  };\n\n  return inverts;\n};\n\nexport { precalculatePointInEllipse };\n","import type { Types } from '@cornerstonejs/core';\n\nexport type CanvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: CanvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Check if two axis-aligned bounding boxes intersect\n * @param aabb1 - First AABB\n * @param aabb2 - Second AABB\n * @returns True if they intersect or false otherwise\n */\nexport default function intersectAABB(\n  aabb1: Types.AABB2,\n  aabb2: Types.AABB2\n): boolean {\n  return (\n    aabb1.minX <= aabb2.maxX &&\n    aabb1.maxX >= aabb2.minX &&\n    aabb1.minY <= aabb2.maxY &&\n    aabb1.maxY >= aabb2.minY\n  );\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart equal to the lineEnd which means the closest point\n  // is any of these two points\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nconst ORIENTATION_TOLERANCE = 1e-2;\n\n/**\n * Test if a point is on a line segment\n * @param lineStart - Line segment start point\n * @param lineEnd - Line segment end point\n * @param point - Point to test\n * @returns True if the point lies on the line segment or false otherwise\n */\nexport default function isPointOnLineSegment(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): boolean {\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\n\n  // No Math.min/max call for better performance when testing thousands of points\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n\n  // Checks if the point lies inside the AABB\n  const aabbContainsPoint =\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\n\n  if (!aabbContainsPoint) {\n    return false;\n  }\n\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\n  const orientation =\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\n\n  // The orientation must be zero for points that lies on the same line\n  return absOrientation <= ORIENTATION_TOLERANCE;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dz = z2 - z1;\n\n  // Time to square 10M numbers:\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\n  return dx * dx + dy * dy + dz * dz;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import { glMatrix } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport * as math from '..';\n\n/**\n * A polyline is considered closed if the start and end points are at the same position\n *\n * @param polyline - Polyline points (2D)\n * @returns True if the polyline is already closed or false otherwise\n */\nexport default function isClosed(polyline: Types.Point2[]): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n\n  const firstPoint = polyline[0];\n  const lastPoint = polyline[numPolylinePoints - 1];\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\n    firstPoint,\n    lastPoint\n  );\n\n  return glMatrix.equals(0, distFirstToLastPoints);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport isClosed from './isClosed';\n\n/**\n * Checks if a 2D point is inside the polyline.\n *\n * A point is inside a curve/polygon if the number of intersections between the horizontal\n * ray emanating from the given point and to the right and the line segments is odd.\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n *\n * Note that a point on the polyline is considered inside.\n *\n * @param polyline - Polyline points (2D)\n * @param point - 2D Point\n * @returns True if the point is inside the polyline or false otherwise\n */\nexport default function containsPoint(\n  polyline: Types.Point2[],\n  point: Types.Point2,\n  options: {\n    closed?: boolean;\n    holes?: Types.Point2[][];\n  } = {\n    closed: undefined,\n  }\n): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n  let numIntersections = 0;\n\n  const { closed, holes } = options;\n\n  if (holes?.length) {\n    for (const hole of holes) {\n      if (containsPoint(hole, point)) {\n        return false;\n      }\n    }\n  }\n\n  // Test intersection against [end, start] line segment if it should be closed\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n\n  for (let i = 0; i <= maxSegmentIndex; i++) {\n    const p1 = polyline[i];\n\n    // Calculating the next point index without using % (mod) operator like in\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    // Calculating min/max without using Math.min/max to make it ~3% faster\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n\n    const mayIntersectLineSegment =\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n\n    if (mayIntersectLineSegment) {\n      const isVerticalLine = p1[0] === p2[0];\n      let intersects = isVerticalLine;\n\n      if (!intersects) {\n        const xIntersection =\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n        intersects = point[0] <= xIntersection;\n      }\n\n      numIntersections += intersects ? 1 : 0;\n    }\n  }\n\n  return !!(numIntersections % 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\n\n/**\n * Checks if a polyline contains a set of points.\n *\n * @param polyline - Polyline points (2D)\n * @param points - 2D points to verify\n * @returns True if all points are inside the polyline or false otherwise\n */\nexport default function containsPoints(\n  polyline: Types.Point2[],\n  points: Types.Point2[]\n): boolean {\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n    if (!containsPoint(polyline, points[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function getArea(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the area with signal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\n *\n * This functions has a runtime very close to `getArea` and it is recommended to\n * be called only if you need the area signal (eg: calculate polygon normal). If\n * you do not need the area signal you should always call `getArea`.\n *\n *\n * @param polyline - Polyline points (2D)\n * @returns Area of the polyline (with signal)\n */\nexport default function getSignedArea(polyline: Types.Point2[]): number {\n  if (polyline.length < 3) {\n    return 0;\n  }\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n  let area = 0;\n\n  // Takes three points (reference point and two other points from each line\n  // segment) and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\n    // for 2D vectors.\n    area += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  area *= 0.5;\n\n  return area;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the winding direction (CW or CCW) of a polyline\n * @param polyline - Polyline (2D)\n * @returns 1 for CW or -1 for CCW polylines\n */\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\n  const signedArea = getSignedArea(polyline);\n\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\n  return signedArea >= 0 ? 1 : -1;\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = vec3.create();\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n\n  // Takes three points, reference point and two other points from each line\n  // segment, and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const aZ = p1[2] - refPoint[2];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n    const bZ = p2[2] - refPoint[2];\n\n    // Cross product without calling vec3.cross() for better performance\n    vecArea[0] += aY * bZ - aZ * bY;\n    vecArea[1] += aZ * bX - aX * bZ;\n    vecArea[2] += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  vec3.scale(vecArea, vecArea, 0.5);\n\n  // The magnitude of the vector is the area of the polyline\n  return <Types.Point3>vecArea;\n}\n\n/**\n * Calculate the normal of a 3D planar polyline\n * @param polyline - Planar polyline in 3D space\n * @returns Normal of the 3D planar polyline\n */\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = _getAreaVector(polyline);\n\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\n}\n","import { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the normal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\n *\n * @param polyline - Planar polyline in 2D space\n * @returns Normal of the 2D planar polyline\n */\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\n  const area = getSignedArea(polyline);\n\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\n  // is CW or CCW polyline\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\n// namespace.\n//\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\n// need to investigate why it is 6x slower than this one when thousands of\n// intersections are calculated. Also that one may return [NaN, NaN] for\n// collinear points.\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\n * orientation algorithm.\n *\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n *\n * @param p1 - Start point of line segment 1\n * @param q1 - End point of line segment 1\n * @param p2 - Start point of line segment 2\n * @param q2 - End point of line segment 2\n * @returns True if the line segments intersect or false otherwise\n */\nexport default function areLineSegmentsIntersecting(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  // Line 1 AABB\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n\n  // Line 2 AABB\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n\n  // If AABBs do not intersect it is impossible for the lines to intersect.\n  // Checking AABB before doing any math makes it run ~12% faster.\n  if (\n    line1MinX > line2MaxX ||\n    line1MaxX < line2MinX ||\n    line1MinY > line2MaxY ||\n    line1MaxY < line2MinY\n  ) {\n    return false;\n  }\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  // Take the cross product between vectors PQ and QR\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Get all intersections between a polyline and a line segment.\n * @param polyline - Polyline points\n * @param p1 - Start point of line segment\n * @param q1 - End point of line segment\n * @param closed - Test the intersection against the line segment that connects\n * the last to the first point when set to true\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\n */\nexport default function getLineSegmentIntersectionsIndexes(\n  polyline: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const intersections: Types.Point2[] = [];\n  const numPoints = polyline.length;\n  const maxI = numPoints - (closed ? 1 : 2);\n\n  for (let i = 0; i <= maxI; i++) {\n    const p2 = polyline[i];\n    // Do not use % operator for better performance\n    const j = i === numPoints - 1 ? 0 : i + 1;\n    const q2 = polyline[j];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([i, j]);\n    }\n  }\n\n  return intersections;\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\n\n// Tested with +1M random overlapping line segments and any tolerance below this\n// one may return invalid results.\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\n\n/**\n * It returns the intersection between two lines (not line segments) or a midpoint\n * when the line segments overlap. This function calculates the intersection between\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\n * has already been called first which guarantees.\n *\n * @param p1 - Line segment 1 start\n * @param q1 - Line segment 1 end\n * @param p2 - Line segment 2 start\n * @param q2 - Line segment 21 end\n * @returns The intersection between two lines or a midpoint when they overlap\n */\nexport default function getLinesIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n) {\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\n\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n    // No Math.min/max calls for better performance.\n    const line1AABB = [\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\n    ];\n\n    // No Math.min/max calls for better performance.\n    const line2AABB = [\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\n    ];\n\n    const aabbIntersects =\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\n\n    if (!aabbIntersects) {\n      return;\n    }\n\n    // Three tests are enough to know if the lines overlap\n    const overlap =\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\n      mathLine.isPointOnLineSegment(p2, q2, p1);\n\n    if (!overlap) {\n      return;\n    }\n\n    // min/max seems to be inverted but that is correct because it is looking\n    // for the intersection range. No Math.min/max calls for better performance.\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n    const midX = (minX + maxX) * 0.5;\n    const midY = (minY + maxY) * 0.5;\n\n    return [midX, midY];\n  }\n\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * diffQ1P1[0];\n  const resultY = p1[1] + a * diffQ1P1[1];\n\n  return [resultX, resultY];\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\n\nenum PolylinePointType {\n  Vertex,\n  Intersection,\n}\n\n// Position of the point related to the intersection region\nenum PolylinePointPosition {\n  Outside = -1,\n  Edge = 0,\n  Inside = 1,\n}\n\n// Direction from last point to the intersection point to know if it is entering\n// or exiting the intersection region\nenum PolylinePointDirection {\n  Exiting = -1,\n  Unknown = 0,\n  Entering = 1,\n}\n\ntype PolylinePoint = {\n  type: PolylinePointType;\n  coordinates: Types.Point2;\n  position?: PolylinePointPosition;\n  visited: boolean;\n  next: PolylinePoint;\n};\n\ntype PolylineIntersectionPoint = PolylinePoint & {\n  direction: PolylinePointDirection;\n  cloned?: boolean;\n};\n\n/**\n * Ensure all polyline point objects are pointing to the next object in case\n * it is still not point to anyone.\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\n */\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\n  // Make sure all nodes point to a valid node\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const currentPoint = polylinePoints[i];\n\n    if (!currentPoint.next) {\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n    }\n  }\n}\n\n/**\n * Creates one linked list per polyline that contains all vertices and intersections\n * found while walking along the edges.\n *\n * @param targetPolyline - Target polyline\n * @param sourcePolyline - Source polyline\n * @returns Two linked lists with all vertices and intersections.\n */\nfunction getSourceAndTargetPointsList(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetPolylinePoints: PolylinePoint[] = [];\n  const sourcePolylinePoints: PolylinePoint[] = [];\n  const sourceIntersectionsCache = new Map<\n    number,\n    PolylineIntersectionPoint[]\n  >();\n\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n\n  let intersectionPointDirection = isFirstPointInside\n    ? PolylinePointDirection.Exiting\n    : PolylinePointDirection.Entering;\n\n  // Store all vertices and intersection for target contour\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\n    const p1 = targetPolyline[i];\n    const pointInside = containsPoint(sourcePolyline, p1);\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      position: pointInside\n        ? PolylinePointPosition.Inside\n        : PolylinePointPosition.Outside,\n      visited: false,\n      next: null,\n    };\n\n    targetPolylinePoints.push(vertexPoint);\n\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\n      sourcePolyline,\n      p1,\n      q1\n    ).map((intersectedLineSegment) => {\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\n\n      // lineSegment.intersectLine returns the midpoint of the four points\n      // when the lines are parallel or co-incident.  Otherwise it will return\n      // an extension of the line.\n      const intersectionCoordinate = getLinesIntersection(\n        p1,\n        q1,\n        p2,\n        q2\n      ) as Types.Point2;\n\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\n        p1,\n        intersectionCoordinate\n      );\n\n      return {\n        sourceLineSegmentId,\n        coordinate: intersectionCoordinate,\n        targetStartPointDistSquared,\n      };\n    });\n\n    intersectionsInfo.sort(\n      (left, right) =>\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\n    );\n\n    intersectionsInfo.forEach((intersectionInfo) => {\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\n        intersectionInfo;\n\n      // Intersection point to be added to the target polyline list\n      const targetEdgePoint: PolylineIntersectionPoint = {\n        type: PolylinePointType.Intersection,\n        coordinates: intersectionCoordinate,\n        position: PolylinePointPosition.Edge,\n        direction: intersectionPointDirection,\n        visited: false,\n        next: null,\n      };\n\n      // Intersection point to be added to the source polyline list.\n      // At this point there is no way to know if the point is entering or\n      // exiting the intersection region but that is not going to be used\n      // hence it is set to \"unknown\".\n      const sourceEdgePoint: PolylineIntersectionPoint = {\n        ...targetEdgePoint,\n        direction: PolylinePointDirection.Unknown,\n        cloned: true,\n      };\n\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\n        targetEdgePoint.next = sourceEdgePoint;\n      } else {\n        sourceEdgePoint.next = targetEdgePoint;\n      }\n\n      let sourceIntersectionPoints =\n        sourceIntersectionsCache.get(sourceLineSegmentId);\n\n      if (!sourceIntersectionPoints) {\n        sourceIntersectionPoints = [];\n        sourceIntersectionsCache.set(\n          sourceLineSegmentId,\n          sourceIntersectionPoints\n        );\n      }\n\n      targetPolylinePoints.push(targetEdgePoint);\n      sourceIntersectionPoints.push(sourceEdgePoint);\n\n      // Switches from \"exiting\" to \"entering\" and vice-versa\n      intersectionPointDirection *= -1;\n    });\n  }\n\n  // Store all vertices and intersections for source contour\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n    const lineSegmentId: number = i;\n    const p1 = sourcePolyline[i];\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      visited: false,\n      next: null,\n    };\n\n    sourcePolylinePoints.push(vertexPoint);\n\n    const sourceIntersectionPoints =\n      sourceIntersectionsCache.get(lineSegmentId);\n\n    if (!sourceIntersectionPoints?.length) {\n      continue;\n    }\n\n    // Calculate the distance between each intersection point to the start point\n    // of the line segment, sort them by distance and return a sorted array that\n    // contains all intersection points.\n    sourceIntersectionPoints\n      .map((intersectionPoint) => ({\n        intersectionPoint,\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\n          p1,\n          intersectionPoint.coordinates\n        ),\n      }))\n      .sort(\n        (left, right) =>\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\n      )\n      .map(({ intersectionPoint }) => intersectionPoint)\n      .forEach((intersectionPoint) =>\n        sourcePolylinePoints.push(intersectionPoint)\n      );\n  }\n\n  ensuresNextPointers(targetPolylinePoints);\n  ensuresNextPointers(sourcePolylinePoints);\n\n  return { targetPolylinePoints, sourcePolylinePoints };\n}\n\n/**\n * Get the next unvisited polyline points that is outside the intersection region.\n * @param polylinePoints - All polyline points (vertices and intersections)\n * @returns Any unvisited point that is outside the intersection region if it\n * exists or `undefined` otherwise\n */\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const point = polylinePoints[i];\n\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\n      return point;\n    }\n  }\n}\n\n/**\n * Merge two planar polylines (2D)\n */\nfunction mergePolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\n  // be reversed if theirs orientation are not the same\n  if (!glMatrix.equals(1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  const startPoint: PolylinePoint =\n    getUnvisitedOutsidePoint(targetPolylinePoints);\n\n  // Source polyline contains target polyline\n  if (!startPoint) {\n    return targetPolyline.slice();\n  }\n\n  const mergedPolyline = [startPoint.coordinates];\n  let currentPoint = startPoint.next;\n\n  while (currentPoint !== startPoint) {\n    if (\n      currentPoint.type === PolylinePointType.Intersection &&\n      (<PolylineIntersectionPoint>currentPoint).cloned\n    ) {\n      currentPoint = currentPoint.next;\n      continue;\n    }\n\n    mergedPolyline.push(currentPoint.coordinates);\n    currentPoint = currentPoint.next;\n  }\n\n  return mergedPolyline;\n}\n\n/**\n * Subtract two planar polylines (2D)\n */\nfunction subtractPolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n): Types.Point2[][] {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\n  // subtracted and one of them needs to be reversed if theirs orientation are\n  // the same\n  if (!glMatrix.equals(-1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  let startPoint: PolylinePoint = null;\n  const subtractedPolylines = [];\n\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\n    const subtractedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n\n    startPoint.visited = true;\n\n    while (currentPoint !== startPoint) {\n      currentPoint.visited = true;\n\n      if (\n        currentPoint.type === PolylinePointType.Intersection &&\n        (<PolylineIntersectionPoint>currentPoint).cloned\n      ) {\n        currentPoint = currentPoint.next;\n        continue;\n      }\n\n      subtractedPolyline.push(currentPoint.coordinates);\n      currentPoint = currentPoint.next;\n    }\n\n    subtractedPolylines.push(subtractedPolyline);\n  }\n\n  return subtractedPolylines;\n}\n\nexport { mergePolylines, subtractPolylines };\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n *\n * @param points - Polyline points\n * @param p1 - First point of the line segment that is being tested\n * @param q1 - Second point of the line segment that is being tested\n * @param closed - Test the intersection with the line segment that connects\n *   the last and first points of the polyline\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\n */\nexport default function getFirstLineSegmentIntersectionIndexes(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\n\n/**\n * Check if two polylines intersect comparing line segment by line segment.\n * @param sourcePolyline - Source polyline\n * @param targetPolyline - Target polyline\n * @returns True if the polylines intersect or false otherwise\n */\nexport default function intersectPolyline(\n  sourcePolyline: Types.Point2[],\n  targetPolyline: Types.Point2[]\n): boolean {\n  // Naive way to detect intersection between polylines in O(n^2).\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\n  // algorithm that uses r-tree may make it run faster\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n    const sourceP1 = sourcePolyline[i];\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n    const sourceP2 = sourcePolyline[sourceP2Index];\n\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\n      targetPolyline,\n      sourceP1,\n      sourceP2\n    );\n\n    if (intersectionPointIndexes?.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\nconst DEFAULT_EPSILON = 0.1;\n\n/**\n * Ramer–Douglas–Peucker algorithm implementation to decimate a polyline\n * to a similar polyline with fewer points\n *\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\n * https://karthaus.nl/rdp/\n *\n * @param polyline - Polyline to decimate\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\n * should or shouldn't be added the decimated polyline version. In each\n * iteration the polyline is split into two polylines and the distance of each\n * point from those new polylines are checked against the line that connects\n * the first and last points.\n * @returns Decimated polyline\n */\nexport default function decimate(\n  polyline: Types.Point2[],\n  epsilon = DEFAULT_EPSILON\n) {\n  const numPoints = polyline.length;\n\n  // The polyline must have at least a start and end points\n  if (numPoints < 3) {\n    return polyline;\n  }\n\n  const epsilonSquared = epsilon * epsilon;\n  const partitionQueue = [[0, numPoints - 1]];\n\n  // Used a boolean array to set each point that will be in the decimated polyline\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\n  // to add all points to a new array.\n  const polylinePointFlags = new Array(numPoints).fill(false);\n\n  // Start and end points are always added to the decimated polyline\n  let numDecimatedPoints = 2;\n\n  // Add start and end points to the decimated polyline\n  polylinePointFlags[0] = true;\n  polylinePointFlags[numPoints - 1] = true;\n\n  // Iterative approach using a queue instead of recursion to reduce the number\n  // of function calls (performance)\n  while (partitionQueue.length) {\n    const [startIndex, endIndex] = partitionQueue.pop();\n\n    // Return if there is no point between the start and end points\n    if (endIndex - startIndex === 1) {\n      continue;\n    }\n\n    const startPoint = polyline[startIndex];\n    const endPoint = polyline[endIndex];\n    let maxDistSquared = -Infinity;\n    let maxDistIndex = -1;\n\n    // Search for the furthest point\n    for (let i = startIndex + 1; i < endIndex; i++) {\n      const currentPoint = polyline[i];\n      const distSquared = mathLine.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        currentPoint\n      );\n\n      if (distSquared > maxDistSquared) {\n        maxDistSquared = distSquared;\n        maxDistIndex = i;\n      }\n    }\n\n    // Do not add any of the points because the fursthest one is very close to\n    // the line based on the epsilon value\n    if (maxDistSquared < epsilonSquared) {\n      continue;\n    }\n\n    // Update the flag for the furthest point because it will be added to the\n    // decimated polyline\n    polylinePointFlags[maxDistIndex] = true;\n    numDecimatedPoints++;\n\n    // Partition the points into two parts using maxDistIndex as the pivot point\n    // and process both sides\n    partitionQueue.push([maxDistIndex, endIndex]);\n    partitionQueue.push([startIndex, maxDistIndex]);\n  }\n\n  // A pre-allocated array is 3-4x faster then multiple push() calls\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\n\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n    if (polylinePointFlags[srcIndex]) {\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\n    }\n  }\n\n  return decimatedPolyline;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\n\n/**\n * Returns all intersections points between a line segment and a polyline\n */\nexport default function getLineSegmentIntersectionsCoordinates(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n\n  return result;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n * @param points - Polyline points\n * @param p1 - Start point of the line segment\n * @param q1 - End point of the line segment\n * @param closed - Test the intersection against the line that connects the first to the last when closed\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\n */\nexport default function getClosestLineSegmentIntersection(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialQ2Index;\n  let p2Index;\n\n  if (closed) {\n    p2Index = points.length - 1;\n    initialQ2Index = 0;\n  } else {\n    p2Index = 0;\n    initialQ2Index = 1;\n  }\n\n  const intersections = [];\n\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n    const p2 = points[p2Index];\n    const q2 = points[q2Index];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([p2Index, q2Index]);\n    }\n\n    p2Index = q2Index;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (!canvasPoints.length) {\n    canvasPoints.push(newCanvasPoint);\n    console.log('>>>>> !canvasPoints. :: RETURN');\n    return 1;\n  }\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst epsilon = 1e-6;\n\n/**\n * Projects a polyline from 3D to 2D by reducing one dimension.\n *\n * @param polyline - The polyline to be projected.\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\n * @throws Error if a shared dimension index cannot be found for the polyline.\n */\nexport function projectTo2D(polyline: Types.Point3[]) {\n  // We need to reduce one dimension to 2D, so basically\n  // we need to find the dimension index that is shared by all points\n  // Use the first three points, two is enough but three is more robust\n  let sharedDimensionIndex;\n\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n\n  for (let i = 0; i < 3; i++) {\n    if (\n      testPoints.every(\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\n      )\n    ) {\n      sharedDimensionIndex = i;\n      break;\n    }\n  }\n\n  if (sharedDimensionIndex === undefined) {\n    throw new Error(\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\n    );\n  }\n\n  // convert polyline list and point to 2D\n  const points2D = [] as Types.Point2[];\n\n  const firstDim = (sharedDimensionIndex + 1) % 3;\n  const secondDim = (sharedDimensionIndex + 2) % 3;\n\n  for (let i = 0; i < polyline.length; i++) {\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n  }\n\n  return {\n    sharedDimensionIndex,\n    projectedPolyline: points2D,\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\n\n/**\n * Determines whether a 3D point is inside a polyline in 3D space.\n *\n * The algorithm works by reducing the polyline and point to 2D space, and then\n * using the 2D algorithm to determine whether the point is inside the polyline.\n *\n * @param point - The 3D point to test.\n * @param polyline - The polyline represented as an array of 3D points.\n * @param options.holesPolyline - An array of polylines representing each hole, so it\n * is an array of arrays of 3D points.\n * @returns A boolean indicating whether the point is inside the polyline.\n * @throws An error if a shared dimension index cannot be found for the polyline points.\n */\nexport function isPointInsidePolyline3D(\n  point: Types.Point3,\n  polyline: Types.Point3[],\n  options: { holes?: Types.Point3[][] } = {}\n) {\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n\n  const { holes } = options;\n  const projectedHoles = [] as Types.Point2[][];\n\n  if (holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const hole2D = [] as Types.Point2[];\n\n      for (let j = 0; j < hole.length; j++) {\n        hole2D.push([\n          hole[j][(sharedDimensionIndex + 1) % 3],\n          hole[j][(sharedDimensionIndex + 2) % 3],\n        ]);\n      }\n\n      projectedHoles.push(hole2D);\n    }\n  }\n\n  const point2D = [\n    point[(sharedDimensionIndex + 1) % 3],\n    point[(sharedDimensionIndex + 2) % 3],\n  ] as Types.Point2;\n\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n  // Square of the radius\n  radius2?: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * This is safe to call for point in circle as long as you don't call it with\n * anything off-plane - that is, a circle is a degenerate sphere that is\n * intersected with the primary plane.\n *\n * @param sphere - Sphere object with center and radius and radius squared\n *     as radius2 if you are calling this a huge number of times.\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n  const radius2 = sphere.radius2 || radius * radius;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius2\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Find the closest point to the target point\n *\n * @param sourcePoints - The potential source points.\n * @param targetPoint - The target point, used to find the closest source.\n * @returns The closest point in the array of point sources\n */\nexport default function findClosestPoint(\n  sourcePoints: Array<Types.Point2>,\n  targetPoint: Types.Point2\n): Types.Point2 {\n  let minPoint = [0, 0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n\n  sourcePoints.forEach(function (sourcePoint) {\n    const distance = _distanceBetween(targetPoint, sourcePoint);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPoint = [...sourcePoint];\n    }\n  });\n\n  return minPoint as Types.Point2;\n}\n\n/**\n *\n * @private\n * @param p1\n * @param p2\n */\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n};\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3 | number[];\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n  const { numComps } = imageData as any;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    numComps ||\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({\n            value,\n            index,\n            pointIJK,\n            pointLPS: currentPos.slice(),\n          });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShapeIJK(\n      rectangleCornersIJK,\n      dimensions\n    );\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nconst { isEqual } = csUtils;\n\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\n\nconst axisList = [iAxis, jAxis, kAxis];\n\n/**\n * Determines whether a given rectangle in a 3D space (defined by its corner\n * points in IJK coordinates) is aligned with the IJK axes.\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\n */\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n  const rectangleVec1 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[1]\n  );\n\n  const rectangleVec2 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[2]\n  );\n\n  // Calculate the angles with IJK axes for both vectors\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\n    (angle) =>\n      isEqual(angle, 0) ||\n      isEqual(angle, 90) ||\n      isEqual(angle, 180) ||\n      isEqual(angle, 270)\n  );\n\n  return isAligned;\n}\n\n// Function to calculate angle with IJK axes\nfunction calculateAnglesWithAxes(vec, axes) {\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\n\nexport { isAxisAlignedRectangle };\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { type: viewportType } = viewport;\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else if (viewport instanceof VideoViewport) {\n    viewport.scroll(delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\n    {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail\n    );\n  } else {\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\n      VolumeScrollEventDetail\n    );\n  }\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  AnnotationCompletedEventType,\n  AnnotationModifiedEventType,\n  AnnotationRemovedEventType,\n} from '../../../types/EventTypes';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport type {\n  InterpolationViewportData,\n  AcceptInterpolationSelector,\n} from '../../../types/InterpolationTypes';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\n\nconst { uuidv4 } = csUtils;\n\nconst ChangeTypesForInterpolation = [\n  ChangeTypes.HandlesUpdated,\n  ChangeTypes.InterpolationUpdated,\n];\n\nexport default class InterpolationManager {\n  static toolNames = [];\n\n  static addTool(toolName: string) {\n    if (!this.toolNames.includes(toolName)) {\n      this.toolNames.push(toolName);\n    }\n  }\n\n  /**\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\n   * Can provide a selector to choose which ones to accept.\n   *\n   * Rules for which items to select:\n   * 1. Only choose annotations having the same segment index and segmentationID\n   * 2. Exclude all contours having the same interpolation UID as any other contours\n   *    on the same slice.\n   * 3. Exclude autogenerated annotations\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\n   *    creating a new interpolation)\n   * 5. Find the set of interpolationUID's remaining\n   *    a. If the set is of size 0, assign a new interpolationUID\n   *    b. If the set is of size 1, assign that interpolationUID\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\n   *       for every remaining annotation, find the one whose center\n   *       point is closest to the center point of the new annotation.\n   *       Choose that interpolationUID\n   *\n   * To allow creating new interpolated groups, the idea is to just use a new\n   * segment index, then have an operation to update the segment index of an\n   * interpolation set.  That way the user can easily draw/see the difference,\n   * and then merge them as required.\n   * However, the base rules allow creating two contours on a single image to\n   * create a separate set.\n   */\n  static acceptAutoGenerated(\n    annotationGroupSelector: AnnotationGroupSelector,\n    selector: AcceptInterpolationSelector = {}\n  ) {\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\n      const annotations = annotationState.getAnnotations(\n        toolName,\n        annotationGroupSelector\n      ) as InterpolationROIAnnotation[];\n      if (!annotations?.length) {\n        continue;\n      }\n      for (const annotation of annotations) {\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\n        if (interpolationUID) {\n          annotation.interpolationCompleted = true;\n        }\n        if (!autoGenerated) {\n          continue;\n        }\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n          continue;\n        }\n        if (\n          sliceIndex !== undefined &&\n          metadata &&\n          sliceIndex !== metadata.sliceIndex\n        ) {\n          continue;\n        }\n        if (\n          segmentationId &&\n          segmentationId !== data.segmentation.segmentationId\n        ) {\n          continue;\n        }\n        addContourSegmentationAnnotation(annotation);\n        annotation.autoGenerated = false;\n      }\n    }\n  }\n\n  /**\n   * When an annotation is completed, if the configuration includes interpolation,\n   * then find matching interpolations and interpolation between this segmentation\n   * and the other segmentations of the same type.\n   */\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      !this.toolNames.includes(toolName) &&\n      !this.toolNames.includes(originalToolName)\n    ) {\n      return;\n    }\n\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn('Unable to find viewport for', annotation);\n      return;\n    }\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    const hasInterpolationUID = !!annotation.interpolationUID;\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\n    annotation.autoGenerated = false;\n    if (hasInterpolationUID) {\n      // This has already been configured with matching details, so just run\n      //  the interpolation again.\n      deleteRelatedAnnotations(viewportData);\n      interpolate(viewportData);\n      return;\n    }\n    const filterData = [\n      {\n        key: 'segmentIndex',\n        value: annotation.data.segmentation.segmentIndex,\n        parentKey: (annotation) => annotation.data.segmentation,\n      },\n      {\n        key: 'viewPlaneNormal',\n        value: annotation.metadata.viewPlaneNormal,\n        parentKey: (annotation) => annotation.metadata,\n      },\n      {\n        key: 'viewUp',\n        value: annotation.metadata.viewUp,\n        parentKey: (annotation) => annotation.metadata,\n      },\n    ];\n    let interpolationAnnotations = getInterpolationDataCollection(\n      viewportData,\n      filterData\n    );\n    // Skip other type of annotation interpolationUID's that are co-located\n    const { sliceIndex } = annotation.metadata;\n    const skipUIDs = new Set<string>();\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\n      if (\n        interpolationAnnotation.interpolationCompleted ||\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\n      ) {\n        const { interpolationUID } = interpolationAnnotation;\n        skipUIDs.add(interpolationUID);\n      }\n    });\n    interpolationAnnotations = interpolationAnnotations.filter(\n      (interpolationAnnotation) =>\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\n    );\n\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\n    annotation.interpolationUID =\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\n    viewportData.interpolationUID = annotation.interpolationUID;\n    interpolate(viewportData);\n  };\n\n  /**\n   * This method gets called when an annotation changes.  It will then trigger\n   * related already interpolated annotations to be updated with the modified data.\n   */\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      (!this.toolNames.includes(toolName) &&\n        !this.toolNames.includes(originalToolName)) ||\n      !ChangeTypesForInterpolation.includes(changeType)\n    ) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn(\n        'Unable to find matching viewport for annotation interpolation',\n        annotation\n      );\n      return;\n    }\n    if (annotation.autoGenerated) {\n      // Dont fire the annotation changed events here, as that leads to recursion,\n      // although this is in fact completing the event, so trigger the segmentation add\n      addContourSegmentationAnnotation(annotation);\n      annotation.autoGenerated = false;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n    };\n    interpolate(viewportData);\n  };\n\n  /**\n   * Delete interpolated annotations when their endpoints are deleted.\n   */\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName } = annotation.metadata;\n\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n\n    if (!viewport) {\n      console.warn(\n        \"No viewport, can't delete interpolated results\",\n        annotation\n      );\n      return;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\n    annotation.autoGenerated = false;\n    deleteRelatedAnnotations(viewportData);\n  };\n}\n\nfunction getSliceData(viewport): Types.ImageSliceData {\n  const sliceData: Types.ImageSliceData = {\n    numberOfSlices: viewport.getNumberOfSlices(),\n    imageIndex: viewport.getCurrentImageIdIndex(),\n  };\n  return sliceData;\n}\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\n * map to work on keys.\n *\n * @param getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param options.equals - An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns Flood fill results\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = new Set();\n  const bounds = new Map();\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  /**\n   * Indicates if the key has been visited.\n   * @param key is a 2 or 3 element vector with values -32768...32767\n   */\n  function visited(key) {\n    const [x, y, z = 0] = key;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    return visits.has(iKey);\n  }\n\n  function markAsVisited(key) {\n    const [x, y, z = 0] = key;\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    visits.add(iKey);\n  }\n\n  function member(getArgs) {\n    const node = get(getArgs);\n\n    return equals ? equals(node, startNode) : node === startNode;\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    const [x, y, z = 0] = prevArgs;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    bounds.set(iKey, prevArgs);\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  // This is a significant performance hit - should be done as a wrapper\n  // only when needed.\n  // function safely(f, args) {\n  //   try {\n  //     return f(...args);\n  //   } catch (error) {\n  //     return;\n  //   }\n  // }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = Array.from(bounds.values());\n    array.reverse();\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import { Types, cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { SegmentationRepresentations } from '../../enums';\n\nconst segmentIndicesCache = new Map<\n  string,\n  { indices: number[]; isDirty: boolean }\n>();\n\n/**\n * Sets the segmentation as dirty, indicating that it needs to be updated.\n * @param segmentationId - The ID of the segmentation.\n */\nexport const setSegmentationDirty = (segmentationId: string) => {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached) {\n    cached.isDirty = true;\n  }\n};\n\nexport const setSegmentationClean = (segmentationId: string) => {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached) {\n    cached.isDirty = false;\n  }\n};\n\nfunction getCachedSegmentIndices(segmentationId) {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached && !cached.isDirty) {\n    return cached.indices;\n  }\n  return null;\n}\n\n/**\n * Retrieves the unique segment indices from a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns An array of unique segment indices.\n * @throws If no geometryIds are found for the segmentationId.\n */\nfunction getUniqueSegmentIndices(segmentationId) {\n  // Attempt to fetch from cache first\n  const cachedResult = getCachedSegmentIndices(segmentationId);\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n  if (!segmentation) {\n    throw new Error(\n      `No segmentation found for segmentationId ${segmentationId}`\n    );\n  }\n\n  let indices;\n  switch (segmentation.type) {\n    case SegmentationRepresentations.Labelmap:\n      indices = handleLabelmapSegmentation(segmentation, segmentationId);\n      break;\n    case SegmentationRepresentations.Contour:\n      indices = handleContourSegmentation(segmentation);\n      break;\n    case SegmentationRepresentations.Surface:\n      indices = handleSurfaceSegmentation(segmentation);\n      break;\n    default:\n      throw new Error(`Unsupported segmentation type: ${segmentation.type}`);\n  }\n\n  // Update cache\n  segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\n  return indices;\n}\n\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\n  const labelmapData =\n    segmentation.representationData[SegmentationRepresentations.Labelmap];\n  const keySet = new Set();\n\n  if (isVolumeSegmentation(labelmapData)) {\n    addVolumeSegmentIndices(keySet, segmentationId);\n  } else {\n    addImageSegmentIndices(keySet, labelmapData.imageIdReferenceMap);\n  }\n\n  return Array.from(keySet)\n    .map(Number)\n    .sort((a, b) => a - b);\n}\n\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\n  const volume = cache.getVolume(segmentationId);\n  const scalarData = volume.getScalarData();\n  scalarData.forEach((segmentIndex) => {\n    if (segmentIndex !== 0) {\n      keySet.add(segmentIndex);\n    }\n  });\n}\n\nfunction addImageSegmentIndices(keySet, imageIdReferenceMap) {\n  imageIdReferenceMap.forEach((segmentationImageId) => {\n    const image = cache.getImage(segmentationImageId);\n    const scalarData = image.getPixelData();\n    scalarData.forEach((segmentIndex) => {\n      if (segmentIndex !== 0) {\n        keySet.add(segmentIndex);\n      }\n    });\n  });\n}\n\nfunction handleContourSegmentation(segmentation) {\n  const { annotationUIDsMap, geometryIds } =\n    segmentation.representationData.CONTOUR || {};\n  if (!geometryIds) {\n    throw new Error(\n      `No geometryIds found for segmentationId ${segmentation.segmentationId}`\n    );\n  }\n\n  const indices = new Set([...annotationUIDsMap.keys()]);\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n    indices.add((geometry.data as Types.IContourSet).getSegmentIndex());\n  });\n\n  return Array.from(indices).sort((a, b) => a - b);\n}\n\nfunction handleSurfaceSegmentation(segmentation) {\n  const geometryIds =\n    segmentation.representationData.SURFACE?.geometryIds ?? [];\n  return Array.from(geometryIds.keys())\n    .map(Number)\n    .sort((a, b) => a - b);\n}\n\nexport { getUniqueSegmentIndices };\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n  segmentIndex?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    if (insert) {\n      scalarData[index] = options.segmentIndex || 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n  segmentIndex?: number; // segment index to threshold\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  outputSegmentationVolume.modified();\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId: string;\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata: Types.Metadata;\n    dimensions: Types.Point3;\n    spacing: Types.Point3;\n    origin: Types.Point3;\n    direction: Types.Mat3;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2,\n  otherArgs: Record<string, unknown> = { isDynamic: false }\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const configuration = {\n    ...otherArgs,\n    ...(threshold !== undefined && { threshold }),\n  };\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD = {\n      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,\n      ...configuration,\n    };\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD\n    .threshold;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","/**\n * Creates a map that associates each imageId with a set of segmentation imageIds.\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\n * are the same length and same order.\n *\n * @param imageIdsArray - An array of imageIds.\n * @param segmentationImageIds - An array of segmentation imageIds.\n * @returns A map that maps each imageId to a set of segmentation imageIds.\n */\nfunction createImageIdReferenceMap(\n  imageIdsArray: string[],\n  segmentationImageIds: string[]\n): Map<string, string> {\n  const imageIdReferenceMap = new Map<string, string>(\n    imageIdsArray.map((imageId, index) => {\n      return [imageId, segmentationImageIds[index]];\n    })\n  );\n\n  return imageIdReferenceMap;\n}\n\nexport { createImageIdReferenceMap };\n","import type { Types } from '@cornerstonejs/core';\nimport { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Determines if there is a point between point1 and point2 which is not\n * contained in the segmentation\n */\nexport default function isLineInSegment(\n  point1: Types.Point3,\n  point2: Types.Point3,\n  isInSegment\n) {\n  const ijk1 = isInSegment.toIJK(point1);\n  const ijk2 = isInSegment.toIJK(point2);\n  const testPoint = vec3.create();\n  const { testIJK } = isInSegment;\n  const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n\n  // Test once for index value between the two points, so the max of the\n  // difference in IJK values\n  const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n  if (testSize < 2) {\n    // No need to test when there are only two points\n    return true;\n  }\n  const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n\n  for (let i = 1; i < testSize; i++) {\n    vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n    if (!testIJK(testPoint)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Creates a function that tests to see if the provided line segment, specified\n * in LPS space (as endpoints) is contained in the segment\n */\nfunction createIsInSegment(\n  segVolumeId: string,\n  segmentIndex: number,\n  containedSegmentIndices?: Set<number>\n) {\n  // Get segmentation volume\n  const vol = cache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const width = vol.dimensions[0];\n  const pixelsPerSlice = width * vol.dimensions[1];\n\n  return {\n    /**\n     * Find the center point between point1 and point2, convert it to IJK space\n     * and test if the value at that location is in the segment\n     */\n    testCenter: (point1, point2) => {\n      const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n      const ijk = vol.imageData.worldToIndex(point as vec3).map(Math.round);\n      const [i, j, k] = ijk;\n      const index = i + j * width + k * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n\n    toIJK: (point) => vol.imageData.worldToIndex(point as vec3),\n\n    testIJK: (ijk) => {\n      const [i, j, k] = ijk;\n      const index =\n        Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n  };\n}\n\nexport { createIsInSegment, isLineInSegment };\n","import { vec3 } from 'gl-matrix';\n\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nimport type { BidirectionalData } from './createBidirectionalToolData';\n\nconst EPSILON = 1e-2;\n\n/**\n * Search in the contours for the given segment to find the largest bidirectional\n * that will fit entirely within the slice contours inside the contours object.\n * Assumptions/implementation details:\n *\n *   1. The major and minor bidirectional lines must not cross the contour\n *   2. The center point for both major and minor bidirectional lines must be\n *      within the segment, or the contained segment index.\n *   3. The major/minor axis must be orthogonal\n *\n * Note this does NOT test that the major/minor axis intersect.  Normally they will, but\n * it isn't a hard requirement.\n *\n * The way that islands within the contours are handled is to allow the island to be\n * coloured with something that is contained - that way both open and closed islands\n * can be handled correctly for finding the bidirectional  (an open island is a section\n * inside the segment that is open to the outside - this can happen at bone endpoints or when\n * one region flows into another)\n */\nexport default function findLargestBidirectional(\n  contours,\n  segVolumeId: string,\n  segment\n) {\n  const { sliceContours } = contours;\n  const { segmentIndex, containedSegmentIndices } = segment;\n  let maxBidirectional;\n  const isInSegment = createIsInSegment(\n    segVolumeId,\n    segmentIndex,\n    containedSegmentIndices\n  );\n  for (const sliceContour of sliceContours) {\n    const bidirectional = createBidirectionalForSlice(\n      sliceContour,\n      isInSegment,\n      maxBidirectional\n    );\n    if (!bidirectional) {\n      continue;\n    }\n    maxBidirectional = bidirectional;\n  }\n  if (maxBidirectional) {\n    Object.assign(maxBidirectional, segment);\n  }\n  return maxBidirectional;\n}\n\n/**\n * This function creates a bidirectional data object for the given slice and\n * slice contour, only when the major distance is larger than currentMax, or\n * equal to current max and the minor is larger than currentMax's minor.\n * It does this by looking at every pair of distances in sliceCountour to find\n * those larger than the currentMax, and then finds the minor distance for those\n * major distances.\n *\n */\nfunction createBidirectionalForSlice(\n  sliceContour,\n  isInSegment,\n  currentMax = { maxMajor: 0, maxMinor: 0 }\n) {\n  const { points } = sliceContour.polyData;\n  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n  let maxMajor = currentMaxMajor * currentMaxMajor;\n  let maxMinor = currentMaxMinor * currentMaxMinor;\n  let maxMajorPoints;\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 < maxMajor) {\n        continue;\n      }\n      if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n        // Consider adding to the set of points rather than continuing here\n        // so that all minor axis can be tested\n        continue;\n      }\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        // If the line intersects the segment boundary, then skip it\n        continue;\n      }\n      maxMajor = distance2 - EPSILON;\n      maxMajorPoints = [index1, index2];\n      maxMinor = 0;\n    }\n  }\n  if (!maxMajorPoints) {\n    return;\n  }\n\n  maxMajor = Math.sqrt(maxMajor + EPSILON);\n  const handle0 = points[maxMajorPoints[0]];\n  const handle1 = points[maxMajorPoints[1]];\n  const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n  vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n\n  let maxMinorPoints;\n\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 <= maxMinor) {\n        continue;\n      }\n      const delta = vec3.sub(vec3.create(), point1, point2);\n\n      const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n      if (dot > EPSILON) {\n        continue;\n      }\n\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        continue;\n      }\n      maxMinor = distance2;\n      maxMinorPoints = [index1, index2];\n    }\n  }\n\n  if (!maxMinorPoints) {\n    // Didn't find a larger minor distance\n    return;\n  }\n  maxMinor = Math.sqrt(maxMinor);\n  const handle2 = points[maxMinorPoints[0]];\n  const handle3 = points[maxMinorPoints[1]];\n\n  const bidirectional = {\n    majorAxis: [handle0, handle1],\n    minorAxis: [handle2, handle3],\n    maxMajor,\n    maxMinor,\n    ...sliceContour,\n  } as BidirectionalData;\n  return bidirectional;\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport findLargestBidirectional from './findLargestBidirectional';\n\nconst { Labelmap } = SegmentationRepresentations;\n\n/**\n * Generates a contour object over the segment, and then uses the contouring to\n * find the largest bidirectional object that can be applied within the acquisition\n * plane that is within the segment index, or the contained segment indices.\n *\n * @param segmentation.segments - a list of segments to apply the contour to.\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\n * @param segmentation.segments.label - the label for the segment\n * @param segmentation.segments.color - the color to use for the segment label\n */\nexport default function contourAndFindLargestBidirectional(segmentation) {\n  const contours = generateContourSetsFromLabelmap({\n    segmentations: segmentation,\n  });\n\n  if (!contours?.length || !contours[0].sliceContours.length) {\n    return;\n  }\n\n  const {\n    representationData,\n    segments = [\n      null,\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ],\n  } = segmentation;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  const segmentIndex = segments.findIndex((it) => !!it);\n  if (segmentIndex === -1) {\n    return;\n  }\n  segments[segmentIndex].segmentIndex = segmentIndex;\n  return findLargestBidirectional(\n    contours[0],\n    segVolumeId,\n    segments[segmentIndex]\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types/AnnotationTypes';\n\nexport type BidirectionalData = {\n  majorAxis: [Types.Point3, Types.Point3];\n  minorAxis: [Types.Point3, Types.Point3];\n  maxMajor: number;\n  maxMinor: number;\n  segmentIndex: number;\n  label?: string;\n  color?: string | number[];\n  referencedImageId: string;\n  sliceIndex: number;\n};\n\n/**\n * Creates data suitable for the BidirectionalTool from the basic bidirectional\n * data object.\n */\nexport default function createBidirectionalToolData(\n  bidirectionalData: BidirectionalData,\n  viewport\n): Annotation {\n  const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n  const [major0, major1] = majorAxis;\n  const [minor0, minor1] = minorAxis;\n\n  const points = [major0, major1, minor0, minor1];\n  const bidirectionalToolData = {\n    highlighted: true,\n    invalidated: true,\n    metadata: {\n      toolName: 'Bidirectional',\n      // Get a view reference for the slice this applies to, not the currently\n      // displayed slice.  This will fill in the remaining data for that slice\n      ...viewport.getViewReference({ sliceIndex }),\n    },\n    data: {\n      handles: {\n        points,\n        textBox: {\n          hasMoved: false,\n          worldPosition: [0, 0, 0] as Types.Point3,\n          worldBoundingBox: {\n            topLeft: [0, 0, 0] as Types.Point3,\n            topRight: [0, 0, 0] as Types.Point3,\n            bottomLeft: [0, 0, 0] as Types.Point3,\n            bottomRight: [0, 0, 0] as Types.Point3,\n          },\n        },\n        activeHandleIndex: null,\n      },\n      label,\n      cachedStats: {},\n    },\n    isLocked: false,\n    isVisible: true,\n  };\n  return bidirectionalToolData;\n}\n","import { getEnabledElement, type Types } from '@cornerstonejs/core';\n\nimport type { Annotation } from '../../types/AnnotationTypes';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport {\n  state as annotationState,\n  config as annotationConfig,\n} from '../../stateManagement/annotation';\nimport { jumpToSlice } from '../viewport';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\n\nexport type Segment = {\n  segmentationId: string;\n  segmentIndex: number;\n  label: string;\n\n  style?: any;\n  containedSegmentIndices?: (number) => boolean;\n};\n\nexport type SegmentContourActionConfiguration = {\n  getSegment?: (\n    enabledElement: Types.IEnabledElement,\n    configuration: SegmentContourActionConfiguration\n  ) => Segment;\n\n  /**\n   * Optional map for data about each segment\n   */\n  segmentationId?: string;\n  segmentIndex?: number;\n  segmentData?: Map<number, Segment>;\n  toolGroupId?: string;\n};\n\nexport default function segmentContourAction(\n  element: HTMLDivElement,\n  configuration\n) {\n  const { data: configurationData } = configuration;\n  const enabledElement = getEnabledElement(element);\n  const segment = (configurationData.getSegment || defaultGetSegment)(\n    enabledElement,\n    configurationData\n  );\n  if (!segment) {\n    return;\n  }\n  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n  const segmentationsList = segmentation.state.getSegmentations();\n  const { segmentIndex, segmentationId } = segment;\n  const bidirectionals = annotationState.getAnnotations(\n    this.toolName || BidirectionalTool.toolName,\n    FrameOfReferenceUID\n  );\n  let hasExistingActiveSegment = false;\n  const existingLargestBidirectionals = bidirectionals.filter(\n    (existingBidirectionalItem) => {\n      const { segment } = existingBidirectionalItem.data;\n      if (!segment) {\n        return;\n      }\n      if (\n        segment.segmentationId === segmentationId &&\n        segment.segmentIndex === segmentIndex\n      ) {\n        hasExistingActiveSegment = true;\n        existingBidirectionalItem.data.segment = segment;\n      }\n      return !!segment;\n    }\n  );\n  if (!hasExistingActiveSegment) {\n    // Just create a dummy annotation object containing just enough information\n    // to create a real one.\n    existingLargestBidirectionals.push({\n      data: { segment },\n    } as unknown as Annotation);\n  }\n\n  let newBidirectional;\n  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {\n    const segments = [];\n    const { segment: updateSegment } = existingLargestBidirectional.data;\n    const { segmentIndex, segmentationId } = updateSegment;\n    segments[segmentIndex] = updateSegment;\n    annotationState.removeAnnotation(\n      existingLargestBidirectional.annotationUID\n    );\n    const bidirectionalData = contourAndFindLargestBidirectional({\n      ...segmentationsList.find(\n        (segmentation) => segmentation.segmentationId === segmentationId\n      ),\n      segments,\n    });\n\n    if (!bidirectionalData) {\n      return;\n    }\n    const bidirectionalToolData = createBidirectionalToolData(\n      bidirectionalData,\n      enabledElement.viewport\n    );\n    bidirectionalToolData.annotationUID =\n      existingLargestBidirectional.annotationUID;\n    bidirectionalToolData.data.segment = updateSegment;\n\n    const annotationUID = annotationState.addAnnotation(\n      bidirectionalToolData,\n      FrameOfReferenceUID\n    );\n\n    if (\n      updateSegment.segmentIndex === segment.segmentIndex &&\n      updateSegment.segmentationId === segment.segmentationId\n    ) {\n      newBidirectional = bidirectionalData;\n      const { style } = segment;\n      if (style) {\n        annotationConfig.style.setAnnotationStyles(annotationUID, style);\n      }\n    }\n  });\n\n  if (newBidirectional) {\n    const { sliceIndex } = newBidirectional;\n    const imageIds = enabledElement.viewport.getImageIds();\n\n    // TODO - figure out why this is reversed\n    jumpToSlice(element, {\n      imageIndex: imageIds.length - 1 - sliceIndex,\n    });\n    enabledElement.viewport.render();\n  } else {\n    console.warn('No bidirectional found');\n  }\n\n  return newBidirectional;\n}\n\nexport function defaultGetSegment(\n  enabledElement: Types.IEnabledElement,\n  configuration: SegmentContourActionConfiguration\n): Segment {\n  const segmentationsList = segmentation.state.getSegmentations();\n  if (!segmentationsList.length) {\n    return;\n  }\n  const segmentationId =\n    configuration.segmentationId || segmentationsList[0].segmentationId;\n  const segmentIndex =\n    configuration.segmentIndex ??\n    segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);\n  if (!segmentIndex) {\n    return;\n  }\n  const segmentData = configuration.segmentData?.get(segmentIndex);\n  return {\n    label: `Segment ${segmentIndex}`,\n    segmentIndex,\n    segmentationId,\n    ...segmentData,\n  };\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Invalidates the brush cursor for a specific tool group.\n * This function triggers the update of the brush being rendered.\n * It also triggers an annotation render for any viewports on the tool group.\n *\n * @param toolGroupId - The ID of the tool group.\n */\nexport function invalidateBrushCursor(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\n\ntype Options = {\n  representationType?: SegmentationRepresentations;\n  viewport?: Types.IViewport;\n};\n\n/**\n * Get the segment at the specified world point in the viewport.\n * @param segmentationId - The ID of the segmentation to get the segment for.\n * @param worldPoint - The world point to get the segment for.\n *\n * @returns The index of the segment at the world point, or undefined if not found.\n */\nexport function getSegmentAtWorldPoint(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  options = {} as Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const representationData = segmentation.representationData;\n\n  // if representationType is not provided, we will use the first representation\n  const desiredRepresentation =\n    options?.representationType ?? Object.keys(representationData)[0];\n\n  if (!desiredRepresentation) {\n    throw new Error(\n      `Segmentation ${segmentationId} does not have any representations`\n    );\n  }\n\n  switch (desiredRepresentation) {\n    case SegmentationRepresentations.Labelmap:\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\n    case SegmentationRepresentations.Contour:\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\n    default:\n      return;\n  }\n}\n\n/**\n * Retrieves the segment index at a given world point for a labelmap.\n *\n * @param labelmapData - The labelmap segmentation data.\n * @param worldPoint - The world point to retrieve the segment at.\n *\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForLabelmap(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number | undefined {\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const segmentIndex =\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n\n    return segmentIndex;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  return segmentIndex;\n}\n\n/**\n * Retrieves the segment index at a given world point for contour segmentation.\n *\n * @param segmentation - The segmentation data.\n * @param worldPoint - The world point to check.\n * @param options - The options for segmentation.\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForContour(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number {\n  const contourData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  for (const segmentIndex of segmentIndices) {\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n\n    if (!annotationsSet) {\n      continue;\n    }\n\n    for (const annotationUID of annotationsSet) {\n      const annotation = getAnnotation(\n        annotationUID\n      ) as ContourSegmentationAnnotation;\n\n      if (!annotation) {\n        continue;\n      }\n\n      const { polyline } = annotation.data.contour;\n\n      if (\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\n      ) {\n        continue;\n      }\n\n      // This function checks whether we are inside the contour. It does not\n      // check if we are exactly on the contour, which is highly unlikely given\n      // the canvas pixel resolution of 1 decimal place we have by design.\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\n        return Number(segmentIndex);\n      }\n    }\n  }\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\n\ntype Options = {\n  viewport?: Types.IViewport;\n  searchRadius?: number;\n};\n\n/**\n * Retrieves the segment index at the border of a labelmap in a segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param worldPoint - The world coordinates of the point.\n * @param options - Additional options.\n * @param options.viewport - The viewport to use.\n * @param options.searchRadius - The search radius to use.\n * @returns The segment index at the labelmap border, or undefined if not found.\n */\nexport function getSegmentAtLabelmapBorder(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  { viewport, searchRadius }: Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const imageData = segmentationVolume.imageData;\n\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\n\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\n\n    const onEdge = isSegmentOnEdgeCanvas(\n      canvasPoint as Types.Point2,\n      segmentIndex,\n      viewport,\n      imageData,\n      searchRadius\n    );\n\n    return onEdge ? segmentIndex : undefined;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  const onEdge = isSegmentOnEdgeIJK(\n    indexIJK as Types.Point3,\n    dimensions,\n    voxelManager,\n    segmentIndex\n  );\n\n  return onEdge ? segmentIndex : undefined;\n}\n\n/**\n * Checks if a segment is on the edge of a labelmap.\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\n * @param segmentIndex - The index of the segment to check.\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\n * @returns A boolean indicating whether the segment is on the edge.\n */\nfunction isSegmentOnEdge(\n  getNeighborIndex: (\n    deltaI: number,\n    deltaJ: number,\n    deltaK: number\n  ) => number | undefined,\n  segmentIndex: number,\n  searchRadius = 1 // Default search radius\n): boolean {\n  const neighborRange = Array.from(\n    { length: 2 * searchRadius + 1 },\n    (_, i) => i - searchRadius\n  );\n\n  for (const deltaI of neighborRange) {\n    for (const deltaJ of neighborRange) {\n      for (const deltaK of neighborRange) {\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n          continue; // Skipping the central point\n        }\n\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n          return true; // On the edge\n        }\n      }\n    }\n  }\n\n  return false; // No edge neighbors found\n}\n\nfunction isSegmentOnEdgeIJK(\n  indexIJK: Types.Point3,\n  dimensions: Types.Point3,\n  voxelManager: any,\n  segmentIndex: number,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\n    const neighborIJK = [\n      indexIJK[0] + deltaI,\n      indexIJK[1] + deltaJ,\n      indexIJK[2] + deltaK,\n    ];\n\n    return voxelManager.getAtIJK(...neighborIJK);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n\nfunction isSegmentOnEdgeCanvas(\n  canvasPoint: Types.Point2,\n  segmentIndex: number,\n  viewport: Types.IViewport,\n  imageData: any,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\n    return imageData.getScalarValueFromWorld(worldPoint);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\n\n/**\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\n */\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n  const segmentation = getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\n      (annotationUID) => getAnnotation(annotationUID).highlighted\n    );\n\n    if (highlightedAnnotationUID) {\n      return segmentIndex;\n    }\n  }\n\n  return undefined;\n}\n","import {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../../store/ToolGroupManager';\n\nimport { SegmentationDisplayTool } from '../../tools';\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\n\n/**\n * SegmentationRenderingEngine is a class that is responsible for rendering\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\n * based on the segmentation data and their configurations. Note: This is a Singleton class\n * and should not be instantiated directly. To trigger a render for all the\n * segmentations of a tool group you can use.\n *\n * ```\n * triggerSegmentationRender(toolGroupId)\n * ```\n */\nclass SegmentationRenderingEngine {\n  private _needsRender: Set<string> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  public hasBeenDestroyed: boolean;\n\n  public removeToolGroup(toolGroupId) {\n    this._needsRender.delete(toolGroupId);\n\n    if (this._needsRender.size === 0) {\n      this._reset();\n    }\n  }\n\n  public renderToolGroupSegmentations(toolGroupId): void {\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n  }\n\n  /**\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\n    toolGroupIds: string[]\n  ) {\n    // Add the viewports to the set of flagged viewports\n    toolGroupIds.forEach((toolGroupId) => {\n      this._needsRender.add(toolGroupId);\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   *  _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedToolGroups\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  private _renderFlaggedToolGroups = () => {\n    this._throwIfDestroyed();\n\n    // for each toolGroupId insides the _needsRender set, render the segmentation\n    const toolGroupIds = Array.from(this._needsRender.values());\n\n    for (const toolGroupId of toolGroupIds) {\n      this._triggerRender(toolGroupId);\n\n      // This viewport has been rendered, we can remove it from the set\n      this._needsRender.delete(toolGroupId);\n\n      // If there is nothing left that is flagged for rendering, stop here\n      // and allow RAF to be called again\n      if (this._needsRender.size === 0) {\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        return;\n      }\n    }\n  };\n  _triggerRender(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n      return;\n    }\n\n    const { viewportsInfo } = toolGroup;\n\n    const viewports = viewportsInfo\n      .map(({ viewportId, renderingEngineId }) => {\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n\n        if (!renderingEngine) {\n          console.warn('rendering Engine has been destroyed');\n          return;\n        }\n\n        const viewport = renderingEngine.getViewport(viewportId);\n\n        if (viewport) {\n          return viewport;\n        }\n      })\n      .filter(Boolean);\n\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\n      SegmentationDisplayTool.toolName\n    ) as SegmentationDisplayTool;\n    if (!segmentationDisplayToolInstance) {\n      console.warn('No segmentation tool found inside', toolGroupId);\n      return;\n    }\n\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\n      const { element, viewportId, renderingEngineId } = evt.detail;\n\n      element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn('toolGroup has been destroyed');\n        return;\n      }\n\n      const eventDetail: SegmentationRenderedEventDetail = {\n        toolGroupId: toolGroup.id,\n        viewportId,\n      };\n\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n        ...eventDetail,\n      });\n    }\n\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\n    // drawSvg(element, (svgDrawingHelper) => {\n    //   const handleDrawSvg = (tool) => {\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\n    //       tool.renderAnnotation({ detail: eventDetail })\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\n    //     }\n    //   }\n    //   enabledTools.forEach(handleDrawSvg)\n    // })\n\n    viewports.forEach(({ element }) => {\n      element.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n    });\n\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n  }\n\n  /**\n   *  _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n  }\n}\n\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\n\n/**\n * It triggers a render for all the segmentations of the tool group with the given Id.\n * @param toolGroupId - The Id of the tool group to render.\n */\nfunction triggerSegmentationRender(toolGroupId: string): void {\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\n\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\n    voxelCornersIJK,\n    dimensions\n  );\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import {\n  getEnabledElement,\n  triggerEvent,\n  getRenderingEngine,\n} from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * AnnotationRenderingEngine is a class that is responsible for rendering\n * annotations defined in the renderAnnotation method of annotation tools on the page.\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\n * is a Singleton class and should not be instantiated directly. To trigger\n * an annotation render for an HTML element containing a viewport you can use\n *\n * ```\n * triggerAnnotationRender(element)\n * ```\n */\nclass AnnotationRenderingEngine {\n  public hasBeenDestroyed: boolean;\n  private _needsRender: Set<HTMLDivElement> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  private _viewportElements: Map<string, HTMLDivElement>;\n\n  constructor() {\n    this._viewportElements = new Map();\n  }\n\n  /**\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\n   * just informs the annotationRenderingEngine about the viewport and\n   * does not initiate a render.\n   * @param viewportId - Viewport Unique identifier\n   * @param element - HTMLDivElement\n   */\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.set(viewportId, element);\n  }\n\n  /**\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\n   * @param viewportId - Viewport Unique identifier\n   */\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.delete(viewportId);\n\n    // delete element from needsRender if element exist\n    this._needsRender.delete(element);\n\n    // I don' think there is any disadvantage to canceling the animation frame\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\n    // new one while removing the old one\n    this._reset();\n  }\n\n  /**\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\n   * time it renders.\n   *\n   * @param element - The element to render.\n   */\n  public renderViewport(element: HTMLDivElement): void {\n    this._setViewportsToBeRenderedNextFrame([element]);\n  }\n\n  /**\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _renderFlaggedViewports = () => {\n    this._throwIfDestroyed();\n\n    const elements = Array.from(this._viewportElements.values());\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (this._needsRender.has(element)) {\n        this._triggerRender(element);\n\n        // This viewport has been rendered, we can remove it from the set\n        this._needsRender.delete(element);\n\n        // If there is nothing left that is flagged for rendering, stop here\n        // and allow RAF to be called again\n        if (this._needsRender.size === 0) {\n          break;\n        }\n      }\n    }\n\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    // Call render again which will use RAF to call this function asynchronously\n    // if there is any viewport that needs to be rendered because when\n    // `triggerRender` is called inside the render loop a listener can flag new\n    // viewports that need to be rendered and some of the viewports that were\n    // already rendered can be added back to `_needsRender`.\n    this._render();\n  };\n\n  private _setAllViewportsToBeRenderedNextFrame() {\n    const elements = [...this._viewportElements.values()];\n\n    elements.forEach((element) => {\n      this._needsRender.add(element);\n    });\n\n    this._renderFlaggedViewports();\n  }\n\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\n    const elementsEnabled = [...this._viewportElements.values()];\n\n    // Add the viewports to the set of flagged viewports\n    elements.forEach((element) => {\n      // only enabledElement need to render\n      if (elementsEnabled.indexOf(element) !== -1) {\n        this._needsRender.add(element);\n      }\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   * _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedViewports\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  _triggerRender(element) {\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      // Happens during testing, and isn't an issue as it just means there\n      // is overlap between shutdown and re-render\n      // console.warn('Element has been disabled');\n      return;\n    }\n\n    const renderingEngine = getRenderingEngine(\n      enabledElement.renderingEngineId\n    );\n    if (!renderingEngine) {\n      console.warn('rendering Engine has been destroyed');\n      return;\n    }\n\n    const enabledTools = getToolsWithModesForElement(element, [\n      Active,\n      Passive,\n      Enabled,\n    ]);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n    const eventDetail: AnnotationRenderedEventDetail = {\n      element,\n      renderingEngineId,\n      viewportId,\n    };\n\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\n    //   return annotations && annotations.length;\n    // });\n\n    drawSvg(element, (svgDrawingHelper) => {\n      let anyRendered = false;\n      const handleDrawSvg = (tool) => {\n        if (tool.renderAnnotation) {\n          const rendered = tool.renderAnnotation(\n            enabledElement,\n            svgDrawingHelper\n          );\n          anyRendered = anyRendered || rendered;\n        }\n      };\n\n      /**\n       * We should be able to filter tools that don't have annotations, but\n       * currently some of tools have renderAnnotation method BUT\n       * don't keep annotation in the state, so if we do so, the tool will not be\n       * rendered.\n       */\n      enabledTools.forEach(handleDrawSvg);\n\n      if (anyRendered) {\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n      }\n    });\n  }\n\n  /**\n   * _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    this._setAllViewportsToBeRenderedNextFrame();\n  }\n}\n\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\n\n/**\n * It triggers the rendering of the annotations for the given HTML element using\n * the `AnnotationRenderingEngine`\n * @param element - The element to render the annotation on.\n */\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\n  annotationRenderingEngine.renderViewport(element);\n}\n\nexport { annotationRenderingEngine, triggerAnnotationRender };\n\nexport default triggerAnnotationRender;\n","import type { Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\n\nexport function triggerAnnotationRenderForViewportIds(\n  renderingEngine: Types.IRenderingEngine,\n  viewportIdsToRender: string[]\n): void {\n  if (!viewportIdsToRender.length || !renderingEngine) {\n    return;\n  }\n\n  viewportIdsToRender.forEach((viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n      console.warn(`Viewport not available for ${viewportId}`);\n      return;\n    }\n    const { element } = viewport;\n    triggerAnnotationRender(element);\n  });\n}\n\nexport default triggerAnnotationRenderForViewportIds;\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1\n        ? targetIdTokens[1].split('?')[0]\n        : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n"],"names":["ELEMENT_CURSORS_MAP","Symbol","initElementCursor","element","cursor","_getElementCursors","_setElementCursor","cursors","style","MouseCursor","getDefinedCursor","getStyleProperty","resetElementCursor","hideElementCursor","map","WeakMap","Object","defineProperty","value","get","set","DEFINED_CURSORS","STANDARD_CURSORS","Set","constructor","name","fallback","this","getName","addFallbackStyleProperty","definedCursors","getDefinedCursors","mouseCursor","has","setDefinedCursor","context","symbol","Map","standardCursorNames","values","ImageMouseCursor","url","x","y","super","getUniqueInstanceName","Number","prefix","utilities","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","assign","create","registerCursor","toolName","svgCursorNames","keys","STATE","AnnotationStyleStates","Highlighted","MODE","ToolModes","Active","SVGMouseCursor","pointer","color","urn","type","getCursorURN","descriptor","getDefinedSVGCursorDescriptor","options","URL","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","prototype","hasOwnProperty","bind","replace","match","key","svgSize","Math","max","cursorName","console","log","setElementCursor","CursorNames","annotationUID","drawingElementType","nodeUID","attributes","svgNode","forEach","currentValue","getAttribute","newValue","undefined","removeAttribute","setAttribute","svgDrawingHelper","circleUID","center","radius","dataId","fill","width","lineWidth","lineDash","fillOpacity","strokeOpacity","strokeWidth","svgNodeHash","existingCircleElement","getSvgNode","cx","cy","r","stroke","setNodeTouched","newCircleElement","document","createElementNS","appendNode","ellipseUID","canvasCoordinates","existingEllipse","bottom","top","left","right","w","hypot","h","angle","atan2","PI","rx","ry","transform","svgEllipseElement","corner1","corner2","handleGroupUID","handle","uniqueIndex","handleRadius","opacity","Error","side","parseFloat","height","existingHandleElement","newHandleElement","handlePoints","i","drawLine","lineUID","start","end","isNaN","shadow","existingLine","dropShadowStyle","svgLayerElement","id","x1","y1","x2","y2","newLine","drawPolyline","polylineUID","points","length","fillColor","closePath","existingPolyLine","pointsAttribute","point","toFixed","firstPoint","newPolyLine","drawPath","pathUID","pointsArrays","Array","isArray","existingNode","numArrays","numPoints","j","d","newNode","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","querySelector","removeChild","getBBox","insertBefore","firstChild","bBox","textUID","textLines","position","padding","fontFamily","fontSize","background","textGroupBoundingBox","svgns","existingTextGroup","textElement","textSpans","from","children","textSpan","appendChild","textGroupAttributes","textGroup","noSelectStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","linkUID","annotationAnchorPoints","refPoint","boundingBox","findClosestPoint","boundingBoxPoints","halfWidth","halfHeight","_boundingBoxPoints","textBoxUID","textBoxPosition","textBox","mergedOptions","centering","canvasBoundingBox","drawRect","rectangleUID","_width","existingRect","tlhc","min","abs","svgRectElement","drawArrow","arrowUID","firstLine","cos","sin","secondLine","drawRedactionRect","ChangeTypes","Events","SegmentationRepresentations","StrategyCallbacks","Swipe","MouseBindings","KeyboardBindings","onImageRendered","evt","triggerAnnotationRender","detail","enable","addEventListener","Enums","IMAGE_RENDERED","disable","removeEventListener","MOUSE_CLICK","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_DOUBLE_CLICK","MOUSE_DRAG","MOUSE_MOVE","MOUSE_UP","MOUSE_WHEEL","KEY_DOWN","KEY_UP","Passive","Enabled","onCameraModified","getToolsWithModesForMouseEvent","tool","CAMERA_MODIFIED","onImageSpacingCalibrated","IMAGE_SPACING_CALIBRATED","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_PRESS","eventTarget","ANNOTATION_COMPLETED","InterpolationManager","handleAnnotationCompleted","ANNOTATION_MODIFIED","handleAnnotationUpdate","ANNOTATION_REMOVED","handleAnnotationDelete","DEFAULT_CONTOUR_SEG_TOOLNAME","async","contourSegmentationCompletedListener","sourceAnnotation","annotation","viewport","viewports","viewportWithToolRegistered","find","isFreehandContourSegToolRegisteredForViewport","getViewport","contourSegmentationAnnotations","sourceAnnotationUID","getAllAnnotations","filter","targetAnnotation","isReferenceViewable","metadata","getValidContourSegmentationAnnotations","sourcePolyline","convertContourPolylineToCanvasSpace","data","contour","polyline","targetAnnotationInfo","sourceAABB","math","targetPolyline","targetAABB","aabbIntersect","lineSegmentsIntersect","isContourHole","findIntersectingContour","contourHoleProcessingEnabled","createPolylineHole","PlanarFreehandContourSegmentationTool","warn","sourceStartPoint","mergePolylines","contourHolesData","getChildAnnotations","holeAnnotation","getContourHolesData","unassignedContourHolesSet","reassignedContourHolesMap","assignHoleToPolyline","parentPolyline","holeData","holes","push","delete","newPolylines","mergedPolyline","newPolyline","contourHolesDataArray","contourHoleData","clearParentAnnotation","enabledElement","getEnabledElement","handles","segmentation","removeAnnotation","startPoint","canvasToWorld","endPoint","newAnnotation","originalToolName","cachedStats","closed","spline","highlighted","invalidated","isLocked","isVisible","interpolationUID","interpolationCompleted","targetWindingDirection","Clockwise","addAnnotation","addChildAnnotation","renderingEngine","updatedTtoolNames","viewportIdsToRender","getViewportIdsWithToolToRender","triggerAnnotationRenderForViewportIds","Promise","resolve","window","requestAnimationFrame","updateViewports","combinePolylines","silent","toolGroup","renderingEngineId","errorMessage","hasTool","getToolOptions","projectedPolyline","worldToCanvas","windingDirection","holeWindingDirection","reverse","updatedToolNames","mouseDoubleClickListener","mouseDownListener","mouseMoveListener","capture","preventGhostClick","touchStartListener","passive","wheelListener","toolGroupId","triggerSegmentationRender","segmentationId","modifiedSlicesToUse","representationData","toolGroupIds","labelmapRepresentationData","segmentationVolume","cache","getVolume","volumeId","imageData","vtkOpenGLTexture","slicesToUpdate","numSlices","getDimensions","setUpdatedFrame","modified","performVolumeLabelmapUpdate","toolGroupSegmentationRepresentations","viewportsInfo","getToolGroup","getViewportsInfo","representation","viewportId","getEnabledElementByIds","VolumeViewport","actorEntry","getActor","segmentationRepresentationUID","currentImageId","getCurrentImageId","segImageData","actor","getMapper","getInputData","imageIdReferenceMap","currentSegmentationImageId","segmentationImage","getImage","performStackLabelmapUpdate","Labelmap","getToolGroupIdsWithSegmentation","getSegmentationRepresentations","triggerSegmentationRepresentationModified","perToolGroupManualTriggers","_imageChangeEventListener","eventData","getToolGroupForViewport","segmentationRepresentations","LABELMAP","labelmapData","representationList","actors","getActors","includes","uid","segmentationActor","derivedImageId","segmentationImageData","setDerivedImage","scalarArray","numberOfComponents","Uint8Array","getNumberOfPoints","getPointData","setScalars","setInputData","derivedImage","dimensions","spacing","direction","getImageDataMetadata","currentImage","imageId","origin","currentOrigin","originToUse","setOrigin","removeActors","addImages","actorUID","callback","imageActor","getPixelData","setDimensions","setSpacing","setDirection","render","BaseVolumeViewport","STACK_NEW_IMAGE","annotationCompletedListener","contourSegmentationCompleted","removed","getRenderingEngines","viewportIds","getViewports","vp","getRenderingEngine","annotationRemovedListener","removeContourSegmentationAnnotation","csToolsInitialized","init","defaultConfiguration","_removeCornerstoneEventListeners","elementEnabledEvent","ELEMENT_ENABLED","elementDisabledEvent","ELEMENT_DISABLED","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","ANNOTATION_SELECTION_CHANGE","SEGMENTATION_MODIFIED","SEGMENTATION_DATA_MODIFIED","SEGMENTATION_REPRESENTATION_MODIFIED","SEGMENTATION_REPRESENTATION_REMOVED","destroy","ToolGroupManager","annotationManager","getAnnotationManager","segmentationStateManager","getDefaultSegmentationStateManager","restoreAnnotations","resetState","cameraSyncCallback","synchronizerInstance","sourceViewport","targetViewport","cameraModifiedEvent","camera","tViewport","setCamera","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","presentationViewSyncCallback","_synchronizerInstance","_sourceEvent","presentationView","getViewPresentation","setView","createPresentationViewSynchronizer","voiSyncCallback","modifiedEvent","eventDetail","range","invertStateChanged","invert","colormap","tProperties","voiRange","syncInvertState","syncColormap","_actors","size","setProperties","StackViewport","createVOISynchronizer","VOI_MODIFIED","auxiliaryEventNames","COLORMAP_MODIFIED","zoomPanSyncCallback","getOptions","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","getSpatialRegistration","targetId","sourceId","imageSliceSyncCallback","disabled","imageId1","sourceImagePositionPatient","metaData","imagePositionPatient","targetImageIds","getImageIds","viewport1","viewport2","viewPlaneNormal","viewPlaneNormal1","getCamera","viewPlaneNormal2","dotProducts","areViewportsCoplanar","registrationMatrixMat4","getFrameOfReferenceUID","useInitialPosition","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","targetPoint","reduce","closestImageIdIndex","index","distance","Infinity","imageIndexToSet","getCurrentImageIdIndex","jumpToSlice","imageIndex","VOLUME_NEW_IMAGE","createImageSliceSynchronizer","slabThicknessSyncCallback","slabThickness","getSlabThickness","setSlabThickness","createStackImageSynchronizer","VideoRedactionTool","toolConfiguration","supportedInteractionTypes","configuration","preventHandleOutsideImage","addNewAnnotation","currentPoints","worldPos","world","isDrawing","viewUp","referencedImageId","getReferencedImageId","FrameOfReferenceUID","getToolName","activeHandleIndex","active","viewportUIDsToRender","editData","handleIndex","hasMoved","_activateDraw","preventDefault","getHandleNearImagePoint","canvasCoords","proximity","toolDataCanvasCoordinate","isPointNearTool","canvasPoint1","canvasPoint2","rect","_getRectangleImageCoordinates","rectangle","distanceToPoint","toolSelectedCallback","interactionType","_activateModify","handleSelectedCallback","movingTextBox","worldPosition","findIndex","p","_mouseUpCallback","_deactivateModify","_deactivateDraw","isHandleOutsideImage","_mouseDragCallback","deltaPoints","worldPosDelta","bottomLeftCanvas","bottomRightCanvas","topLeftCanvas","topRightCanvas","bottomLeftWorld","bottomRightWorld","topLeftWorld","topRightWorld","isInteractingWithTool","renderAnnotation","renderStatus","annotations","filterInteractableAnnotationsForElement","getTargetId","styleSpecifier","getStyle","activeHandleCanvasCoords","drawHandles","point0","point1","_calculateCachedStats","viewportUID","renderingEngineUID","sceneUID","worldPos1","worldPos2","targetUIDs","targetUID","imageVolume","_getImageVolumeFromTargetUID","scalarData","vtkImageData","worldPos1Index","worldPos2Index","worldToIndexVec3","floor","_isInsideVolume","iMin","iMax","jMin","jMax","kMin","kMax","worldWidth","worldHeight","getWorldWidthAndHeightFromTwoPoints","area","count","mean","stdDev","yMultiple","zMultiple","k","valueMinusMean","sqrt","Modality","eventType","triggerEvent","index1","index2","_getTargetVolumeUID","scene","volumeUID","volumeActors","getVolumeActors","_throttledCalculateCachedStats","throttle","trailing","cancel","startsWith","coloneIndex","indexOf","substring","getImageData","_getTargetStackUID","FrameOfReferenceSpecificAnnotationManager","getGroupKey","annotationGroupSelector","_imageVolumeModifiedHandler","frameOfReferenceSpecificAnnotations","getFramesOfReference","getAnnotations","groupKey","getAnnotation","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getNumberOfAnnotations","total","checkAndDefineIsLockedProperty","checkAndDefineIsVisibleProperty","groupAnnotations","toolAnnotations","splice","removeAnnotations","saveAnnotations","state","flat","getNumberOfAllAnnotations","removeAllAnnotations","IMAGE_VOLUME_MODIFIED","defaultFrameOfReferenceSpecificAnnotationManager","globalLockedAnnotationsSet","setAnnotationLocked","locked","makeEventDetail","lockedAnnotationsSet","add","added","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","isAnnotationLocked","getAnnotationsLockedCount","getOwnPropertyDescriptor","configurable","setIsLocked","getIsLocked","isExtensible","shouldDefineIsLockedProperty","enumerable","freeze","item","ANNOTATION_LOCK_CHANGE","selectedAnnotationUIDs","setAnnotationSelected","selected","preserveSelected","clearSelectionSet","selectAnnotation","deselectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","defaultManager","setAnnotationManager","resetAnnotationManager","manager","childUID","parentAnnotationUID","parentAnnotation","childUIDIndex","childAnnotationUIDs","childAnnotation","parentUID","getParentAnnotation","childAnnotationUID","HTMLDivElement","annotationManagerUID","invalidateAnnotation","currAnnotation","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","hide","showAllAnnotations","isAnnotationVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","lastVisible","hidden","ANNOTATION_VISIBILITY_CHANGE","_initializeConfig","colorHighlighted","colorSelected","colorLocked","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","getAnnotationToolStyles","config","getViewportToolStyles","getToolGroupToolStyles","toolGroups","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","mode","alternatives","list","getHierarchalPropertyStyles","Selected","Locked","autoGenerated","AutoGenerated","Default","triggerAnnotationAddedForElement","ANNOTATION_ADDED","triggerAnnotationAddedForFOR","getToolGroupsWithToolName","viewportsToRender","viewportInfo","triggerAnnotationModified","changeType","HandlesUpdated","triggerAnnotationCompleted","_triggerAnnotationCompleted","triggerContourAnnotationCompleted","AnnotationGroup","annotationUIDs","_isVisible","visibleFilter","unboundVisibleFilter","setVisible","baseEvent","findNearby","uids","remove","clear","getActiveSegmentationRepresentation","getActiveSegmentation","activeRepresentation","getSegmentation","setActiveSegmentationRepresentation","setSegmentationVisibility","visibility","segmentsHidden","indices","getUniqueSegmentIndices","getSegmentationVisibility","indicesSet","segmentIndex","setSegmentsVisibility","segmentIndices","segRepresentation","setSegmentVisibility","getSegmentVisibility","workerManager","getWebWorkerManager","polyDataCache","surfacesAABBCache","triggerWorkerProgress","progress","WEB_WORKER_PROGRESS","WorkerTypes","SURFACE_CLIPPING","clipAndCacheSurfacesForViewport","surfacesInfo","planesInfo","getSlicesClippingPlanes","currentSliceIndex","getSliceIndex","sort","a","b","sliceIndex","surfacesWithoutAABB","surface","surfacesAABB","executeTask","callbacks","aabb","updateSurfacesAABBCache","polyDataResults","polyDataResult","surfaceId","cacheId","pointToString","generateCacheId","lines","numberOfCells","actorCache","updatePolyDataCache","catch","error","getSurfaceActorUID","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentations","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","JSON","stringify","segmentationDataUID","segmentationRepresentation","getSegmentationRepresentationByUID","removeSegmentationRepresentation","Contour","_removeSegmentation","segmentationInputArray","segmentationInput","segInput","addSegmentation","getGlobalConfig","setGlobalConfig","segmentationConfig","getGlobalRepresentationConfig","representationType","representations","setGlobalRepresentationConfig","globalConfig","getToolGroupSpecificConfig","setToolGroupSpecificConfig","segmentationRepresentationConfig","getSegmentationRepresentationSpecificConfig","setSegmentationRepresentationSpecificConfig","getSegmentSpecificConfig","setSegmentSpecificConfig","getRepresentationSpecificConfig","representationInput","addSegmentationRepresentation","toolGroupSpecificConfig","colorLUTIndexToUse","colorLUTOrIndexInput","colorLUTOrIndex","nextIndex","getNextColorLUTIndex","colorLUTToAdd","addColorLUT","getColorLUTIndex","toolGroupSpecificRepresentation","colorLUTIndex","segmentationRepresentationSpecificConfig","segmentSpecificConfig","polySeg","currentToolGroupConfig","mergedConfig","renderInactiveSegmentations","representationInputArray","toolGroupSpecificRepresentationConfig","promises","all","Surface","computeVolumeSegmentationFromStack","segmentationImageIds","additionalDetails","volumeLoader","convertStackToVolumeSegmentation","removeOriginal","removeImageLoadObject","addEventListenerOnce","SEGMENTATION_RENDERED","triggerSegmentationDataModified","updateSegmentationState","computeStackSegmentationFromVolume","isAllImagesCached","imageCacheOffsetMap","imageIds","every","volumeUsedInOtherViewports","getVolumeViewports","hasVolumeId","decache","referencedImageIds","createImageIdReferenceMap","referencedVolumeId","referencedVolume","segmentationImageIdsToUse","convertToImageSlicesAndCache","_getImageIdReferenceMapForStackSegmentation","convertVolumeToStackSegmentation","removeVolumeLoadObject","updateStackSegmentationState","isSegmentIndexLocked","segmentsLocked","setSegmentIndexLocked","triggerSegmentationModified","getLockedSegments","colorLUT","unshift","setColorLUT","getColorForSegmentIndex","colorValue","setColorForSegmentIndex","colorReference","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","registerPolySegWorker","debouncedUpdateFunction","event","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","debounce","POLYSEG_CONTOUR_TO_SURFACE","createAndCacheSurfacesFromRaw","rawSurfacesData","findSegmentationRepresentationByUID","geometryIds","rawSurfaceData","slice","closedSurface","polys","geometryId","geometryLoader","SURFACE","geometryData","POLYSEG_LABELMAP_TO_SURFACE","computeSurfaceData","CONTOUR","contourRepresentationData","annotationUIDsMap","polylines","numPointsArray","results","convertContourToSurface","computeSurfaceFromContourSegmentation","computeSurfaceFromLabelmapSegmentation","isVolume","volume","getScalarData","convertLabelmapToSurface","surfaces","allSettled","errors","status","Boolean","computeAndAddSurfaceRepresentation","surfacesObj","getGeometry","setPoints","setPolys","geometry","updateSurfaceData","POLYSEG_CONTOUR_TO_LABELMAP","convertContourToVolumeLabelmap","segmentationVolumeId","volumeProps","annotationUIDsInSegmentMap","_getAnnotationMapFromSegmentation","newScalarData","getScalars","setData","convertContourToStackLabelmap","getImageLoadObject","imageLoader","segmentationsInfo","segImageId","segImage","imagePlaneModule","IMAGE_PLANE","columnCosines","rowCosines","rowPixelSpacing","columnPixelSpacing","rowCosineVec","colCosineVec","scanAxisNormal","newSegmentationsScalarData","segmentationInfo","imageFrame","pixelData","annotationMap","annotationUIDsInSegment","hasChildAnnotations","holesPolyline","POLYSEG_SURFACE_TO_LABELMAP","computeLabelmapData","rawLabelmapData","convertFunction","result","computeLabelmapFromContourSegmentation","segmentsGeometryIds","defaultActor","getDefaultActor","surfaceRepresentationData","segmentsInfo","getPoints","getPolys","convertSurfaceToVolumeLabelmap","computeLabelmapFromSurfaceSegmentation","computeAndAddLabelmapRepresentation","extractContourData","segmentIndexMap","rawResults","intersectionInfo","split","_","_extractLineSegments","contourData","lineSegments","linesNumberOfPoints","pointsInLine","computeContourData","rawContourData","segmentIndexToSurfaceId","surfaceIdToSegmentIndex","computeContourFromSurfaceSegmentation","pointsAndPolys","toString","computeContourFromLabelmapSegmentation","contoursData","line","pointIndex","contourSegmentationAnnotation","getViewReference","currentSet","createAndAddContourSegmentationsFromClippedSurfaces","fillAlpha","computeAndAddContourRepresentation","conversionPaths","canComputeRequestedRepresentation","representationInfo","enabled","existingRepresentationTypes","supportedTypes","representationTypeData","validateFn","getExistingRepresentationTypes","some","existingRepresentationType","fromRepresentationType","toRepresentationType","canConvertFromTo","registered","registerWorker","Worker","maxWorkerInstances","autoTerminateOnIdle","idleTimeThreshold","setActiveSegmentIndex","activeSegmentIndex","invalidateBrushCursor","getActiveSegmentIndex","defaultLabelmapConfig","defaultContourConfig","defaultSurfaceConfig","initialDefaultState","segmentations","defaultSegmentationStateManager","getState","getToolGroups","getColorLUT","lutIndex","toolGroupSegRepresentationsWithConfig","getAllSegmentationRepresentations","toolGroupSegReps","entries","_handleActiveSegmentation","segmentationData","removeSegmentation","segData","removedSegmentationRepresentation","toolGroupSegmentations","toolGroupStateWithConfig","setSegmentationRepresentationConfig","removeColorLUT","recentlyAddedOrRemovedSegmentationRepresentation","isContourRepresentation","segmentLabels","label","getSegmentations","suppressEvents","getSegmentationIdRepresentations","allRepresentations","foundRepresentations","foundRepresentation","allToolGroupRepresentations","foundToolGroupIds","getSegmentSpecificRepresentationConfig","setSegmentSpecificRepresentationConfig","getToolGroupIdFromSegmentationRepresentationUID","triggerSegmentationRemoved","triggerSegmentationRepresentationRemoved","removeSegmentationRepresentations","SEGMENTATION_REMOVED","segmentationIds","_getViewportIndex","arr","ar","_containsViewport","synchronizerId","eventName","eventHandler","_viewportOptions","_onEvent","_ignoreFiredEvents","_targetViewports","currentTarget","_sourceViewports","s","fireEvent","_enabled","_eventName","_eventHandler","_options","_auxiliaryEventNames","isDisabled","_hasSourceElements","setOptions","setEnabled","addTarget","addSource","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","t","removeTarget","_getViewportElement","hasSourceViewport","hasTargetViewport","sourceEvent","ex","then","vp1","vp2","unique","vps","concat","u","_getUniqueViewports","_remove","disableHandler","vUid","synchronizersFilteredByIds","synchronizers","synchronizer","notDisabled","sync","Synchronizer","pop","synchronizerIndex","re","toolGroupFilteredByIds","tg","addTool","ToolClass","toolAlreadyAdded","tools","toolClass","removeTool","addEnabledElement","svgLayer","svgLayerId","classList","pointerEvents","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","viewportUid","renderingEngineUid","dataset","elementHash","svgNodeCache","_setSvgNodeCache","addViewportElement","enabledElements","VIEWPORT_ELEMENT","_removeViewportFromSynchronizers","getSynchronizersForViewport","_removeViewportFromToolGroup","removeViewports","_removeEnabledElement","foundElementIndex","el","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","removeViewportElement","cancelActiveManipulations","toolsWithData","defaultState","isMultiPartToolActive","resetCornerstoneToolsState","resetSvgNodeCache","transformWorldToIndex","BidirectionalTool","toolProps","defaultToolProps","getTextLines","defaultGetTextLines","_endCallback","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","_dragDrawCallback","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyCallback","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","getAnnotationStyle","unit","dataId1","dataId2","secondLineUID","getLinkedTextBoxStyle","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","canvasTextBoxCoords","getTextBoxCoordsCanvas","drawLinkedTextBox","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos3","worldPos4","targetIds","image","getTargetIdImage","scale","dist1","_calculateLength","dist2","index3","index4","vector1","vector2","pos1","pos2","dz","roundNumber","calculateStats","allowOpenContours","isContourSegmentationTool","renderAnnotationInstance","renderContext","renderResult","AnnotationDisplayTool","imageURI","frameOfReference","VideoViewport","AnnotationTool","A","mouseMoveCallback","filteredAnnotations","canvas","annotationsNeedToBeRedrawn","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","statsCalculator","createAnnotation","annotationBaseData","baseData","createAnnotationForViewport","createAndAddAnnotation","isCanvasAnnotation","annotationCanvasCoordinate","isSuvScaled","scaling","PT","scalingModule","suvbw","lineOpacity","textbox","BaseTool","initialProps","strategies","defaultStrategy","activeStrategy","strategyOptions","Disabled","applyActiveStrategy","operationData","call","applyActiveStrategyCallback","callbackType","setConfiguration","newConfiguration","setActiveStrategy","strategyName","getTargetVolumeId","actorEntries","getClassName","getReferenceId","renderOutline","outlineWidthActive","outlineWidthInactive","activeSegmentOutlineWidthDelta","renderFill","renderFillInactive","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","isValidLabelmapConfig","MAX_NUMBER_COLORS","labelMapConfigCache","getRepresentationRenderingConfig","cfun","ofun","addPoint","polySegConversionInProgress","_getLabelmapConfig","toolGroupLabelmapConfig","segmentationRepresentationLabelmapConfig","isActiveLabelmap","segmentsLabelmapConfig","configToUse","outlineWidth","_needsTransferFunctionUpdate","segmentColor","cacheUID","oldConfig","forceOpacityUpdate","forceColorUpdate","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_addLabelmapToViewport","toolGroupConfig","renderingConfig","labelmapUID","defaultActorUID","isSameFrameOfReference","numColors","segmentSpecificLabelmapConfig","addRGBPoint","segmentOpacity","removePoint","addPointLong","getProperty","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","setLabelOutlineThickness","setVisibility","_setLabelmapColorAndOpacity","renderImmediate","_removeLabelmapFromToolGroupViewports","PanTool","touchDragCallback","_dragCallback","mouseDragCallback","deltaPointsWorld","focalPoint","updatedPosition","updatedFocalPoint","TrackballRotateTool","rotateIncrementDegrees","preMouseDownCallback","mapper","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","rotateCamera","centerWorld","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newPosition","newFocalPoint","newViewUp","Float32Array","lastPoints","currentPointsCanvas","lastPointsCanvas","clientWidth","clientHeight","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","dot","angleX","acos","sign","upVec","atV","rightV","forwardV","angleY","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint16Array","Int16Array","frame","buffer","_getMinMax","lower","upper","modality","newRange","viewportsContainingVolumeUID","isPreScaled","properties","getProperties","preScale","scaled","scalingParameters","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","windowWidth","windowCenter","imageDynamicRange","calculatedDynamicRange","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","round","getRange","imageDataRange","voxel","StackScrollTool","debounceIfNotLoaded","loop","deltaY","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","scroll","delta","debounceLoading","numberOfSlices","getNumberOfSlices","offsetHeight","PlanarRotateTool","startPoints","currentPointWorld","startPointWorld","centerCanvas","angleBetweenLines","v1","v2","cross","rotAngle","rotMat","rotatedViewUp","rotation","StackScrollMouseWheelTool","scrollSlabs","mouseWheelCallback","wheel","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","preTouchStartCallback","_dragParallelProjection","pinch","deltaDistance","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","currentPointsList","parallelProjection","_panCallback","DIRECTIONS","VolumeRotateMouseWheelTool","cz","ax","ay","az","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","jumpToWorld","RENDERING_DEFAULTS","CONSTANTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","viewportIndicators","autoPan","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","MAXIMUM_INTENSITY_BLEND","mobile","toolCenter","initializeViewport","_getAnnotations","cameraPosition","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","normal","_getViewportsInfo","resetCrosshairs","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","normal2","point2","normal3","point3","firstPlane","secondPlane","thirdPlane","jumpWorld","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","getViewportIds","_autoPanViewportIfNecessary","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","_areViewportIdArraysEqual","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","buildFromDegree","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","referenceColorCoordinates","circleRadius","drawCircle","_onNewVolume","e","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","otherViewportActors","sameScene","viewportsAnnotationsToUpdate","_applyDeltaShiftToSelectedViewportCameras","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","buildFromRadian","translate","otherViewportsIds","renderViewports","referenceAnnotations","viewportsIds","dotProd","projectedDelta","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","getToolInstance","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","onSetToolActive","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","VOLUME_VIEWPORT_NEW_VOLUME","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","c","_applyDeltaShiftToViewportCamera","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","viewportProperties","canvasPos","magnifyToolElement","magnifyElement","createElement","display","viewportInput","STACK","enableElement","magnifyViewport","setStack","pow","_dragEndCallback","disableElement","viewportElement","AdvancedMagnifyToolActions","AdvancedMagnifyTool","magnifyingGlass","zoomFactor","zoomFactorList","actions","showZoomFactorsList","method","bindings","mouseButton","Secondary","modifierKey","Shift","canvasHandlePoints","_getCanvasHandlePoints","magnifyViewportId","sourceViewportId","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","len","dispose","canvasTop","canvasBottom","canvasLeft","radiusPoint","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","update","canvasCenterPos","canvasRadius","AdvancedMagnifyViewportManager","getInstance","Actions","canvasPoint","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","focus","onChangeCallback","stopPropagation","keyCode","which","toLowerCase","option","title","defaultSelected","EPSILON","ReferenceLines","showFullDimension","_init","filterViewportsWithToolEnabled","sourceViewportCanvasCornersInWorld","onSetToolConfiguration","getEnabledElementByViewportId","sourceViewPlaneNormal","isParallel","targetViewportPlane","pointSet1","pointSet2","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","vec2","targetImage","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","indexToWorld","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","OverlayGridTool","sourceImageIds","pointSets","calculateImageIdPointSets","viewportData","rows","columns","imageIdNormal","getImageIdNormal","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","imageOrientationPatient","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","canvasPoints","polyLineUID","actorWorldPointsMap","polyData","getOutputData","polyDataUtils","colorArray","colorComponentToString","component","componentString","colorToString","getColor","ReferenceCursors","displayThreshold","positionSync","disableCursor","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","previousCamera","oldFocalPoint","cameraNormal","dotProduct","newWorldPos","isElementWithCursor","updateViewportImage","lineWidthBase","crosshairUIDs","centerSpace","lineLength","plane","currentMousePosition","closestIndex","setImageIdIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","renderViewport","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","offset","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","scaleSizeDisplayValue","scaleSizeUnits","LengthTool","units","cachedVolumeStats","ProbeTool","eventDispatchDetail","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","modalityUnitOptions","isViewportPreScaled","samplesPerPixel","baseIndex","modalityUnit","calibratedResults","hasEnhancedRegionValues","getModalityUnit","DragProbeTool","postMouseDownCallback","postTouchStartCallback","RectangleROITool","BasicStatsCalculator","areaUnit","boundsIJK","getWorldWidthAndHeightFromCorners","pointsInShape","pointInShapeCallback","statsCallback","stats","getStatistics","statsArray","array","EllipticalROITool","centerPointRadius","initialRotation","getRotation","canvasCorners","getCanvasEllipseCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","dYCanvas","newHalfCanvasWidth","canvasRight","dXCanvas","newHalfCanvasHeight","centerPoint","_getCanvasEllipseCenter","hasPixelSpacing","ellipseObj","xRadius","yRadius","zRadius","isEmptyArea","pointLPS","pointInEllipse","fast","ellipse","normalized","ellipseCanvasPoints","areaLine","CircleROITool","canvasEnd","radiusUnit","perimeter","aspect","radiusLine","DEFAULT_SPLINE_CONFIG","resolution","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","ContourSegmentationBaseTool","contourHoleAdditionModifierKey","decimate","epsilon","Cardinal","Class","CardinalSpline","CatmullRom","CatmullRomSpline","Linear","LinearSpline","BSpline","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","Primary","DeleteControlPoint","Ctrl","fireChangeOnUpdate","instance","isPointNearCurve","Completed","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","_mouseMoveCallback","lastCanvasPoint","_mouseDownCallback","doubleClick","worldPoint","closeContour","addNewPoint","closestControlPoint","getClosestControlPointWithinDistance","moveAnnotation","StatsUpdated","triggerChangeEvent","_renderStats","textboxStyle","addControlPointCallback","splineType","splineConfig","_getSplineConfig","maxDist","closestPointInfo","getClosestPoint","addControlPointAtU","uValue","deleteControlPointCallback","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","getCalibratedScale","getCalibratedAreaUnits","SplineTypes","getMouseModifier","cancelAnnotation","annotationStyle","controlPoints","annotationLocked","childAnnotations","it","join","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","getPolylinePoints","updateContourPolyline","numControlPoints","previewPolylinePoints","getPreviewPolylinePoints","controlPointsConnectors","createInterpolatedSplineControl","increment","contourAnnotation","createSpline","onInterpolationComplete","interpolation","splineConfigs","parseInt","setControlPoints","fixedResolution","fixedScale","SplineContourSegmentationTool","LivewireContourTool","snapHandleNearby","nearestEdge","showInterpolationPolyline","undo","proximitySquared","clearAnnotation","clearEditData","worldToSlice","sliceToWorld","worldPosOriginal","currentPath","getControlPoints","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","scissors","findMinNearby","pathPoints","findPathToPoint","addPoints","prependPath","confirmedPath","lastPoint","getLastPoint","addControlPoint","startSearch","updateAnnotation","imgWidth","imgHeight","slicePoint","editHandle","setupBaseEditData","rightPos","viewportImageData","sliceImageData","sliceToIndexMatrix","indexToSliceMatrix","ijkPoint","startPos","LivewireScissors","createInstanceFromRawPixelData","scissorsRight","currentPathNext","confirmedPathRight","numHandles","previousHandle","nextHandle","previousIndex","findHandlePolylineIndex","slicePos","pathPointsLeft","pathPointsRight","appendPath","canvasHandles","livewirePath","pointArray","imagePoints","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","repeatInterpolation","originalPoints","handleSmoothing","hIndex","testPoint","minPoint","acceptedPath","path","InterpolationUpdated","rendered","polylineCanvasPoints","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","stopImmediatePropagation","updatedText","doneChangingTextCallback","prompt","AngleTool","angleStartedNotYetCompleted","line1","canvasPoint3","line2","String","fromCharCode","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","mid1","midPoint","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","dist","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","units1","values2","units2","KeyImageTool","canvasPosition","AnnotationEraserTool","_deleteNearbyAnnotations","_toolInstances","annotationsToRemove","toolInstance","interactableAnnotations","RectangleScissorsTool","FILL_INSIDE","ERASE_INSIDE","activeSegmentationRepresentation","activeSegmentation","segmentLocking","toolMetadata","CircleScissorsTool","strategySpecificConfiguration","SphereScissorsTool","RectangleROIThresholdTool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","startIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","pointsInVolume","projectionPoints","projectionPointsImageIds","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","newProjectionPoints","newPoint","RectanglePoints","pointsInsideVolume","projectionPoint","worldProjectionPointIndex","endPos","halfSpacingInNormalDirection","imageIdIndex","dir","CircleROIStartEndThresholdTool","newStartIndex","_getStartSliceIndex","isMiddleSlice","lineWidthToUse","worldCenterIndex","numSlicesToPropagateFromStart","_getImageIdIndex","pos","isEqual","PaintFillTool","getDirection","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","floodFill","flooded","scalarDataPosition","framesModified","getFramesModified","boundaries","minJ","maxJ","seedIndex3D","getScalarDataPosition","z","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","OverlayMarkerType","ANNOTATED_CUBE","AXES","CUSTOM","OrientationMarkerTool","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","OVERLAY_MARKER_TYPES","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","polyDataURL","_resizeObservers","configuration_invalidated","initViewports","_subscribeToViewportEvents","cleanUpData","reset","resize","orientationMarker","orientationMarkers","updateViewport","CUBE","AXIS","VTPFILE","unobserve","resizeObserver","ResizeObserver","setTimeout","observe","offscreenMultiRenderWindow","getRenderWindow","getWidget","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","shallowCopy","setActiveScalars","setColorModeToDirectScalars","setMapper","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","methodName","charAt","toUpperCase","SegmentSelectTool","hoverTimeout","SelectMode","Border","searchRadius","hoverTimer","clearTimeout","_setActiveSegment","Inside","activeSegmentationReps","_setActiveSegmentForType","hoveredSegmentIndex","getSegmentAtWorldPoint","getSegmentAtLabelmapBorder","getHoveredContourSegmentationAnnotation","v","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","THRESHOLD","threshold","thresholdVolumeId","brushSize","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","AcceptPreview","RejectPreview","_previewData","timerStart","timer","NaN","isDrag","_editData","createEditData","Date","now","hoverData","_hoverData","createHoverData","getOperationData","OnInteractionStart","updateCursor","time","rejectPreview","previewCallback","Preview","OnInteractionEnd","acceptPreview","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","volumes","referenceId","referencedVolumeIdToThreshold","getActiveSegmentationData","brushCursor","_calculateCursor","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","strategy","computeInnerCircleRadius","brushCursorUID","dynamicRadiusInCanvas","circleUID1","isVolumeSegmentation","ContourWindingDirection","numSlicesToProject","sliceNormalIndex","calculateBoundingBox","isWorld","xMin","xMax","yMin","yMax","zMin","zMax","is3D","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","clip","val","low","high","addContourSegmentationAnnotation","annotationsUIDsSet","areSameSegment","firstAnnotation","secondAnnotation","firstSegmentation","secondSegmentation","isContourSegmentationAnnotation","closestDistance","testIndex","areCoplanarContours","firstViewPlaneNormal","secondViewPlaneNormal","firstPolyline","secondPolyline","firstDistance","secondDistance","findNextLink","contourPoints","cell","nextLine","remainingLines","findContours","firstCell","shift","extraContours","findContoursFromReducedSet","getDeduplicatedVTKPolyDataPoints","bypass","getLines","pointsArray","getPoint","linesArray","getNumberOfCells","getCell","newPoints","pt","newIndex","getIsPointInsidePolygon","vertices","inside","xi","yi","xj","yj","processContourHoles","contours","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","hContour","outerContour","innerContour","pointsNotEnclosed","checkEnclosed","contourHoleSet","holeIndex","contourIndex","generateContourSetsFromLabelmap","segments","segVolumeId","vol","getData","pixelsPerSlice","ContourSets","numSegments","segIndex","segment","sliceContours","scalars","dataType","containedSegmentIndices","isSliceEmptyForSegment","frameStart","setValue","mSquares","imageDataCopy","cValues","setContourValues","setMergePoints","reducedSet","FrameNumber","ContourSet","startIdx","endIdx","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","referenceImageId","validateAnnotation","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","random","register","RectangleROIStartEndThreshold","getContourHolesDataWorld","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","canvasHoleContour","acceptAutogeneratedInterpolations","selector","acceptAutoGenerated","polylineData","transforms","polylineWorldPoints","currentWindingDirection","currentClosedState","lastToFirstDist","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","TypeError","invokeFunc","args","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","cancelAnimationFrame","cancelTimer","flush","pending","annotationCanvasPoints","corners","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","_determineCorners","CalibrationTypes","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","getCalibratedLengthUnits","calibration","sequenceOfUltrasoundRegions","UNCALIBRATED","SQUARE","getCalibratedLengthUnitsAndScale","areaUnits","calibrationType","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","USER","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","getSphereBoundsInfo","circlePoints","radiusWorld","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJKWithCamera","getViewportForAnnotation","getViewportsForAnnotation","getEnabledElements","getAnnotationNearPoint","getAnnotationNearPointOnEnabledElement","found","findAnnotationNearPointByTool","currentId","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","calibrationOrScale","calibrateSpacing","AnnotationFrameRange","frameRangeExtractor","imageIdToFrames","framesToString","framesToImageId","newRangeString","setFrameRange","eventBase","getFrameRange","pointInSurroundingSphereCallback","centerIJK","spacings","getSpacing","minSpacing","maxRadiusIJK","ceil","sphereCornersIJK","getBoundingBoxAroundShape","_getBounds","sphereObj","getOrientationStringLPS","vector","orientation","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","addToolState","getToolState","ViewportStatus","dynamicVolumesPlayingMap","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","waitForRendered","numScrollSteps","currentStepIndex","getTargetImageIdIndex","frameTimeVectorEnabled","waitForRenderedCount","viewportStatus","RENDERED","_createStackViewportCinePlayContext","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","timeouts","isTimeVarying","sample","delay","sum","limit","_getPlayClipTimeouts","playClipAction","newStepIndex","newStepIndexOutOfRange","CLIP_STOPPED","playClipTimeoutHandler","setInterval","CLIP_STARTED","stopClip","toolState","getToolStateByViewportId","clearInterval","_stopClipWithData","dynamicCineElement","_getVolumesFromViewport","smoothAnnotation","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","resetPrefetchDelay","prefetch","stackPrefetchData","stackPrefetch","stack","currentImageIdIndex","indicesToRequest","removeFromList","isLoaded","imageLoadPoolManager","clearRequestStack","nearest","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","useNorm16Texture","rendering","targetBuffer","requestType","addRequest","onImageUpdated","target","indexOfCurrentImage","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","getConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","filterRequests","getCachedImageBasedOnImageURI","decodeTimeInMS","loadTimeInMS","sizeInBytes","usage","getMaxCacheSize","cacheFill","fillTime","fillSize","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","minIndex","maxIndex","dynamicVolume","frames","frameNumbers","maskVolumeId","imageCoordinate","dataInTime","ijkCoords","maskImageData","segScalarData","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","isSameVolume","indexValues","activeScalarData","segPointLPS","segValue","pointIJK","segPointIJK","overlapIJKMinMax","perFrameSum","averageCallback","averageValues","_getTimePointDataMask","coordinate","worldToIndex","allScalarData","scalarIndex","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","SUM","currentArray","SUBTRACT","AVERAGE","idx","idx3","getPolyDataPointIndexes","linesData","segmentSize","findStartingPoint","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","DEFAULTS","MULTIPLIER","RANGE_TEXT_POSITION","ColorbarRangeTextPosition","Right","TICKS_BAR_SIZE","Colorbar","Widget","props","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","_mouseOutCallback","hideTicks","_addVOIEventListeners","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startVOIRange","local","voiLower","voiUpper","newVoiRange","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_canvas","_createCanvas","_ticksBar","_createTicksBar","_rangeTextPosition","ticks","appendTo","rootElement","_addRootElementEventListeners","activeColormapName","colormapName","imageRange","currentVoiRange","onVoiChange","showFullImageRange","showFullPixelValueRange","createRootElement","onContainerResize","updateTicksBar","containerSize","colormaps","items","Name","cm","ColorbarCanvas","ticksProps","ColorbarTicks","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","client","page","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","rangeTextPosition","isRangeTextPositionValid","ticksBarTop","ticksBarLeft","Top","Left","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_viewportColormapModifiedCallback","_addCornerstoneEventListener","volumeActor","getRGBTransferFunction","interval","sumSquares","squaredDiffSum","newArray","stdDevWithSumSquare","named","singleArrayAsNumber","inverts","precalculated","precalculatePointInEllipse","invXRadiusSq","invYRadiusSq","invZRadiusSq","centerL","centerP","centerS","intersectAABB","aabb1","aabb2","minX","maxX","minY","maxY","distanceToPointSquared","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","intersectLine","r3","r4","r1","r2","denom","num","ORIENTATION_TOLERANCE","isPointOnLineSegment","p1","p2","z1","z2","mirror","mirrorPoint","staticPoint","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getArea","n","getSignedArea","aX","aY","bX","getWindingDirection","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getNormal2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","orientationValue","getLineSegmentIntersectionsIndexes","intersections","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","next","getSourceAndTargetPointsList","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","targetStartPointDistSquared","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","targetNormal","sourceNormal","dotNormals","subtractPolylines","subtractedPolylines","subtractedPolyline","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourceLen","intersectionPointIndexes","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","maxDistSquared","maxDistIndex","decimatedPolyline","srcIndex","dstIndex","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","minDistance","subPixelResolution","xDir","yDir","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","closeContourProximity","newCanvasPoint","commonData","lastWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectTo2D","sharedDimensionIndex","testPoints","points2D","firstDim","secondDim","isPointInsidePolyline3D","projectedHoles","hole2D","rectToLineSegments","pointInSphere","sphere","radius2","sourcePoints","MAX_SAFE_INTEGER","sourcePoint","_distanceBetween","INSIDE","OUTSIDE","clipT","tE","tL","box","da","db","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","isPlaneIntersectingAABB","pointInShapeFn","numComps","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","rowStep","columnStep","scanAxisStep","xMultiple","currentPos","startPosJ","startPosI","decimals","referenceVolume","AllBoundsIJK","pointsToUse","rectangleCornersIJK","g","accumulator","axisList","isAxisAlignedRectangle","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","vec","viewportType","useSlabThickness","sliceRangeInfo","sliceRange","spacingInNormalDirection","desiredStepIndex","VolumeScrollEventDetail","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","uuidv4","ChangeTypesForInterpolation","toolNames","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","isInterpolationUpdate","lpad","string","character","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","permute","perm","countNonZeroes","prunedPermutations","visits","bounds","currentArgs","flood","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","segmentIndicesCache","setSegmentationDirty","cached","isDirty","cachedResult","getCachedSegmentIndices","keySet","addVolumeSegmentIndices","segmentationImageId","addImageSegmentIndices","handleLabelmapSegmentation","getSegmentIndex","handleContourSegmentation","handleSurfaceSegmentation","thresholdVolumeInformation","overwrite","overlapType","baseVolumeIdx","volumeInfoList","overlaps","testOverlapRange","volumeInfo","voxelSpacing","voxelCenter","overlapBounds","overlapTest","testRange","referenceValues","computeOffsetIndex","insert","volumeSize","validToolNames","_validateAnnotations","getBoundsIJKFromRectangleAnnotations","outputSegmentationVolume","labelmaps","labelmap","outputData","arrayType","isValidRepresentationConfig","getDefaultRepresentationConfig","createLabelmapVolumeForViewport","input","setBrushSizeForToolGroup","viewportsInfoArray","getBrushSizeForToolGroup","toolInstances","brushToolInstance","setBrushThresholdForToolGroup","otherArgs","isDynamic","brushBasedToolInstances","getBrushThresholdForToolGroup","segmentationIndex","_handleSameSizeVolume","callbackOverlap","_handleDifferentSizeVolume","imageIdsArray","isLineInSegment","isInSegment","ijk1","toIJK","ijk2","testIJK","testSize","unitDelta","findLargestBidirectional","maxBidirectional","testCenter","ijk","createIsInSegment","sliceContour","bidirectional","createBidirectionalForSlice","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","distance2","handle0","handle1","unitMajor","maxMinorPoints","majorAxis","minorAxis","contourAndFindLargestBidirectional","createBidirectionalToolData","bidirectionalData","major0","major1","minor0","minor1","segmentContourAction","configurationData","getSegment","defaultGetSegment","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","segmentData","desiredRepresentation","getScalarValueFromWorld","indexIJK","voxelManager","createVolumeVoxelManager","getAtIJKPoint","getSegmentAtWorldForLabelmap","annotationsSet","getSegmentAtWorldForContour","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","segmentationRenderingEngine","_needsRender","_animationFrameSet","_animationFrameHandle","_renderFlaggedToolGroups","_throwIfDestroyed","_triggerRender","removeToolGroup","_reset","renderToolGroupSegmentations","_setToolGroupSegmentationToBeRenderedNextFrame","hasBeenDestroyed","_render","segmentationDisplayToolInstance","onSegmentationRender","renderSegmentation","getBrushToolInstances","equalsCheck","getVoxelOverlap","voxelCornersWorld","voxelCornersIJK","processVolumes","segmentationSpacing","getDeltaPoints","curr","getMeanPoints","last","_subtractPoints2D","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","parse","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","rotationAngle","pairedDistance","annotationRenderingEngine","_renderFlaggedViewports","elements","_viewportElements","_setViewportsToBeRenderedNextFrame","_setAllViewportsToBeRenderedNextFrame","elementsEnabled","enabledTools","draw","anyRendered","ANNOTATION_RENDERED","targetIdTokens","currentImageIndex","_getImageSliceData","lastSliceIndex","_getImageIndexToJump","_applyShift","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolOptions","toolMode","EPS","vpCamera","requireParallelNormals","vtkErrorMacro","vtkDebugMacro","m","vtkImageMarchingSquares","publicAPI","model","classHierarchy","getContourValues","contourValues","ids","pixelScalars","pixelPts","edgeLocator","newInstance","getPixelScalars","dims","increments","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","xyz","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","x0","insertEdge","requestData","inData","outData","getOrigin","extent","getExtent","computeIncrements","getKernels","cv","initialize","polydata","Uint32Array","timeEnd","DEFAULT_VALUES","initialValues","arguments","obj","algo","setGet","vtkImageMarchingSquares$1"],"sourceRoot":""}